package org.opentesting.services.adapter;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.services.encryption.Encryption;
import org.opentesting.services.file.FileManager;
import org.opentesting.services.jwt.JwtReceiver;
import org.opentesting.services.lock.Lock;
import org.opentesting.services.random.RandomData;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.OpenTestingConfig;
import org.opentesting.util.LogExecutionTime;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonMappingException;

import org.springframework.beans.factory.annotation.Autowired;

import lombok.extern.slf4j.Slf4j;

/**
 * abstract class to be used by every technology-specific implementation
 */
@Slf4j
public abstract class Adapter {

    @Autowired
    protected OpenTestingConfig e2ETestConfig;

    @Autowired
    private JwtReceiver jwtReceiver;

    @Autowired
    private Encryption encryption;

    @Autowired
    private Lock lock;

    @Autowired
    private OpenTestingConversion e2EConversion;

    @Autowired
    private RandomData randomData;

    @Autowired
    private FileManager fileManager;

    /**
     * used service name in test definition
     */
    public abstract String getServicename();

    /**
     * inject data into your adapter
     */
    public abstract boolean inject(String testid, TestCaseInjectionDTO inject, TestCaseRandomDataDTO randomdata);

    /**
     * execute check within your adapter
     */
    public abstract boolean check(TestCaseCheckDTO check, Object... args);

    /**
     * create required components to execute the checks
     */
    public abstract void createRequiredComponents(TestCaseDTO test);

    /**
     * create required timers at startup, default off
     */
    public List<String> getRequiredTimerCrons() {
        return new ArrayList<>();
    }

    /**
     * pause method could be overridden
     * @param byLabel
     */
    public void pause(boolean value, String byLabel) { }

    /**
     * service alias method could be overridden
     */
    public List<String> getServicenameAlias() {
        return new ArrayList<String>();
    }

    /**
     * service alias method could be overridden
     */
    public List<String> getAllServicenames() {
        List<String> res = new ArrayList<>(getServicenameAlias());
        res.add(this.getServicename());
        return res;
    }

    /**
     * read file from internal store
     * @param testid test case ID
     * @param filename filename 
     * @return file content
     */
    protected String readFile(String testid, String filename) {
        return fileManager.readFile(testid, filename);       
    }

    /**
     * read file from internal store and replace placeholders with random data
     * @param testid test case ID
     * @param filename filename
     * @param randomdata random data store
     * @return file content
     */
    protected String readFileAndAddTestData(String testid, String filename, TestCaseRandomDataDTO randomdata) {                
        return randomData.addRandomData(this.readFile(testid, filename), randomdata);
    }

    /**
     * inject random data into content
     * @param data content
     * @param randomdata random data store
     * @return content
     */
    protected String addRandomData(String data, TestCaseRandomDataDTO randomdata) {                
        return randomData.addRandomData(data, randomdata);
    }

    /**
     * check if checks contain 1 of a list of services
     * @param test test case
     * @param services service names
     * @return existence
     */
    protected boolean doChecksContainServices(TestCaseDTO test, List<String> services) {
        if (test.getChecks() != null) {
            for (TestCaseCheckDTO check : test.getChecks()) {
                if (services.contains(check.getService())) return true;
            }
        }
        return false;
    }

    /**
     * create connection key
     */
    protected String createConnectionKey(String testid, String connectstring, String connectuser, String connectpassword) {
        //test id at the beginning - this is used to remove blocks
        return testid+"#"+connectstring+"#"+connectuser+"#"+connectpassword;
    }

    /**
     * create parameter map
     * @param input paramers
     * @return parameter map
     */
    protected Map<String,String> toParameterMap(String input) {
        //broker=kafka-broker:9092;topic=mytopicname
        Map<String,String> result = new HashMap<>();
        if (input == null || input.length() < 1) return result;
        for (String str : input.split(";")) {

            //need to split using the first occurance of =
            int equalsSign=str.indexOf("=");    
            String key = str.substring(0, equalsSign);  
            String value = str.substring(equalsSign+1);             

            //add
            result.put(key, value);
        }
        return result;
    }

    /**
     * create the headers map
     */
    @LogExecutionTime
    protected Map<String,String> getHeaders(String testid, String header, TestCaseRandomDataDTO randomdata,
            String connectuser, String connectpassword, String jwtuser, String jwtpassword) throws JsonMappingException, JsonProcessingException {

        Map<String,String> headerMap = new HashMap<>();
        
        //check if there is a header file
        if (header != null && header.length() > 0) {

            //read the file and replace random data
            String headers = this.readFileAndAddTestData(testid, header, randomdata);

            //parse the JSON
            TypeReference<Map<String,String>> ref = new TypeReference<Map<String,String>>() {};
            Map<String,String> headersmap = e2EConversion.json2object(headers, ref);

            //replace connectuser and connectpassword
            headersmap = this.replaceUserAndPassword(headersmap, connectuser, connectpassword, jwtuser, jwtpassword);

            headerMap.putAll(headersmap);
        }       

        return headerMap;
    }

    /**
     * replace our placeholders
     */
    protected Map<String,String> replaceUserAndPassword(Map<String,String> headermap, String connectuser, String connectpassword,
            String jwtuser, String jwtpassword) {
        for (Map.Entry<String,String> entry : headermap.entrySet()) {
            if (entry.getValue() != null) {
                if (connectuser != null) entry.setValue(entry.getValue().replace("#connectuser#", connectuser));
                else entry.setValue(entry.getValue().replace("#connectuser#", ""));
                if (connectpassword != null) entry.setValue(entry.getValue().replace("#connectpassword#", decryptPassword(connectpassword)));
                else entry.setValue(entry.getValue().replace("#connectpassword#", ""));
                if (jwtuser != null) entry.setValue(entry.getValue().replace("#jwtuser#", jwtuser));
                else entry.setValue(entry.getValue().replace("#jwtuser#", ""));
                if (jwtpassword != null) entry.setValue(entry.getValue().replace("#jwtpassword#", decryptPassword(jwtpassword)));
                else entry.setValue(entry.getValue().replace("#jwtpassword#", ""));
            }
        }
        return headermap;
    }

    /**
     * add jwt token if required
     */
    @LogExecutionTime
    public Map<String,String> addJwt(String testid, Map<String,String> serviceparam, Map<String,String> headerMap, String key, String prefix) {
        String jwtPost = serviceparam.get("jwt-post");
        if (jwtPost != null && jwtPost.length() > 0) {
            String jwtParam = serviceparam.get("jwt-param");
            String jwtHeader = serviceparam.get("jwt-header");
            //Authorization: "Bearer <insert_your_JWT_here>"
            String token = jwtReceiver.requestToken(testid, jwtPost, jwtParam, jwtHeader);
            if (token != null) {
                headerMap.put(key, prefix + token);
            }
        }
        return headerMap;
    }

    /**
     * add JSON result to random data
     * @param testid test ID
     * @param check check
     * @param randomdata random data
     * @param response json
     * @return random data
     */
    @LogExecutionTime
    public TestCaseRandomDataDTO addCheckResult2Random(String testid, TestCaseCheckDTO check, TestCaseRandomDataDTO randomdata, String response) {
        if (check.getResult2random() != null && !check.getResult2random().isEmpty()) {
            //add data using the clean check id
            randomdata = addResult2Random(testid, OpenTestingConversion.getCleanCheckID(check.getCheckid()), randomdata,
                    response, check.getResult2random());
        }
        return randomdata;
    }

    /**
     * internally add values to random data
     * @param testid test ID
     * @param id check or inject ID
     * @param randomdatadto random data
     * @param response json
     * @return random data
     */
    private TestCaseRandomDataDTO addResult2Random(String testid, String id, TestCaseRandomDataDTO randomdatadto,
                                                   String response, List<String> attributes) {
        try {
            //parse JSON
            Map<String, Object> jsonMap = e2EConversion.json2Map(response);
            //log.warn(""+jsonMap);

            randomdatadto = checkRecursive(jsonMap, attributes, randomdatadto, id);

        } catch (Exception e) {
            log.warn(testid+"."+id+" cannot add result to random data: "+e.getMessage(), e);
        }
        return randomdatadto;
    }

    private TestCaseRandomDataDTO checkRecursive(Map<String, Object> jsonMap, List<String> attributes, TestCaseRandomDataDTO randomdatadto, String id) {

        //add data
        for (Map.Entry<String, Object> entry : jsonMap.entrySet()) {
            if (!(entry.getValue() instanceof Map)) {
                if (attributes.contains(entry.getKey())) {
                    if (randomdatadto == null) {
                        randomdatadto = new TestCaseRandomDataDTO();
                        randomdatadto.setRandomdata(new HashMap<>());
                    }
                    randomdatadto.getRandomdata().put("#"+id + "." + entry.getKey()+"#", "" + entry.getValue());
                }
            } else {
                //recursion
                randomdatadto.getRandomdata().putAll(checkRecursive((Map<String, Object>)entry.getValue(), attributes, randomdatadto, id).getRandomdata());
            }
        }

        return randomdatadto;
    }

    /**
     * decrypt password
     */
    protected String decryptPassword(String password) {
        return encryption.decrypt(password);
    }

    /**
     * add failed Connector to cache
     */
    protected void addFailedConnector(String connector) {
        lock.addLock(connector);
    }

    /**
     * remove failed Connector starting with
     */
    protected void removeFailedConnectorStartingWith(String connectorprefix) {
        lock.removeLocksStartingWith(connectorprefix);
    }

    /**
     * check if connector already failed
     */
    protected boolean isFailedConnector(String connector) {
        return lock.isLock(connector);
    }
    
}
