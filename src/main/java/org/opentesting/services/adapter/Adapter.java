package org.opentesting.services.adapter;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.opentesting.dto.ResponseDTO;
import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseDataExtractionDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.dto.TestCaseServiceDTO;
import org.opentesting.dto.TestCaseValidationDTO;
import org.opentesting.services.adapter.util.ReplacementHelper;
import org.opentesting.services.adapter.util.ValidationHelper;
import org.opentesting.services.execution.TestAbstractHandler;
import org.opentesting.services.lock.Lock;
import org.opentesting.util.OpenTestingConfig;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.exceptions.ValidationException;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.LogExecutionTime;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;

import lombok.Setter;
import lombok.extern.slf4j.Slf4j;

/**
 * abstract class to be used by every technology-specific implementation
 */
@Slf4j
public abstract class Adapter extends TestAbstractHandler {

    private static final String CHECKFAILED = "check failed:\n";

    @Setter //for testing
    protected OpenTestingConfig openTestingConfig;    

    @Setter //for testing
    private Lock lock;
  
    @Setter //for testing
    private ReplacementHelper replacementHelper;

    @Setter //for testing
    private ValidationHelper validationHelper; 

    protected Adapter(ApplicationContextProvider applicationContextProvider) {
        super(applicationContextProvider);
        openTestingConfig = applicationContextProvider.getBean(OpenTestingConfig.class);
        lock = applicationContextProvider.getBean(Lock.class);
        replacementHelper = applicationContextProvider.getBean(ReplacementHelper.class);
        validationHelper = applicationContextProvider.getBean(ValidationHelper.class);
    }

    /**
     * used service name in test definition
     */
    public abstract String getServicename(); 

    /**
     * inject data into your adapter
     */
    public abstract boolean inject(String testid, TestCaseInjectionDTO inject);

    /**
     * execute check within your adapter
     */
    public abstract boolean check(String testid, TestCaseCheckDTO check, Object... args);

    /**
     * create required components to execute the checks
     */
    public abstract void createRequiredComponents(TestCaseDTO test);    

    /**
     * pause method could be overridden
     * @param byLabel
     */
    public void pause(boolean value, String byLabel) { }

    /**
     * specify if check timer is required
     */
    public boolean checkTimerRequired() {
        return true;
    }

    /**
     * service alias method could be overridden
     */
    public List<String> getServicenameAlias() {
        return new ArrayList<>();
    }   

    /**
     * read file from internal store and replace placeholders with random data
     * @param testid test case ID
     * @param filename filename
     * @param randomdata random data store
     * @return file content
     * @throws NotFoundException
     */
    protected String getFileAndAddTestData(String testid, String filename, TestCaseRandomDataDTO randomdata) throws NotFoundException {                
        return replacementHelper.getFileAndAddTestData(testid, filename, randomdata);
    }

    /**
     * inject random data into content
     * @param data content
     * @param randomdata random data store
     * @return content
     */
    protected String addRandomData(String data, TestCaseRandomDataDTO randomdata) {                
        return replacementHelper.addRandomData(data, randomdata);
    }

    /**
     * check if checks contain 1 of a list of services
     * @param test test case
     * @param services service names
     * @return existence
     */
    protected boolean doChecksContainServices(TestCaseDTO test, List<String> services) {
        if (test.getChecks() != null) {
            for (TestCaseCheckDTO check : test.getChecks()) {
                if (services.contains(check.getService().getType())) return true;
            }
        }
        return false;
    }

    /**
     * create connection key
     */
    protected String createConnectionKey(String testid, String connectstring, String connectuser, String connectpassword) {
        //test id at the beginning - this is used to remove blocks
        return testid+"#"+connectstring+"#"+connectuser+"#"+connectpassword;
    }    

    /**
     * create the headers map
     * @throws NotFoundException
     */
    @LogExecutionTime
    protected Map<String,String> getHeaders(String testid, String header, TestCaseRandomDataDTO randomdata,
                                            TestCaseServiceDTO service) throws JsonProcessingException, NotFoundException {

        Map<String,String> headerMap = new HashMap<>();
        
        //check if there is a header file
        if (header != null && header.length() > 0) {

            //read the file and replace random data
            String headers = this.getFileAndAddTestData(testid, header, randomdata);

            //parse the JSON
            TypeReference<Map<String,String>> ref = new TypeReference<Map<String,String>>() {};
            Map<String,String> headersmap = openTestingConversion.json2object(headers, ref);

            //replace connectuser and connectpassword
            for (Map.Entry<String,String> entry : headersmap.entrySet()) {
                headerMap.put(entry.getKey(), replaceCustomAndUsernamePassword(entry.getValue(), service));
            }            
        }       

        return headerMap;
    }

    /**
     * replace our placeholders
     */
    protected String replaceCustomAndUsernamePassword(String input, TestCaseServiceDTO service) {
        return replacementHelper.replaceCustomAndUsernamePassword(input, service);
    }

    /**
     * add jwt token if required
     */
    @LogExecutionTime
    public Map<String,String> addJwt(String testid, TestCaseServiceDTO service, 
            Map<String,String> headerMap, String key, String prefix) {
        return replacementHelper.addJwt(testid, service, headerMap, key, prefix);
    }

    /**
     * add JSON result to random data
     * @param testid test ID
     * @param check check
     * @param randomdata random data
     * @param response json
     * @return random data
     */
    @LogExecutionTime
    public TestCaseRandomDataDTO addCheckDataextraction(String testid, TestCaseCheckDTO check, TestCaseRandomDataDTO randomdata, ResponseDTO response) {
        return replacementHelper.addCheckDataextraction(testid, check, randomdata, response);
    }

    /**
     * add JSON result to random data
     * @param testid test ID
     * @param randomdata random data
     * @param response json
     * @return random data
     */
    @LogExecutionTime
    public TestCaseRandomDataDTO addInjectDataextraction(String testid, TestCaseInjectionDTO injection, TestCaseRandomDataDTO randomdata, ResponseDTO response) {
        return replacementHelper.addInjectDataextraction(testid, injection, randomdata, response);
    }

    /**
     * use regex on data extraction
     * @param extract extract definition
     * @param data original data
     * @return regex cleaned data
     */
    public String getValueDataextraction(TestCaseDataExtractionDTO extract, Object data, String testid) {
        return replacementHelper.getValueDataextraction(extract, data, testid);
    }

    /**
     * decrypt password
     */
    protected String decryptPassword(String password) {
        return replacementHelper.decryptPassword(password);
    }

    /**
     * add failed Connector to cache
     */
    protected void addFailedConnector(String connector) {
        lock.addLock(connector);
    }

    /**
     * remove failed Connector starting with
     */
    protected void removeFailedConnectorStartingWith(String connectorprefix) {
        lock.removeLocksStartingWith(connectorprefix);
    }

    /**
     * check if connector already failed
     */
    protected boolean isFailedConnector(String connector) {
        return lock.isLock(connector);
    }

    /**
     * check adapter result using the validation objects
     * @return check successful or not
     * @throws NotFoundException
     * @throws ValidationException
     * @throws JsonProcessingException
     */
    public boolean validateResult(String testid, TestCaseCheckDTO check, TestCaseValidationDTO validation, ResponseDTO result, 
        String logInfo, boolean dolog) throws NotFoundException, ValidationException, JsonProcessingException {

        boolean retvalue = true;

        switch (validation.getType()) {
            case TestCaseValidationDTO.TYPE_CONTAINS:    
                if (!validationHelper.validateContains(testid, check, validation, result, dolog)) retvalue = false;
                break;
            case TestCaseValidationDTO.TYPE_EQUALS:
                if (!validationHelper.validateEquals(testid, check, validation, result, dolog)) retvalue = false;
                break;
            case TestCaseValidationDTO.TYPE_CONTAINSNOT:
                if (!validationHelper.validateContainsNot(testid, check, validation, result, dolog)) retvalue = false;
                break; 
            case TestCaseValidationDTO.TYPE_CONTAINSONEOF:
                retvalue = false;
                if (!validationHelper.validateContainsOneOf(testid, check, validation, result)) retvalue = true;
                break;   
            case TestCaseValidationDTO.TYPE_REGEX:                
                if (!validationHelper.validateRegex(testid, check, validation, result, dolog)) retvalue = false;
                break; 
            case TestCaseValidationDTO.TYPE_JSONSCHEMA:                
                if (!validationHelper.validateJsonSchema(testid, check, validation, result, dolog)) retvalue = false;
                break;
            default:
                log.warn("unknown type: >"+validation.getType()+"<");             
        }

        //add data extraction attributes
        check.setRandomdata(this.addCheckDataextraction(testid, check, check.getRandomdata(), result));

        //check failed
        if (!retvalue) log.info(CHECKFAILED+logInfo);

        return retvalue;
    }    

    /**
     * get Integer from String input, default is 0
     * @param input String input
     * @return Integer
     */
    protected Integer getInteger(String input) {
        if (input == null || input.isEmpty()) return 0;
        return Integer.parseInt(input);
    }

    /**
     * sort validations by order
     * @return sorted list
     */
    public List<TestCaseValidationDTO> sortValidations(List<TestCaseValidationDTO> input) {
        return validationHelper.sortValidations(input);
    }

}