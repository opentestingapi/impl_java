package org.opentesting.services.adapter.kafka;

import java.util.Optional;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.header.Header;
import org.opentesting.dto.TraceDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import brave.Span;
import brave.Tracer;
import lombok.extern.slf4j.Slf4j;

/*
 * generate and extract trace information
 */
@Component
@Slf4j
public class KafkaTrace {

    private static final String B3TRACEID = "X-B3-TraceId";
    private static final String B3SPANID = "X-B3-SpanId";
    private static final String B3PARENTSPANID = "X-B3-ParentSpanId";
    private static final String B3SAMPLED = "X-B3-Sampled";
    private static final String B3 = "b3";

    private static final String SETTINGCUSTOMHEADER = "setting custom header ";
    private static final String USINGCUSTOMHEADER = "using custom header ";

    @Autowired
    private Tracer tracer;

    @Value("${kafka.trace.headertraceid:}")
    private String kafkaTraceHeaderTraceId;

    @Value("${kafka.trace.headerspanid:}")
    private String kafkaTraceHeaderSpanId;

    @Value("${kafka.trace.headerparentspanid:}")
    private String kafkaTraceHeaderParentSpanId;

    @Value("${kafka.trace.headersampled:}")
    private String kafkaTraceHeaderSampled;

    /**
     * extract trace info
     * @param data message data
     * @return trace information
     */
    public TraceDTO extractTraceInfo(ConsumerRecord<String, String> data) {

        //not set values
        String traceId = "";
        String spanId = "";
        String parentSpanId = "";
        boolean sampled = false;

        //default headers used for B3
        traceId = Optional.ofNullable(getHeader(data, B3TRACEID, false)).orElse(traceId);
        spanId = Optional.ofNullable(getHeader(data, B3SPANID, false)).orElse(spanId);
        parentSpanId = Optional.ofNullable(getHeader(data, B3PARENTSPANID, false)).orElse(parentSpanId);
        for (Header h : data.headers().headers(B3SAMPLED)) {
            sampled = new String(h.value()).equalsIgnoreCase("1");
        }
        for (Header h : data.headers().headers(B3)) {
            //header: b3=f0790c6abfbd941d-7e2658424c8076a7-1
            String[] vals = new String(h.value()).split("-");
            traceId = vals[0];
            spanId = vals[1];
            sampled = vals[2].equalsIgnoreCase("1");
        }  

        //custom headers
        if (!kafkaTraceHeaderTraceId.isEmpty()) {
            traceId = Optional.ofNullable(getHeader(data, kafkaTraceHeaderTraceId, true)).orElse(traceId);            
        }
        if (!kafkaTraceHeaderSpanId.isEmpty()) {
            spanId = Optional.ofNullable(getHeader(data, kafkaTraceHeaderSpanId, true)).orElse(spanId);
        }
        if (!kafkaTraceHeaderParentSpanId.isEmpty()) {
            parentSpanId = Optional.ofNullable(getHeader(data, kafkaTraceHeaderParentSpanId, true)).orElse(parentSpanId);
        }
        if (!kafkaTraceHeaderSampled.isEmpty()) {
            for (Header h : data.headers().headers(kafkaTraceHeaderSampled)) {
                sampled = new String(h.value()).equalsIgnoreCase("1");
                log.debug(USINGCUSTOMHEADER+kafkaTraceHeaderSampled+": "+sampled);
            }
        }        

        //create Trace object
        return new TraceDTO(traceId, spanId, parentSpanId, sampled);
    }

    private String getHeader(ConsumerRecord<String, String> data, String header, boolean customLog) {
        String result = null;
        for (Header h : data.headers().headers(header)) {
            if (customLog) log.debug(USINGCUSTOMHEADER+header+": "+new String(h.value()));
            result = new String(h.value());
        }
        return result;
    }

    /**
     * add trace info to record
     * @param kafkarecord kafka record
     */
    public void generateTraceInfo(ProducerRecord<String, String> kafkarecord) {

        // add trace information
        Span span = tracer.currentSpan();

        //traceId
        String traceId = span.context().traceIdString();
        kafkarecord.headers().add(B3TRACEID, traceId.getBytes());
        if (!kafkaTraceHeaderTraceId.isEmpty()) {
            log.debug(SETTINGCUSTOMHEADER+kafkaTraceHeaderTraceId+": "+traceId);
            kafkarecord.headers().add(kafkaTraceHeaderTraceId, traceId.getBytes());
        }

        //spanId
        String spanId = span.context().spanIdString();
        kafkarecord.headers().add(B3SPANID, spanId.getBytes());
        if (!kafkaTraceHeaderSpanId.isEmpty()) {
            log.debug(SETTINGCUSTOMHEADER+kafkaTraceHeaderSpanId+": "+spanId);
            kafkarecord.headers().add(kafkaTraceHeaderSpanId, spanId.getBytes());
        }

        //parentSpanId        
        if (span.context().parentIdString() != null) {
            String parentSpanId = span.context().parentIdString();
            kafkarecord.headers().add(B3PARENTSPANID, parentSpanId.getBytes());
            if (!kafkaTraceHeaderParentSpanId.isEmpty()) {
                log.debug(SETTINGCUSTOMHEADER+kafkaTraceHeaderParentSpanId+": "+parentSpanId);
                kafkarecord.headers().add(kafkaTraceHeaderParentSpanId, parentSpanId.getBytes());
            }
        }

        //sampled
        String sampled = "" + ((span.context().sampled()) ? 1 : 0);
        kafkarecord.headers().add(B3SAMPLED, sampled.getBytes());
        if (!kafkaTraceHeaderSampled.isEmpty()) {
            log.debug(SETTINGCUSTOMHEADER+kafkaTraceHeaderSampled+": "+sampled);
            kafkarecord.headers().add(kafkaTraceHeaderSampled, sampled.getBytes());
        }        

        //default b3 header
        kafkarecord.headers().add(B3, (traceId + "-" + spanId + "-" + sampled).getBytes());        
    }
    
}