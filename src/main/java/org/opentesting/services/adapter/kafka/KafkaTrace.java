package org.opentesting.services.adapter.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.producer.ProducerRecord;
import org.apache.kafka.common.header.Header;
import org.opentesting.dto.TraceDTO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import brave.Span;
import brave.Tracer;
import lombok.extern.slf4j.Slf4j;

/*
 * generate and extract trace information
 */
@Component
@Slf4j
public class KafkaTrace {

    private static final String b3TraceId = "X-B3-TraceId";
    private static final String b3SpanId = "X-B3-SpanId";
    private static final String b3ParentSpanId = "X-B3-ParentSpanId";
    private static final String b3Sampled = "X-B3-Sampled";
    private static final String b3 = "b3";

    @Autowired
    private Tracer tracer;

    @Value("${kafka.trace.headertraceid:}")
    private String kafkaTraceHeaderTraceId;

    @Value("${kafka.trace.headerspanid:}")
    private String kafkaTraceHeaderSpanId;

    @Value("${kafka.trace.headerparentspanid:}")
    private String kafkaTraceHeaderParentSpanId;

    @Value("${kafka.trace.headersampled:}")
    private String kafkaTraceHeaderSampled;

    /**
     * extract trace info
     * @param data message data
     * @return trace information
     */
    public TraceDTO extractTraceInfo(ConsumerRecord<String, String> data) {

        //not set values
        String traceId = "";
        String spanId = "";
        String parentSpanId = "";
        Boolean sampled = null;   

        //default headers used for B3
        for (Header h : data.headers().headers(b3TraceId)) {
            traceId = new String(h.value());
        }
        for (Header h : data.headers().headers(b3SpanId)) {
            spanId = new String(h.value());
        }
        for (Header h : data.headers().headers(b3ParentSpanId)) {
            parentSpanId = new String(h.value());
        }
        for (Header h : data.headers().headers(b3Sampled)) {
            sampled = new String(h.value()).equalsIgnoreCase("1");
        }
        for (Header h : data.headers().headers(b3)) {
            //header: b3=f0790c6abfbd941d-7e2658424c8076a7-1
            String[] vals = new String(h.value()).split("-");
            traceId = vals[0];
            spanId = vals[1];
            sampled = vals[2].equalsIgnoreCase("1");
        }  

        //custom headers
        if (!kafkaTraceHeaderTraceId.isEmpty()) {
            for (Header h : data.headers().headers(kafkaTraceHeaderTraceId)) {
                traceId = new String(h.value());
                log.debug("using custom header "+kafkaTraceHeaderTraceId+": "+traceId);
            }
        }
        if (!kafkaTraceHeaderSpanId.isEmpty()) {
            for (Header h : data.headers().headers(kafkaTraceHeaderSpanId)) {
                spanId = new String(h.value());
                log.debug("using custom header "+kafkaTraceHeaderSpanId+": "+spanId);
            }
        }
        if (!kafkaTraceHeaderParentSpanId.isEmpty()) {
            for (Header h : data.headers().headers(kafkaTraceHeaderParentSpanId)) {
                parentSpanId = new String(h.value());
                log.debug("using custom header "+kafkaTraceHeaderParentSpanId+": "+parentSpanId);
            }
        }
        if (!kafkaTraceHeaderSampled.isEmpty()) {
            for (Header h : data.headers().headers(kafkaTraceHeaderSampled)) {
                sampled = new String(h.value()).equalsIgnoreCase("1");
                log.debug("using custom header "+kafkaTraceHeaderSampled+": "+sampled);
            }
        }        

        //create Trace object
        return new TraceDTO(traceId, spanId, parentSpanId, sampled);
    }

    /**
     * add trace info to record
     * @param record kafka record
     */
    public void generateTraceInfo(ProducerRecord<String, String> record) {

        // add trace information
        Span span = tracer.currentSpan();

        //traceId
        String traceId = span.context().traceIdString();
        record.headers().add(b3TraceId, traceId.getBytes());
        if (!kafkaTraceHeaderTraceId.isEmpty()) {
            log.debug("setting custom header "+kafkaTraceHeaderTraceId+": "+traceId);
            record.headers().add(kafkaTraceHeaderTraceId, traceId.getBytes());
        }

        //spanId
        String spanId = span.context().spanIdString();
        record.headers().add(b3SpanId, spanId.getBytes());
        if (!kafkaTraceHeaderSpanId.isEmpty()) {
            log.debug("setting custom header "+kafkaTraceHeaderSpanId+": "+spanId);
            record.headers().add(kafkaTraceHeaderSpanId, spanId.getBytes());
        }

        //parentSpanId        
        if (span.context().parentIdString() != null) {
            String parentSpanId = span.context().parentIdString();
            record.headers().add(b3ParentSpanId, parentSpanId.getBytes());
            if (!kafkaTraceHeaderParentSpanId.isEmpty()) {
                log.debug("setting custom header "+kafkaTraceHeaderParentSpanId+": "+parentSpanId);
                record.headers().add(kafkaTraceHeaderParentSpanId, parentSpanId.getBytes());
            }
        }

        //sampled
        String sampled = "" + ((span.context().sampled()) ? 1 : 0);
        record.headers().add(b3Sampled, sampled.getBytes());
        if (!kafkaTraceHeaderSampled.isEmpty()) {
            log.debug("setting custom header "+kafkaTraceHeaderSampled+": "+sampled);
            record.headers().add(kafkaTraceHeaderSampled, sampled.getBytes());
        }        

        //default b3 header
        record.headers().add(b3, (traceId + "-" + spanId + "-" + sampled).getBytes());        
    }
    
}