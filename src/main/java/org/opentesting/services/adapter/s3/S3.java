package org.opentesting.services.adapter.s3;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import jakarta.annotation.PreDestroy;

import org.opentesting.dto.ResponseDTO;
import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseValidationDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.exceptions.ConnectFailedException;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class S3 extends Adapter {

    private static final String BUCKETNAME = "bucketName";
    private static final String FILENAME = "fileName";
    private static final String REGION = "region";

    //Connection cache
    private HashMap<String, S3Connector> s3connectors = new HashMap<>();

    public S3(ApplicationContextProvider applicationContextProvider) {
        super(applicationContextProvider);
    }

    @Override
    public String getServicename() {
        return "s3";
    }

    @Override
    public boolean inject(String testid, TestCaseInjectionDTO inject) {        
        try {
            //connect
            S3Config config = createConfig(inject.getService().getConnectstring(),
                inject.getService().getUsername(),
                inject.getService().getPassword(),
                inject.getService().getCustom(REGION).getStringValue());
            S3Connector connection = getConnector(testid, config);
            if (connection == null) return false;

            //random data replacements
            String bucketName = this.addRandomData(inject.getService().getCustom(BUCKETNAME).getStringValue(), inject.getRandomdata());    
            log.debug(bucketName);
            String filename = this.addRandomData(inject.getService().getCustom(FILENAME).getStringValue(), inject.getRandomdata());  
            log.debug(filename);
            String data = this.addRandomData(this.getFile(testid, inject.getSourcefile()), inject.getRandomdata());
            log.debug(data);

            //push to S3
            connection.store(filename, data, bucketName);

            return true;
        } catch (Exception e) {
            log.error(testid+" "+inject.getInjectid()+" "+inject.getInstanceid()+": inject failed", e);
            return false;
        }
    }

    @Override
    public boolean check(String testid, TestCaseCheckDTO check, Object... args) {
        try {
            //connect
            S3Config config = createConfig(check.getService().getConnectstring(),
                check.getService().getUsername(),
                check.getService().getPassword(),
                check.getService().getCustom(REGION).getStringValue());
            S3Connector connection = getConnector(testid, config);
            if (connection == null) return false;

            //random data replacements
            String bucketName = this.addRandomData(check.getService().getCustom(BUCKETNAME).getStringValue(), check.getRandomdata());    
            log.debug(bucketName);
            String filename = this.addRandomData(check.getService().getCustom(FILENAME).getStringValue(), check.getRandomdata());    
            log.debug(filename);   

            //read file from S3
            ResponseDTO result = new ResponseDTO(connection.read(filename, bucketName));

            boolean retvalue = true;

            //check all validations, sort first
            for (TestCaseValidationDTO validation : sortValidations(check.getValidations())) {                
                if (!validateResult(testid, check, validation, result, "S3 "+bucketName+"/"+filename, true)) {
                    retvalue = false;
                }
            }

            return retvalue;
        } catch (Exception e) {
            log.error(testid+" "+check.getCheckid()+" "+check.getInstanceid()+": check failed", e);
            return false;
        }
    }

    private S3Config createConfig(String connectstring, String accessKey, String secretAccessKey, String region) {           
        //config creation
        S3Config conf = new S3Config();
        conf.setAccessKey(accessKey);
        conf.setSecretAccessKey(secretAccessKey);
        conf.setRegion(region);
        conf.setServiceEndpoint(connectstring);
        return conf;
    }

    /**
     * synchronized as we want have one connection only
     * @throws SQLException
     * @throws ClassNotFoundException
     */
    @LogExecutionTime
    private synchronized S3Connector getConnector(String testid, S3Config config) throws ConnectFailedException {

        //no reuse because of different password configurations
        String key = createConnectionKey(testid, config.getServiceEndpoint(), config.getAccessKey(), config.getRegion());
        S3Connector con = s3connectors.get(key);

        //block ones
        if (this.isFailedConnector(key)) {
            log.warn(testid + ": S3 connection blocked - please check credentials and upload testcase: " + config.getAccessKey() + "@" + config.getServiceEndpoint() + "@" + config.getRegion());
            return null;
        }

        try {
            //create new
            if (con == null) {
                con = new S3Connector(config);
                log.info("s3Connector created: "+con.getS3Config().getServiceEndpoint() + " for " + con.getS3Config().getAccessKey());
                s3connectors.put(key, con);
            }

            return con;
        } catch (Exception e) {            
            this.addFailedConnector(key);
            String jdbcmessage = testid+": S3 client failed - blocked: "+config.getAccessKey() + "@" + config.getServiceEndpoint() + "@" + config.getRegion();
            log.error(jdbcmessage, e);
            throw new ConnectFailedException(jdbcmessage);
        }
    }

    @Override
    @LogExecutionTime
    public void createRequiredComponents(TestCaseDTO test) {
        try {
            //remove blocked connections and existing connectors
            this.removeFailedConnectorStartingWith(test.getId());
            HashMap<String, S3Connector> newConnectors = new HashMap<>();
            for (Map.Entry<String,S3Connector> entry : s3connectors.entrySet()) {
                if (entry.getKey().startsWith(test.getId())) {
                    entry.getValue().close();
                    S3Config tmp = entry.getValue().getS3Config();
                    log.info("closed: "+tmp.getServiceEndpoint()+" - "+tmp.getAccessKey());
                } else {
                    newConnectors.put(entry.getKey(), entry.getValue());
                }
            }
            s3connectors = newConnectors;
        } catch (Exception e) {
            log.warn("cannot create timer", e);
        }
    }

    @Override
    @LogExecutionTime
    public List<String> getRequiredTimerCrons() {
        return Arrays.asList(openTestingConfig.getCheckcron());
    }

    @PreDestroy
    @LogExecutionTime
    private void close() {
        //parallel close
        s3connectors.values().parallelStream().forEach(
                con -> {
                    try {
                        con.close();
                    } catch (Exception e) {
                        log.warn("cannot close connector", e);
                    }
                }
        );
    }
    
}