package org.opentesting.services.adapter.cassandra;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.PreDestroy;

import org.opentesting.dto.ResponseDTO;
import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseValidationDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.exceptions.ConnectFailedException;

import com.datastax.driver.core.ResultSet;
import com.datastax.driver.core.Row;
import com.datastax.driver.core.Session;

import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class Cassandra extends Adapter {

    //connection cache
    private HashMap<String,CassandraConnector> cassandraconnectors = new HashMap<>();

    public Cassandra(ApplicationContextProvider applicationContextProvider) {
        super(applicationContextProvider);
    }

    @Override
    public String getServicename() {
        return "cassandra";
    }

    @Override
    @LogExecutionTime
    public boolean inject(String testid, TestCaseInjectionDTO inject) {
        try {
            //connect        
            Session session = getConnector(testid, inject.getService().getConnectstring(), 
                    inject.getService().getUsername(), inject.getService().getPassword());
            if (session == null) return false;

            //random data replacements
            String query = this.getFileAndAddTestData(testid, inject.getSourcefile(), inject.getRandomdata());
            log.debug(query);

            //execute query
            ResultSet rs = session.execute(query);

            return rs.wasApplied();
        } catch (Exception e) {
            log.error(testid+" "+inject.getInjectid()+" "+inject.getInstanceid()+": inject has thrown an error", e);
            return false;
        }
    }

    @Override
    @LogExecutionTime
    public boolean check(String testid, TestCaseCheckDTO check, Object... args) {        
        try {

            //connect            
            Session session = getConnector(testid, check.getService().getConnectstring(), 
                                check.getService().getUsername(), check.getService().getPassword());
            if (session == null) return false;

            boolean retvalue = true;

            //check all validations, sort first
            for (TestCaseValidationDTO validation : sortValidations(check.getValidations())) {

                //random data replacements            
                String query = this.getFileAndAddTestData(testid, validation.getRequest(), check.getRandomdata());     
                log.debug(query);

                //execute query
                ResultSet rs = session.execute(query);

                //SQL result should be JSON (from database)
                ResponseDTO result = new ResponseDTO("no database result");
                for (Row r : rs.all()) {
                    result.setPayload(r.getString(0));
                }

                //do validation
                if (!validateResult(testid, check, validation, result, "Cassandra "+query, true)) {
                    retvalue = false;
                }
            }
                     
            return retvalue;
        } catch (Exception e) {
            log.error(testid+" "+check.getCheckid()+" "+check.getInstanceid()+": check has thrown an error", e);
            return false;
        }
    }

    /**
     * synchronized as we want have one connection only
     * @throws ConnectFailedException
     */
    @LogExecutionTime
    private synchronized Session getConnector(String testid, String connectstring, String connectuser, String connectpassword) throws ConnectFailedException {

        //no reuse because of different password configurations
        String key = createConnectionKey(testid, connectstring, connectuser, connectpassword);
        CassandraConnector con = cassandraconnectors.get(key);

        //block ones
        if (this.isFailedConnector(key)) {
            log.warn(testid + ": Cassandra connection blocked - please check credentials and upload testcase: " + connectuser + "@" + connectstring);
            return null;
        }

        try {
            //create new
            if (con == null) {
                con = new CassandraConnector(connectstring, connectuser, decryptPassword(connectpassword));
                log.info("CassandraConnector created: " + con.getInfo());
                cassandraconnectors.put(key, con);
            }

            return con.getSession();
        } catch (Exception e) {
            String message = testid+": Cassandra connection failed - blocked: "+connectuser+"@"+connectstring;
            log.error(message, e);
            this.addFailedConnector(key);
            throw new ConnectFailedException(message);
        }
    }

    @Override
    @LogExecutionTime
    public void createRequiredComponents(TestCaseDTO test) {         
        try {
            //remove blocked connections and existing connectors
            this.removeFailedConnectorStartingWith(test.getId());
            HashMap<String,CassandraConnector> newConnectors = new HashMap<>();
            for (Map.Entry<String,CassandraConnector> entry : cassandraconnectors.entrySet()) {
                if (entry.getKey().startsWith(test.getId())) {
                    entry.getValue().close();
                    log.info("closed: "+entry.getValue().getInfo());
                } else {
                    newConnectors.put(entry.getKey(), entry.getValue());
                }
            }
            cassandraconnectors = newConnectors;
        } catch (Exception e) {
            log.warn("cannot create timer", e);
        }     
    }

    @Override
    @LogExecutionTime
    public List<String> getRequiredTimerCrons() {
        return Arrays.asList(openTestingConfig.getCheckcron());
    }

    @PreDestroy
    @LogExecutionTime
    private void close() {
        //parallel close
        cassandraconnectors.values().parallelStream().forEach(
            con -> {
                try {
                    con.close();                    
                } catch (Exception e) {
                    log.warn("cannot close connector", e);
                }
            }
        );              
    }
    
}
