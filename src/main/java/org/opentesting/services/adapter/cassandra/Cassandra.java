package org.opentesting.services.adapter.cassandra;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.PreDestroy;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.util.LogExecutionTime;
import com.datastax.driver.core.ResultSet;
import com.datastax.driver.core.Row;
import com.datastax.driver.core.Session;

import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class Cassandra extends Adapter {

    //connection cache
    private HashMap<String,CassandraConnector> connectors = new HashMap<>();

    @Override
    public String getServicename() {
        return "cassandra";
    }

    @Override
    @LogExecutionTime
    public boolean inject(String testid, TestCaseInjectionDTO inject, TestCaseRandomDataDTO randomdata) {
        try {
            //connect            
            Session session = getConnector(testid, inject.getConnectstring(), inject.getConnectuser(),
                    inject.getConnectpassword());
            if (session == null) return false;

            //Map<String,String> serviceparam = this.toParameterMap(inject.getServiceparam());

            //random data replacements
            String query = this.readFileAndAddTestData(testid, inject.getSourcefile(), randomdata);
            log.debug(query);       

            //execute query
            ResultSet rs = session.execute(query);

            return rs.wasApplied();
        } catch (Exception e) {
            log.error(testid+" "+inject.getInjectid()+": inject has thrown an error", e);
            return false;
        }
    }

    @Override
    @LogExecutionTime
    public boolean check(TestCaseCheckDTO check, Object... args) {        
        try {

            //connect            
            Session session = getConnector(check.getTestid(), check.getConnectstring(), check.getConnectuser(), check.getConnectpassword());
            if (session == null) return false;

            //random data replacements
            Map<String,String> serviceparam = this.toParameterMap(check.getServiceparam());
            String query = this.readFileAndAddTestData(check.getTestid(), serviceparam.get("cql"), check.getRandomdata());     
            log.debug(query);   

            //execute query
            ResultSet rs = session.execute(query); 
            String result = "no database result";
            for (Row r : rs.all()) {
                result = r.getString(0);
            }
            
            //random data replacements
            String expected = this.readFileAndAddTestData(check.getTestid(), check.getExpectedfile(), check.getRandomdata());                  

            //expected result check
            boolean retvalue = false;
            switch (check.getExpectedtype()) {
                case "contains":
                    if (result.contains(expected)) retvalue = true;
                    break;
                case "equals":
                    if (result.equals(expected)) retvalue = true;
                    break;        
                default:
                    log.warn("unknown expected type: >"+check.getExpectedtype()+"<");                           
            }

            //add result2random attributes
            check.setRandomdata(this.addCheckResult2Random(check.getTestid(), check, check.getRandomdata(), result));

            //check failed
            if (!retvalue) log.info("Cassandra check result:\n"+query+"\n>"+result+"<\n>"+expected+"<");
            
            return retvalue;

        } catch (Exception e) {
            log.error(check.getTestid()+" "+check.getCheckid()+": check has thrown an error", e);
            return false;
        }
    }

    /**
     * synchronized as we want have one connection only
     */
    @LogExecutionTime
    private synchronized Session getConnector(String testid, String connectstring, String connectuser, String connectpassword) throws Exception {

        //no reuse because of different password configurations
        String key = createConnectionKey(testid, connectstring, connectuser, connectpassword);
        CassandraConnector con = connectors.get(key);

        //block ones
        if (this.isFailedConnector(key)) {
            log.warn(testid + ": Cassandra connection blocked - please check credentials and upload testcase: " + connectuser + "@" + connectstring);
            return null;
        }

        try {
            //create new
            if (con == null) {
                con = new CassandraConnector(connectstring, connectuser, decryptPassword(connectpassword));
                log.info("CassandraConnector created: " + con.getInfo());
                connectors.put(key, con);
            }

            return con.getSession();
        } catch (Exception e) {
            String message = testid+": Cassandra connection failed - blocked: "+connectuser+"@"+connectstring;
            log.error(message, e);
            this.addFailedConnector(key);
            throw new Exception(message);
        }
    }

    @Override
    @LogExecutionTime
    public void createRequiredComponents(TestCaseDTO test) {         
        try {
            //remove blocked connections and existing connectors
            this.removeFailedConnectorStartingWith(test.getTestid());
            HashMap<String,CassandraConnector> newConnectors = new HashMap<String,CassandraConnector>();
            for (Map.Entry<String,CassandraConnector> entry : connectors.entrySet()) {
                if (entry.getKey().startsWith(test.getTestid())) {
                    entry.getValue().close();
                    log.info("closed: "+entry.getValue().getInfo());
                } else {
                    newConnectors.put(entry.getKey(), entry.getValue());
                }
            }
            connectors = newConnectors;
        } catch (Exception e) {
            log.warn("cannot create timer", e);
        }     
    }

    @Override
    @LogExecutionTime
    public List<String> getRequiredTimerCrons() {
        return Arrays.asList(e2ETestConfig.getCheckcron());
    }

    @PreDestroy
    @LogExecutionTime
    private void close() {
        //parallel close
        connectors.values().parallelStream().forEach(
            con -> {
                try {
                    con.close();                    
                } catch (Exception e) {
                    log.warn("cannot close connector", e);
                }
            }
        );              
    }
    
}
