package org.opentesting.services.adapter.rest;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.cert.X509Certificate;
import java.util.Map;
import java.util.Map.Entry;

import javax.annotation.PostConstruct;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.opentesting.util.OpenTestingConfig;
import org.opentesting.util.LogExecutionTime;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import brave.Span;
import brave.Tracer;
import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class RequestSender {

    @Autowired
    private OpenTestingConfig config;

    @Autowired
    private Tracer tracer;

    /**
    * we should use native Java code to get as abstract as possible - this is very hard to achive with Spring classes
    */
    @LogExecutionTime
    public String send(String type, String urlstr, Map<String,String> headers, String payload) throws MalformedURLException, SendException {
        URL url = new URL(urlstr);
        HttpURLConnection con = null;
        
        try {
            //define connection
            con = (HttpURLConnection) url.openConnection();
            con.setRequestMethod(type);
            for (Entry<String,String> entry : headers.entrySet()) {
                con.setRequestProperty(entry.getKey(), entry.getValue());
            }
            con.setConnectTimeout(config.getResttimeout()*1000);
            con.setReadTimeout(config.getResttimeout()*1000);
            con.setInstanceFollowRedirects(true);            
            con.setDoOutput(true);

            //add trace information
            Span span = tracer.currentSpan();
            con.setRequestProperty("X-B3-TraceId", span.context().traceIdString());
            con.setRequestProperty("X-B3-ParentSpanId", span.context().parentIdString());
            con.setRequestProperty("X-B3-Sampled", ""+((span.context().sampled().booleanValue()) ? 1 : 0));
            con.setRequestProperty("X-B3-SpanId", span.context().spanIdString());
            
            //payload if required
            if (payload != null && payload.length() > 0) {
                con.setDoInput(true);                
                try (OutputStreamWriter writer = new OutputStreamWriter(con.getOutputStream(), StandardCharsets.UTF_8)) {
                    writer.write(payload);
                }
            }

            //read status code
            int status = con.getResponseCode();
            log.info(urlstr+" returned: " + status);

            //read response
            StringBuilder content = new StringBuilder();
            try(BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(con.getInputStream()))){
                String line = bufferedReader.readLine();
                while(line != null) {
                    content.append(line);
                    line = bufferedReader.readLine();
                }
            }
            
            //return
            return content.toString();
        } catch (Exception e) {
            log.error(type+" failed: "+urlstr + " headers: " + headers, e);
            throw new SendException(e.getMessage());
        } finally {            
            if (con != null) con.disconnect();
        }
    } 
    
    @PostConstruct
    private void prepareSSL() {    
        try {

            // Create a trust manager that does not validate certificate chains
            TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {
                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                        return null; //NOSONAR
                    }
                    public void checkClientTrusted(X509Certificate[] certs, String authType) { //NOSONAR
                    }
                    public void checkServerTrusted(X509Certificate[] certs, String authType) { //NOSONAR
                    }
                }   
            };

            // Install the all-trusting trust manager
            SSLContext sc = SSLContext.getInstance("SSL"); //NOSONAR
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

            // Create all-trusting host name verifier
            HostnameVerifier allHostsValid = new HostnameVerifier() { //NOSONAR
                public boolean verify(String hostname, SSLSession session) {
                    return true; //NOSONAR
                }
            };

            // Install the all-trusting host verifier
            HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

        } catch (Exception e) {
            log.error("cannot prepare SSL for REST Adapter", e);
        }
    }
    
}
