package org.opentesting.services.adapter.rest;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.cert.X509Certificate;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import jakarta.annotation.PostConstruct;
import javax.net.ssl.HostnameVerifier;
import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.SSLSession;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;

import org.opentesting.util.OpenTestingConfig;
import org.opentesting.dto.ResponseDTO;
import org.opentesting.util.LogExecutionTime;

import org.springframework.stereotype.Component;

import io.micrometer.tracing.Span;
import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class RequestSender {

    private OpenTestingConfig config;

    public RequestSender(OpenTestingConfig configIn) {
        config = configIn;    
    }

    /**
    * we should use native Java code to get as abstract as possible - this is very hard to achive with Spring classes
    */
    @LogExecutionTime
    public ResponseDTO send(String testid, String type, String urlstr, Map<String,String> headers, String payload, Span span) throws MalformedURLException, SendException {
        URL url = new URL(urlstr);
        HttpURLConnection con = null;
        int status = 0;
        
        try {
            //define connection
            con = (HttpURLConnection) url.openConnection();
            con.setRequestMethod(type);
            for (Entry<String,String> entry : headers.entrySet()) {
                con.setRequestProperty(entry.getKey(), entry.getValue());
            }
            con.setConnectTimeout(config.getResttimeout()*1000);
            con.setReadTimeout(config.getResttimeout()*1000);
            con.setInstanceFollowRedirects(true);            
            con.setDoOutput(true);

            //add trace information
            if (span != null && span.context() != null) {
                con.setRequestProperty("X-B3-TraceId", span.context().traceId());
                con.setRequestProperty("X-B3-ParentSpanId", span.context().parentId());
                con.setRequestProperty("X-B3-Sampled", ""+((span.context().sampled().booleanValue()) ? 1 : 0));
                con.setRequestProperty("X-B3-SpanId", span.context().spanId());
            }
            
            //payload if required
            if (payload != null && payload.length() > 0) {
                con.setDoInput(true);                
                try (OutputStreamWriter writer = new OutputStreamWriter(con.getOutputStream(), StandardCharsets.UTF_8)) {
                    writer.write(payload);
                }
            }

            //read status code
            status = con.getResponseCode();
            if (status != 200) log.info(testid+": "+urlstr+" returned: " + status);

            //read response
            StringBuilder content = new StringBuilder();
            try(BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(con.getInputStream()))){
                String line = bufferedReader.readLine();
                while(line != null) {
                    content.append(line);
                    line = bufferedReader.readLine();
                }
            }
            
            //return
            ResponseDTO resp = new ResponseDTO(content.toString());            
            return addResponseHeaders(resp, con);
        } catch (Exception e) {
            log.error(testid+": "+type+" failed: "+urlstr + " headers: " + headers, e);
            String mes = e.getClass().getName() + " " + e.getMessage() + " " + e.getCause();
            if (status != 0) mes = "ResponseCode: " + status + " - " + mes;
            throw new SendException(mes);
        } finally {            
            if (con != null) con.disconnect();
        }
    } 

    /**
     * extract response headers
     */
    private ResponseDTO addResponseHeaders(ResponseDTO resp, HttpURLConnection con) {
        for (Map.Entry<String,List<String>> entry : con.getHeaderFields().entrySet()) {
            if (entry.getValue() != null && !entry.getValue().isEmpty()) {
                int counter = 0;
                for (String value : entry.getValue()) {
                    if (counter == 0) resp.putHeader(entry.getKey(), value);
                    else resp.putHeader(entry.getKey()+counter, value);
                    counter++;
                }                            
            }
        }
        return resp;
    }
    
    @PostConstruct
    private void prepareSSL() {    
        try {

            // Create a trust manager that does not validate certificate chains
            TrustManager[] trustAllCerts = new TrustManager[] {new X509TrustManager() {
                    public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                        return null; //NOSONAR
                    }
                    public void checkClientTrusted(X509Certificate[] certs, String authType) { //NOSONAR
                    }
                    public void checkServerTrusted(X509Certificate[] certs, String authType) { //NOSONAR
                    }
                }   
            };

            // Install the all-trusting trust manager
            SSLContext sc = SSLContext.getInstance("SSL"); //NOSONAR
            sc.init(null, trustAllCerts, new java.security.SecureRandom());
            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());

            // Create all-trusting host name verifier
            HostnameVerifier allHostsValid = new HostnameVerifier() { //NOSONAR
                public boolean verify(String hostname, SSLSession session) {
                    return true; //NOSONAR
                }
            };

            // Install the all-trusting host verifier
            HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);

        } catch (Exception e) {
            log.error("cannot prepare SSL for REST Adapter", e);
        }
    }
    
}
