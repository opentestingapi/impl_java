package org.opentesting.services.adapter.rest;

import java.net.MalformedURLException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseValidationDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.util.LogExecutionTime;

import org.opentesting.util.exceptions.NotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class Rest extends Adapter {

    @Autowired
    private RequestSender requestSender;    

    @Override
    public String getServicename() {
        return "rest";
    }

    @Override
    @LogExecutionTime
    public boolean inject(String testid, TestCaseInjectionDTO inject) {
        try {
            //connect info            
            String url = this.addRandomData(inject.getService().getConnectstring(), inject.getRandomdata());

            //header need replacement of connectuser, connectpassword, jwtuser, jwtpassword and randomdata
            Map<String, String> headerMap = this.getHeaders(testid, inject.getService().getCustom("header").getValue(), inject.getRandomdata(), inject.getService());

            //add jwt if required
            headerMap = this.addJwt(testid, inject.getService(), headerMap, "Authorization", "Bearer ");

            //send
            String response = null;
            String type = inject.getService().getCustom("type").getValue();
            if (type.equalsIgnoreCase("GET")) {
                response = requestSender.send("GET", url, headerMap, null);
            } else {
                //random data replacements for payload
                String payload = this.getFileAndAddTestData(testid, inject.getSourcefile(), inject.getRandomdata());
                response = requestSender.send(type.toUpperCase(), url, headerMap, payload);               
            }
            log.debug("response: "+response);

            //add result2random attributes
            inject.setRandomdata(this.addInjectResult2Random(testid, inject, inject.getRandomdata(), response));

            return true;
        } catch (Exception e) {
            log.error(testid+" "+inject.getInjectid()+" "+inject.getInstanceid()+": inject failed", e);
            return false;
        }
    }    

    @Override
    @LogExecutionTime
    public boolean check(String testid, TestCaseCheckDTO check, Object... args) {
        try {
            //connect info             
            String url = this.addRandomData(check.getService().getConnectstring(), check.getRandomdata());

            //header need replacement of connectuser, connectpassword, jwtuser, jwtpassword and randomdata
            Map<String, String> headerMap = this.getHeaders(testid, check.getService().getCustom("header").getValue(), check.getRandomdata(), check.getService());
            
            //add jwt if required
            headerMap = this.addJwt(testid, check.getService(), headerMap, "Authorization", "Bearer ");

            boolean retvalue = true;
            String getResponse = null;

            //check all validations, sort first
            for (TestCaseValidationDTO validation : sortValidations(check.getValidations())) {

                //send
                String sendInfo = url;

                //send the request
                SendRequestResultDO res = sendRequest(getResponse, sendInfo, url, headerMap, testid, check, validation);
                getResponse = res.getGetResponse();
                sendInfo = res.getSendInfo();

                //do validation
                if (!validateResult(testid, check, validation, res.getResult(), "Rest "+sendInfo)) {
                    retvalue = false;
                }
            }
         
            return retvalue;
        } catch (Exception e) {
            log.error(testid+" "+check.getCheckid()+" "+check.getInstanceid()+": check failed", e);
            return false;
        }
    }

    private SendRequestResultDO sendRequest(String getResponse, String sendInfo, String url,
                                            Map<String, String> headerMap, String testid, TestCaseCheckDTO check,
                                            TestCaseValidationDTO validation) throws MalformedURLException, NotFoundException {
        String type = check.getService().getCustom("type").getValue();
        String result = "";
        try {
            if (type.equalsIgnoreCase("GET")) {
                //we will not execute the GET multiple times, as payload does not change
                if (getResponse == null) getResponse = requestSender.send("GET", url, headerMap, null);
                result = getResponse;
            } else {                
                //random data replacements for payload
                String payload = this.getFileAndAddTestData(testid, validation.getRequest(), check.getRandomdata());
                sendInfo = sendInfo + " " + payload;
                result = requestSender.send(type.toUpperCase(), url, headerMap, payload);                    
            }
        } catch (SendException e) {
            log.error(e.getMessage(), e);
            //we do want to be able to check for HTTP codes and so on
            result = e.getMessage();
        }

        SendRequestResultDO res = new SendRequestResultDO();
        res.setResult(result);
        res.setGetResponse(getResponse);
        res.setSendInfo(sendInfo);
        return res;
    }

    @Override
    @LogExecutionTime
    public void createRequiredComponents(TestCaseDTO test) {         
        //nothing to do   
    }   
    
    @Override
    @LogExecutionTime
    public List<String> getRequiredTimerCrons() {
        return Arrays.asList(openTestingConfig.getCheckcron());
    }
    
}
