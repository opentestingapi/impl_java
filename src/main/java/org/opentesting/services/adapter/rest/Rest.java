package org.opentesting.services.adapter.rest;

import java.net.MalformedURLException;
import java.time.Instant;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseValidationDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.util.LogExecutionTime;

import org.opentesting.util.exceptions.NotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.TaskScheduler;
import org.springframework.stereotype.Component;

import brave.Span;
import brave.Tracer;
import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class Rest extends Adapter {

    @Autowired
    private RequestSender requestSender;

    @Autowired
    private TaskScheduler taskScheduler;

    @Autowired
    private Tracer tracer;

    @Override
    public String getServicename() {
        return "rest";
    }

    public List<String> getServicenameAlias() {
        return Arrays.asList("soap");
    }

    @Override
    @LogExecutionTime
    public boolean inject(String testid, TestCaseInjectionDTO inject) {
        try {
            //connect info            
            String url = this.addRandomData(inject.getService().getConnectstring(), inject.getRandomdata());

            //header need replacement of connectuser, connectpassword, jwtuser, jwtpassword and randomdata
            Map<String, String> headerMap = this.getHeaders(testid, inject.getService().getCustom("header").getStringValue(), inject.getRandomdata(), inject.getService());

            //add jwt if required
            headerMap = this.addJwt(testid, inject.getService(), headerMap, "Authorization", "Bearer ");

            //check for send delay
            Integer delay = getInteger(inject.getService().getCustom("senddelay").getStringValue());            

            //handle send delay
            String response = null;
            if (delay == 0) {
                //send without delay
                response = send(testid, inject, url, headerMap, tracer.currentSpan());

                //add result2random attributes
                inject.setRandomdata(this.addInjectResult2Random(testid, inject, inject.getRandomdata(), response));
            } else {
                //send with delay
                log.info(testid + " " + inject.getInjectid() + " " + inject.getInstanceid() + ": rest send delay: "+delay);
                DelayedSender ds = new DelayedSender(this, testid, inject, url, headerMap, tracer.currentSpan());
                taskScheduler.schedule(ds, Instant.now().plusMillis(delay));
            }    

            return true;
        } catch (Exception e) {
            log.error(testid+" "+inject.getInjectid()+" "+inject.getInstanceid()+": inject failed", e);
            return false;
        }
    }
    
    /**
     * send the request
     * @param testid test ID
     * @param inject inject instance
     * @param url URL
     * @param headerMap headers
     * @throws MalformedURLException
     * @throws SendException
     * @throws NotFoundException
     */
    public String send(String testid, TestCaseInjectionDTO inject, String url, Map<String, String> headerMap, Span span) throws MalformedURLException, SendException, NotFoundException {
        //send
        String response = null;
        String type = inject.getService().getCustom("type").getStringValue();
        if (type.equalsIgnoreCase("GET")) {
            response = requestSender.send("GET", url, headerMap, null, span);
        } else {
            //random data replacements for payload
            String payload = this.getFileAndAddTestData(testid, inject.getSourcefile(), inject.getRandomdata());
            response = requestSender.send(type.toUpperCase(), url, headerMap, payload, span);               
        }
        log.debug("response: "+response);
        return response;
    }

    @Override
    @LogExecutionTime
    public boolean check(String testid, TestCaseCheckDTO check, Object... args) {
        try {
            //connect info             
            String url = this.addRandomData(check.getService().getConnectstring(), check.getRandomdata());

            //header need replacement of connectuser, connectpassword, jwtuser, jwtpassword and randomdata
            Map<String, String> headerMap = this.getHeaders(testid, check.getService().getCustom("header").getStringValue(), check.getRandomdata(), check.getService());
            
            //add jwt if required
            headerMap = this.addJwt(testid, check.getService(), headerMap, "Authorization", "Bearer ");

            boolean retvalue = true;
            String getResponse = null;

            //check all validations, sort first
            for (TestCaseValidationDTO validation : sortValidations(check.getValidations())) {

                //send
                String sendInfo = url;

                //send the request
                SendRequestResultDO res = sendRequest(getResponse, sendInfo, url, headerMap, testid, check, validation);
                getResponse = res.getGetResponse();
                sendInfo = res.getSendInfo();

                //do validation
                if (!validateResult(testid, check, validation, res.getResult(), "Rest "+sendInfo, true)) {
                    retvalue = false;
                }
            }
         
            return retvalue;
        } catch (Exception e) {
            log.error(testid+" "+check.getCheckid()+" "+check.getInstanceid()+": check failed", e);
            return false;
        }
    }

    private SendRequestResultDO sendRequest(String getResponse, String sendInfo, String url,
                                            Map<String, String> headerMap, String testid, TestCaseCheckDTO check,
                                            TestCaseValidationDTO validation) throws MalformedURLException, NotFoundException {
        String type = check.getService().getCustom("type").getStringValue();
        String result = "";
        try {
            if (type.equalsIgnoreCase("GET")) {
                //we will not execute the GET multiple times, as payload does not change
                if (getResponse == null) getResponse = requestSender.send("GET", url, headerMap, null, tracer.currentSpan());
                result = getResponse;
            } else {                
                //random data replacements for payload
                String payload = this.getFileAndAddTestData(testid, validation.getRequest(), check.getRandomdata());
                sendInfo = sendInfo + " " + payload;
                result = requestSender.send(type.toUpperCase(), url, headerMap, payload, tracer.currentSpan());                    
            }
        } catch (SendException e) {
            log.error(e.getMessage(), e);
            //we do want to be able to check for HTTP codes and so on
            result = e.getMessage();
        }

        SendRequestResultDO res = new SendRequestResultDO();
        res.setResult(result);
        res.setGetResponse(getResponse);
        res.setSendInfo(sendInfo);
        return res;
    }

    @Override
    @LogExecutionTime
    public void createRequiredComponents(TestCaseDTO test) {         
        //nothing to do   
    }   
    
    @Override
    @LogExecutionTime
    public List<String> getRequiredTimerCrons() {
        return Arrays.asList(openTestingConfig.getCheckcron());
    }
    
}
