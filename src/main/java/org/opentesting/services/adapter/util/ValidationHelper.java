package org.opentesting.services.adapter.util;

import java.util.Collections;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.regex.PatternSyntaxException;

import org.opentesting.dto.ResponseDTO;
import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseValidationDTO;
import org.opentesting.services.jsonvalidation.JsonValidator;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.exceptions.ValidationException;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

/**
 * validation logic
 */
@Component
@Slf4j
public class ValidationHelper {

    private static final String EXPECTED = "<\n expected: >";

    private JsonValidator jsonValidator;

    private ReplacementHelper replacementHelper;

    public ValidationHelper(ApplicationContextProvider applicationContextProvider) {
        jsonValidator = applicationContextProvider.getBean(JsonValidator.class);
        replacementHelper = applicationContextProvider.getBean(ReplacementHelper.class);
    }

    public boolean validateContains(String testid, TestCaseCheckDTO check, TestCaseValidationDTO validation, 
        ResponseDTO result, boolean dolog) throws NotFoundException {
        for (String response : validation.getResponse()) {
            String expected = replacementHelper.getFileAndAddTestData(testid, response, check.getRandomdata());
            if (!result.getPayload().contains(expected)) {                
                if (dolog) log.info(testid+"."+check.getInstanceid()+" validateContains:\n actual: >"+result.getPayload()+EXPECTED+expected+"<");
                return false;
            }
        }
        return true;
    }

    public boolean validateEquals(String testid, TestCaseCheckDTO check, TestCaseValidationDTO validation, 
        ResponseDTO result, boolean dolog) throws NotFoundException {
        for (String response : validation.getResponse()) {
            String expected = replacementHelper.getFileAndAddTestData(testid, response, check.getRandomdata());
            if (!result.getPayload().equals(expected)) {                
                if (dolog) log.info(testid+"."+check.getInstanceid()+" equals:\n actual: >"+result.getPayload()+EXPECTED+expected+"<");
                return false;
            }
        }
        return true;
    }

    public boolean validateContainsNot(String testid, TestCaseCheckDTO check, TestCaseValidationDTO validation, 
        ResponseDTO result, boolean dolog) throws NotFoundException {
        for (String response : validation.getResponse()) {
            String expected = replacementHelper.getFileAndAddTestData(testid, response, check.getRandomdata());
            if (result.getPayload().contains(expected)) {                
                if (dolog) log.info(testid+"."+check.getInstanceid()+" contains not:\n actual: >"+result.getPayload()+EXPECTED+expected+"<");
                return false;
            }
        }
        return true;
    }

    public boolean validateRegex(String testid, TestCaseCheckDTO check, TestCaseValidationDTO validation, 
        ResponseDTO result, boolean dolog) throws NotFoundException {
        String regex = "";
        try {
            for (String response : validation.getResponse()) {
                regex = replacementHelper.getFileAndAddTestData(testid, response, check.getRandomdata());
                Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);
                Matcher matcher = pattern.matcher(result.getPayload());
                if (!matcher.matches()) {          
                    if (dolog) log.info(testid+"."+check.getInstanceid()+" regex:\n actual: >"+result.getPayload()+EXPECTED+regex+"<");
                    return false;
                }
            }
        } catch (PatternSyntaxException pse) {
            if (dolog) {
                log.info(testid+"."+check.getInstanceid()+" Did you forget to escape special regex characters? PatternSyntaxException: "+pse.getMessage());
                log.info(testid+"."+check.getInstanceid()+" regex:\n actual: >"+result.getPayload()+EXPECTED+regex+"<");
            }
            return false;
        }
        return true;
    }

    public boolean validateContainsOneOf(String testid, TestCaseCheckDTO check, TestCaseValidationDTO validation, 
        ResponseDTO result) throws NotFoundException {
        for (String response : validation.getResponse()) {
            String expected = replacementHelper.getFileAndAddTestData(testid, response, check.getRandomdata());
            if (result.getPayload().contains(expected)) return true;
        }
        return false;
    }

    public boolean validateJsonSchema(String testid, TestCaseCheckDTO check, TestCaseValidationDTO validation, 
        ResponseDTO result, boolean dolog) throws NotFoundException, ValidationException {
        for (String response : validation.getResponse()) {
            String schema = replacementHelper.getFileAndAddTestData(testid, response, check.getRandomdata());

            List<String> findings = jsonValidator.validateSchema(result.getPayload(), schema, false);
            if (!findings.isEmpty()) {                
                if (dolog) log.info(testid+"."+check.getInstanceid()+" jsonschema:\n actual: >"+result.getPayload()+EXPECTED+schema+"<\n"+findings);
                return false;
            }
        }
        return true;
    }

    /**
     * sort validations by order
     * @return sorted list
     */
    public List<TestCaseValidationDTO> sortValidations(List<TestCaseValidationDTO> input) {
        Collections.sort(input, (a, b) -> Integer.valueOf(a.getOrder()).compareTo(Integer.valueOf(b.getOrder())));
        return input;
    }
    
}