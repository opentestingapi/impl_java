package org.opentesting.services.adapter.util;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.opentesting.dto.ResponseDTO;
import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseCustomParameterDTO;
import org.opentesting.dto.TestCaseDataExtractionDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.dto.TestCaseServiceDTO;
import org.opentesting.services.encryption.Encryption;
import org.opentesting.services.execution.TestAbstractHandler;
import org.opentesting.services.jwt.JwtReceiver;
import org.opentesting.services.random.RandomData;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.exceptions.NotFoundException;
import org.springframework.stereotype.Component;

import com.fasterxml.jackson.dataformat.javaprop.JavaPropsMapper;

import lombok.extern.slf4j.Slf4j;

/**
 * handling of replacements in files
 */
@Component
@Slf4j
public class ReplacementHelper extends TestAbstractHandler {

    private static final String TARGETEMPTY = " target is empty! IGNORED";

    private RandomData randomData;

    private Encryption encryption;

    private JwtReceiver jwtReceiver;

    public ReplacementHelper(ApplicationContextProvider applicationContextProvider) {
        super(applicationContextProvider);
        randomData = applicationContextProvider.getBean(RandomData.class);
        encryption = applicationContextProvider.getBean(Encryption.class);
        jwtReceiver = applicationContextProvider.getBean(JwtReceiver.class);
    }

    /**
     * inject random data into content
     * @param data content
     * @param randomdata random data store
     * @return content
     */
    public String addRandomData(String data, TestCaseRandomDataDTO randomdata) {                
        return randomData.addRandomData(data, randomdata);
    }

    /**
     * read file from internal store and replace placeholders with random data
     * @param testid test case ID
     * @param filename filename
     * @param randomdata random data store
     * @return file content
     * @throws NotFoundException
     */
    public String getFileAndAddTestData(String testid, String filename, TestCaseRandomDataDTO randomdata) throws NotFoundException {                
        return randomData.addRandomData(this.getFile(testid, filename), randomdata);
    }

        /**
     * add JSON result to random data
     * @param testid test ID
     * @param check check
     * @param randomdata random data
     * @param response json
     * @return random data
     */
    @LogExecutionTime
    public TestCaseRandomDataDTO addCheckDataextraction(String testid, TestCaseCheckDTO check, TestCaseRandomDataDTO randomdata, ResponseDTO response) {
        if (check.getDataextraction() != null && !check.getDataextraction().isEmpty()) {
            //add data using the clean check id
            randomdata = addDataextraction(testid, check.getCheckid(), randomdata,
                    response, check.getDataextraction());
        }
        return randomdata;
    }

    /**
     * add JSON result to random data
     * @param testid test ID
     * @param randomdata random data
     * @param response json
     * @return random data
     */
    @LogExecutionTime
    public TestCaseRandomDataDTO addInjectDataextraction(String testid, TestCaseInjectionDTO injection, TestCaseRandomDataDTO randomdata, ResponseDTO response) {
        if (injection.getDataextraction() != null && !injection.getDataextraction().isEmpty()) {
            //add data using the inject id
            randomdata = addDataextraction(testid, injection.getInjectid(), randomdata,
                    response, injection.getDataextraction());
        }
        return randomdata;
    }

    /**
     * use regex on data extraction
     * @param extract extract definition
     * @param data original data
     * @return regex cleaned data
     */
    public String getValueDataextraction(TestCaseDataExtractionDTO extract, Object data, String testid) {
        if (extract.getTarget() == null || extract.getTarget().isEmpty()) {
            log.warn(testid+ " " + extract.getAttribute() + TARGETEMPTY);
            return "";
        }
        if (extract.getRegex() == null || extract.getRegex().isEmpty()) return ""+data;
        Pattern pattern = Pattern.compile(extract.getRegex());        
        Matcher matcher = pattern.matcher(""+data);
        if (matcher.find()) return matcher.group();
        return "";
    }

    /**
     * internally add values to random data
     * @param testid test ID
     * @param id check or inject ID
     * @param randomdatadto random data
     * @param response json
     * @return random data
     */
    private TestCaseRandomDataDTO addDataextraction(String testid, String id, TestCaseRandomDataDTO randomdatadto,
        ResponseDTO response, List<TestCaseDataExtractionDTO> extracts) {
        try {
            //parse using properties logic
            List<String> foundOnes = new ArrayList<>();
            JavaPropsMapper mapper = new JavaPropsMapper();
            Properties jsonPayload = new Properties();

            //payload will work with JSON only, but we will not care about the correctness - parse might be able to use it or not...
            boolean tryRecursive = false;
            if (response.getPayload().trim().startsWith("{")) {
                tryRecursive = true;
                jsonPayload = mapper.writeValueAsProperties(openTestingConversion.json2JsonNode(response.getPayload()));   
            } else {
                log.warn(testid+"."+id+" skipped payload processing as it does not start with {");
            }
                
            //data extraction independent from payload, as it might be the header only
            processDataextracts(extracts, jsonPayload, foundOnes, randomdatadto, response, testid);

            //parse JSON to use simple recursive logic
            Map<String,TestCaseDataExtractionDTO> openOnes = new HashMap<>();
            for (TestCaseDataExtractionDTO de : extracts) {
                if (!foundOnes.contains(de.getAttribute())) openOnes.put(de.getAttribute(), de);
            }

            //recursive logic shall be used only if it is a JSON
            if (tryRecursive && !openOnes.isEmpty()) {
                Map<String, Object> jsonMap = openTestingConversion.json2Map(response.getPayload());           
                randomdatadto = checkRecursive(jsonMap, openOnes, randomdatadto, testid);
            }

            //user hint
            if (!openOnes.isEmpty()) {
                printUserHint(testid, id, jsonPayload, response, openOnes);  
            }

        } catch (Exception e) {
            log.warn(testid+"."+id+" cannot add result to random data: "+e.getMessage(), e);
        }
        
        return randomdatadto;
    }

    /**
     * extract data from property map and headers
     */
    private void processDataextracts(List<TestCaseDataExtractionDTO> extracts, Properties jsonPayload, List<String> foundOnes,
        TestCaseRandomDataDTO randomdatadto, ResponseDTO response, String testid) {
        for (TestCaseDataExtractionDTO de : extracts) {                
            if (de.getSource().equals(TestCaseDataExtractionDTO.SOURCE_PAYLOAD) && jsonPayload.containsKey(de.getAttribute())) {
                foundOnes.add(de.getAttribute());                
                randomdatadto.add(de.getTarget(), getValueDataextraction(de, jsonPayload.get(de.getAttribute()), testid));                 
            }
            if (de.getSource().equals(TestCaseDataExtractionDTO.SOURCE_HEADER) && response.getHeader().containsKey(de.getAttribute())) {
                foundOnes.add(de.getAttribute());                
                randomdatadto.add(de.getTarget(), getValueDataextraction(de, response.getHeader(de.getAttribute()), testid));   
            }
        }
    }

    /**
     * print user hint about not found keys and available ones
     */
    private void printUserHint(String testid, String id, Properties jsonPayload, ResponseDTO response, Map<String,TestCaseDataExtractionDTO> openOnes) {
        log.info(testid+"."+id+" not found keys: "+openOnes.keySet());
        if (jsonPayload.stringPropertyNames() != null) {
            List<String> keys = new ArrayList<>(jsonPayload.stringPropertyNames());  
            Collections.sort(keys);          
            log.info(testid+"."+id+" here are the available payload keys: "+keys);
        }
        if (response.getHeader().keySet() != null) {
            List<String> keys = new ArrayList<>(response.getHeader().keySet());       
            //sort will fail because of null values        
            log.info(testid+"."+id+" here are the available header keys: "+keys);
        }     
    }

    @SuppressWarnings("unchecked")
    private TestCaseRandomDataDTO checkRecursive(Map<String, Object> jsonMap, Map<String,TestCaseDataExtractionDTO> extracts, TestCaseRandomDataDTO randomdatadto, String testid) {

        //add data
        for (Map.Entry<String, Object> entry : jsonMap.entrySet()) {
            if (!(entry.getValue() instanceof Map)) {
                if (extracts.keySet().contains(entry.getKey())) {
                    if (randomdatadto == null) {
                        randomdatadto = new TestCaseRandomDataDTO();
                        randomdatadto.setDatamap(new HashMap<>());
                    }
                    TestCaseDataExtractionDTO extract = extracts.get(entry.getKey());                    
                    randomdatadto.add(extract.getTarget(), getValueDataextraction(extract, entry.getValue(), testid));
                }
            } else {
                //recursion
                randomdatadto.addAll(checkRecursive((Map<String, Object>)entry.getValue(), extracts, randomdatadto, testid).getDatamap());
            }
        }

        return randomdatadto;
    }

    /**
     * replace our placeholders
     */
    public String replaceCustomAndUsernamePassword(String input, TestCaseServiceDTO service) {
        input = replace("username", service.getUsername(), input);
        input = replace("password", service.getPassword(), input);
        for (TestCaseCustomParameterDTO custom : service.getCustom()) {
            input = replace(custom.getKey(), custom.getStringValue(), input);
        }
        return input;
    }

    /**
     * replace #key# in content with decrypted value
     * @param key key
     * @param value value (can be encrypted)
     * @param content content
     * @return content
     */
    private String replace(String key, String value, String content) {
        if (value != null) return content.replace("#"+key+"#", decryptPassword(value));
        return content.replace("#"+key+"#", "");
    }

    /**
     * add jwt token if required
     */
    @LogExecutionTime
    public Map<String,String> addJwt(String testid, TestCaseServiceDTO service, 
            Map<String,String> headerMap, String key, String prefix) {
                
        String jwtPost = service.getCustom("jwtpost").getStringValue();
        String jwtParam = service.getCustom("jwtparam").getStringValue();
        String jwtHeader = service.getCustom("jwtheader").getStringValue();

        //replace placeholders like #jwtpassword# and #jwtusername#
        for (TestCaseCustomParameterDTO custom : service.getCustom()) {            
            jwtPost = replace(custom.getKey(), custom.getStringValue(), jwtPost);
            jwtParam = replace(custom.getKey(), custom.getStringValue(), jwtParam);
            jwtHeader = replace(custom.getKey(), custom.getStringValue(), jwtHeader);            
        }

        //do auth
        if (jwtPost != null && jwtPost.length() > 0) {            
            //Authorization: "Bearer <insert_your_JWT_here>"
            String token = jwtReceiver.requestToken(testid, jwtPost, jwtParam, jwtHeader);
            if (token != null) {
                headerMap.put(key, prefix + token);
            }
        }

        return headerMap;
    }

    /**
     * decrypt password
     */
    public String decryptPassword(String password) {
        return encryption.decrypt(password);
    }
    
}