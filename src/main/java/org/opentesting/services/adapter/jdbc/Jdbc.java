package org.opentesting.services.adapter.jdbc;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseValidationDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.exceptions.ConnectFailedException;

import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.annotation.PreDestroy;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

@Component
@Slf4j
public class Jdbc extends Adapter {


    //Connection cache
    private HashMap<String, JdbcConnector> jdbcconnectors = new HashMap<>();
    
    @Override
    public String getServicename() {
        return "jdbc";
    }

    public List<String> getServicenameAlias() {
        return Arrays.asList("oracle", "postgre");
    }
    
    @Override
    @LogExecutionTime
    public boolean inject(String testid, TestCaseInjectionDTO inject) {
        Statement stmt = null;
        try {
            //connect
            Connection connection = getConnector(testid, inject.getService().getConnectstring(), 
                inject.getService().getUsername(), inject.getService().getPassword());
            if (connection == null) return false;

            //random data replacements
            String query = this.getFileAndAddTestData(testid, inject.getSourcefile(), inject.getRandomdata());
            log.debug(query);

            //create statement
            stmt = connection.createStatement();

            //execute (might be a list with statements, so we cannot check for return code 1)
            stmt.executeUpdate(query);

            return true;
        } catch (Exception e) {
            log.error(testid+" "+inject.getInjectid()+" "+inject.getInstanceid()+": inject failed", e);
            return false;
        } finally {
            if (stmt != null)
                try {
                    stmt.close();
                } catch (SQLException e) {
                    log.warn("cannot close statement", e);
                }
        }
    }

    @Override
    @LogExecutionTime
    public boolean check(String testid, TestCaseCheckDTO check, Object... args) {
        
        try {
            //connect
            Connection connection = getConnector(testid, check.getService().getConnectstring(), 
                check.getService().getUsername(), check.getService().getPassword());
            if (connection == null) return false;

            boolean retvalue = true;

            //check all validations, sort first
            for (TestCaseValidationDTO validation : sortValidations(check.getValidations())) {

                //random data replacements            
                String query = this.getFileAndAddTestData(testid, validation.getRequest(), check.getRandomdata());     
                log.debug(query);

                //execute query
                if (!executeQuery(connection, query, testid, check, validation)) {
                    retvalue = false;
                }                
            }

            return retvalue;
        } catch (Exception e) {
            log.error(testid+" "+check.getCheckid()+" "+check.getInstanceid()+": check failed", e);
            return false;
        }
    }

    /**
     * execute query and validate
     * @param connection JDBC connection
     * @param query SQL
     * @param testid test ID
     * @param check check instance
     * @param validation validation instance
     * @return validation successful
     */
    private boolean executeQuery(Connection connection, String query, String testid, TestCaseCheckDTO check, TestCaseValidationDTO validation) {
        //execute query
        try (Statement stmt = connection.createStatement(); 
                ResultSet rs = stmt.executeQuery(query)) {  

            //SQL result should be JSON (from database)
            String result = "no database result";
            if (rs.next()) {
                result = rs.getString(1); //jdbc driver needs 1 instead of 0
            }

            //do validation
            return validateResult(testid, check, validation, result, "JDBC "+query);            
        } catch (Exception e) {
            log.error(testid+" "+check.getCheckid()+" "+check.getInstanceid()+": validation failed: "+validation.getOrder(), e);
            return false;
        }
    }

    /**
     * synchronized as we want have one connection only
     * @throws SQLException
     * @throws ClassNotFoundException
     */
    @LogExecutionTime
    private synchronized Connection getConnector(String testid, String connectstring, String connectuser, String connectpassword) throws ConnectFailedException {

        //no reuse because of different password configurations
        String key = createConnectionKey(testid, connectstring, connectuser, connectpassword);
        JdbcConnector con = jdbcconnectors.get(key);

        //block ones
        if (this.isFailedConnector(key)) {
            log.warn(testid + ": database connection blocked - please check credentials and upload testcase: " + connectuser + "@" + connectstring);
            return null;
        }

        try {
            //create new
            if (con == null) {
                con = new JdbcConnector(connectstring, connectuser, decryptPassword(connectpassword));
                log.info("jdbcConnector created: "+con.getInfo());
                jdbcconnectors.put(key, con);
            }

            return con.getConnection();
        } catch (Exception e) {            
            this.addFailedConnector(key);
            String jdbcmessage = testid+": JDBC connection failed - blocked: "+connectuser+"@"+connectstring;
            log.error(jdbcmessage, e);
            throw new ConnectFailedException(jdbcmessage);
        }
    }

    @Override
    @LogExecutionTime
    public void createRequiredComponents(TestCaseDTO test) {
        try {
            //remove blocked connections and existing connectors
            this.removeFailedConnectorStartingWith(test.getId());
            HashMap<String, JdbcConnector> newConnectors = new HashMap<>();
            for (String key : jdbcconnectors.keySet()) {
                if (key.startsWith(test.getId())) {
                    jdbcconnectors.get(key).close();
                    log.info("closed: "+jdbcconnectors.get(key).getInfo());
                } else {
                    newConnectors.put(key, jdbcconnectors.get(key));
                }
            }
            jdbcconnectors = newConnectors;
        } catch (Exception e) {
            log.warn("cannot create timer", e);
        }
    }

    @Override
    @LogExecutionTime
    public List<String> getRequiredTimerCrons() {
        return Arrays.asList(openTestingConfig.getCheckcron());
    }

    @PreDestroy
    @LogExecutionTime
    private void close() {
        //parallel close
        jdbcconnectors.values().parallelStream().forEach(
                con -> {
                    try {
                        con.close();
                    } catch (Exception e) {
                        log.warn("cannot close connector", e);
                    }
                }
        );
    }

}
