package org.opentesting.services.adapter.jdbc;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.util.LogExecutionTime;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.annotation.PreDestroy;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.List;

@Component
@Slf4j
public class Jdbc extends Adapter {


    //Connection cache
    private HashMap<String, JdbcConnector> connectors = new HashMap<>();
    
    @Override
    public String getServicename() {
        return "jdbc";
    }

    public List<String> getServicenameAlias() {
        return Arrays.asList(new String[] { "oracle", "postgre" });
    }
    
    @Override
    @LogExecutionTime
    public boolean inject(String testid, TestCaseInjectionDTO inject, TestCaseRandomDataDTO randomdata) {
        Statement stmt = null;
        try {
            //connect
            Connection connection = getConnector(testid, inject.getConnectstring(), inject.getConnectuser(), inject.getConnectpassword());
            if (connection == null) return false;

            //random data replacements
            String query = this.readFileAndAddTestData(testid, inject.getSourcefile(), randomdata);
            log.debug(query);

            //create statement
            stmt = connection.createStatement();

            //execute (might be a list with statements, so we cannot check for return code 1)
            stmt.executeUpdate(query);

            return true;
        } catch (Exception e) {
            log.error(testid+" "+inject.getInjectid()+": inject failed", e);
            return false;
        } finally {
            if (stmt != null)
                try {
                    stmt.close();
                } catch (SQLException e) {
                    log.warn("cannot close statement", e);
                }
        }
    }

    @Override
    @LogExecutionTime
    public boolean check(TestCaseCheckDTO check, Object... args) {
        Statement stmt = null;
        ResultSet rs = null;
        try {
            //connect
            Connection connection = getConnector(check.getTestid(), check.getConnectstring(), check.getConnectuser(), check.getConnectpassword());
            if (connection == null) return false;

            //random data replacements
            Map<String,String> serviceparam = this.toParameterMap(check.getServiceparam());
            String query = this.readFileAndAddTestData(check.getTestid(), serviceparam.get("sql"), check.getRandomdata());
            log.debug(query);

            //create statement
            stmt = connection.createStatement();

            //execute query
            rs = stmt.executeQuery(query);
            String result = "no database result";
            if (rs.next()) {
                result = rs.getString(1); //jdbc driver needs 1 instead of 0
            }

            //random data replacements
            String expected = this.readFileAndAddTestData(check.getTestid(), check.getExpectedfile(), check.getRandomdata());

            //expected result check
            boolean retvalue = false;
            switch (check.getExpectedtype()) {
                case "contains":
                    if (result.contains(expected)) retvalue =  true;
                    break;
                case "equals":
                    if (result.equals(expected)) retvalue =  true;
                    break;
                default:
                    log.warn("unknown expected type: >"+check.getExpectedtype()+"<");
            }

            //add result2random attributes
            check.setRandomdata(this.addCheckResult2Random(check.getTestid(), check, check.getRandomdata(), result));

            //check failed
            if (!retvalue) log.info("Database check result:\n"+query+"\n>"+result+"<\n>"+expected+"<");

            return retvalue;
        } catch (Exception e) {
            log.error(check.getTestid()+" "+check.getCheckid()+": check failed", e);
            return false;
        } finally {
            if (rs != null)
                try {
                    rs.close();
                } catch (SQLException e) {
                    log.warn("cannot close result set", e);
                }
            if (stmt != null)
                try {
                    stmt.close();
                } catch (SQLException e) {
                    log.warn("cannot close statement", e);
                }
        }
    }

    /**
     * synchronized as we want have one connection only
     * @throws SQLException
     * @throws ClassNotFoundException
     */
    @LogExecutionTime
    private synchronized Connection getConnector(String testid, String connectstring, String connectuser, String connectpassword) throws Exception {

        //no reuse because of different password configurations
        String key = createConnectionKey(testid, connectstring, connectuser, connectpassword);
        JdbcConnector con = connectors.get(key);

        //block ones
        if (this.isFailedConnector(key)) {
            log.warn(testid + ": database connection blocked - please check credentials and upload testcase: " + connectuser + "@" + connectstring);
            return null;
        }

        try {
            //create new
            if (con == null) {
                con = new JdbcConnector(connectstring, connectuser, decryptPassword(connectpassword));
                log.info("jdbcConnector created: "+con.getInfo());
                connectors.put(key, con);
            }

            return con.getConnection();
        } catch (Exception e) {
            String message = testid+": database connection failed - blocked: "+connectuser+"@"+connectstring;
            log.error(message, e);
            this.addFailedConnector(key);
            throw new Exception(message);
        }
    }

    @Override
    @LogExecutionTime
    public void createRequiredComponents(TestCaseDTO test) {
        try {
            //remove blocked connections and existing connectors
            this.removeFailedConnectorStartingWith(test.getTestid());
            HashMap<String, JdbcConnector> newConnectors = new HashMap<>();
            for (Map.Entry<String,JdbcConnector> entry : connectors.entrySet()) {
                if (entry.getKey().startsWith(test.getTestid())) {
                    entry.getValue().close();
                    log.info("closed: "+entry.getValue().getInfo());
                } else {
                    newConnectors.put(entry.getKey(), entry.getValue());
                }
            }
            connectors = newConnectors;
        } catch (Exception e) {
            log.warn("cannot create timer", e);
        }
    }

    @Override
    @LogExecutionTime
    public List<String> getRequiredTimerCrons() {
        return Arrays.asList(e2ETestConfig.getCheckcron());
    }

    @PreDestroy
    @LogExecutionTime
    private void close() {
        //parallel close
        connectors.values().parallelStream().forEach(
                con -> {
                    try {
                        con.close();
                    } catch (Exception e) {
                        log.warn("cannot close connector", e);
                    }
                }
        );
    }
}
