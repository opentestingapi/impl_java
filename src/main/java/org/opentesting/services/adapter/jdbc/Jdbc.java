package org.opentesting.services.adapter.jdbc;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.dto.TestCaseValidationDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.util.LogExecutionTime;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import javax.annotation.PreDestroy;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.List;

@Component
@Slf4j
public class Jdbc extends Adapter {


    //Connection cache
    private HashMap<String, JdbcConnector> connectors = new HashMap<>();
    
    @Override
    public String getServicename() {
        return "jdbc";
    }

    public List<String> getServicenameAlias() {
        return Arrays.asList(new String[] { "oracle", "postgre" });
    }
    
    @Override
    @LogExecutionTime
    public boolean inject(String testid, TestCaseInjectionDTO inject, TestCaseRandomDataDTO randomdata) {
        Statement stmt = null;
        try {
            //connect
            Connection connection = getConnector(testid, inject.getService().getConnectstring(), 
                inject.getService().getUsername(), inject.getService().getPassword());
            if (connection == null) return false;

            //random data replacements
            String query = this.getFileAndAddTestData(testid, inject.getSourcefile(), randomdata);
            log.debug(query);

            //create statement
            stmt = connection.createStatement();

            //execute (might be a list with statements, so we cannot check for return code 1)
            stmt.executeUpdate(query);

            return true;
        } catch (Exception e) {
            log.error(testid+" "+inject.getInjectid()+" "+inject.getInjectinstanceid()+": inject failed", e);
            return false;
        } finally {
            if (stmt != null)
                try {
                    stmt.close();
                } catch (SQLException e) {
                    log.warn("cannot close statement", e);
                }
        }
    }

    @Override
    @LogExecutionTime
    public boolean check(String testid, TestCaseCheckDTO check, Object... args) {
        Statement stmt = null;
        ResultSet rs = null;
        try {
            //connect
            Connection connection = getConnector(testid, check.getService().getConnectstring(), 
                check.getService().getUsername(), check.getService().getPassword());
            if (connection == null) return false;

            boolean retvalue = true;

            //check all validations, sort first
            for (TestCaseValidationDTO validation : sortValidations(check.getValidations())) {

                //random data replacements            
                String query = this.getFileAndAddTestData(testid, validation.getRequest(), check.getRandomdata());     
                log.debug(query);

                //create statement
                stmt = connection.createStatement();

                //execute query
                rs = stmt.executeQuery(query);
                String result = "no database result";
                if (rs.next()) {
                    result = rs.getString(1); //jdbc driver needs 1 instead of 0
                }

                //do validation
                if (!validateResult(testid, check, validation, result, "JDBC "+query)) {
                    retvalue = false;
                }
            }

            return retvalue;
        } catch (Exception e) {
            log.error(testid+" "+check.getCheckid()+" "+check.getCheckinstanceid()+": check failed", e);
            return false;
        } finally {
            if (rs != null)
                try {
                    rs.close();
                } catch (SQLException e) {
                    log.warn("cannot close result set", e);
                }
            if (stmt != null)
                try {
                    stmt.close();
                } catch (SQLException e) {
                    log.warn("cannot close statement", e);
                }
        }
    }

    /**
     * synchronized as we want have one connection only
     * @throws SQLException
     * @throws ClassNotFoundException
     */
    @LogExecutionTime
    private synchronized Connection getConnector(String testid, String connectstring, String connectuser, String connectpassword) throws Exception {

        //no reuse because of different password configurations
        String key = createConnectionKey(testid, connectstring, connectuser, connectpassword);
        JdbcConnector con = connectors.get(key);

        //block ones
        if (this.isFailedConnector(key)) {
            log.warn(testid + ": database connection blocked - please check credentials and upload testcase: " + connectuser + "@" + connectstring);
            return null;
        }

        try {
            //create new
            if (con == null) {
                con = new JdbcConnector(connectstring, connectuser, decryptPassword(connectpassword));
                log.info("jdbcConnector created: "+con.getInfo());
                connectors.put(key, con);
            }

            return con.getConnection();
        } catch (Exception e) {
            String message = testid+": database connection failed - blocked: "+connectuser+"@"+connectstring;
            log.error(message, e);
            this.addFailedConnector(key);
            throw new Exception(message);
        }
    }

    @Override
    @LogExecutionTime
    public void createRequiredComponents(TestCaseDTO test) {
        try {
            //remove blocked connections and existing connectors
            this.removeFailedConnectorStartingWith(test.getId());
            HashMap<String, JdbcConnector> newConnectors = new HashMap<>();
            for (Map.Entry<String,JdbcConnector> entry : connectors.entrySet()) {
                if (entry.getKey().startsWith(test.getId())) {
                    entry.getValue().close();
                    log.info("closed: "+entry.getValue().getInfo());
                } else {
                    newConnectors.put(entry.getKey(), entry.getValue());
                }
            }
            connectors = newConnectors;
        } catch (Exception e) {
            log.warn("cannot create timer", e);
        }
    }

    @Override
    @LogExecutionTime
    public List<String> getRequiredTimerCrons() {
        return Arrays.asList(openTestingConfig.getCheckcron());
    }

    @PreDestroy
    @LogExecutionTime
    private void close() {
        //parallel close
        connectors.values().parallelStream().forEach(
                con -> {
                    try {
                        con.close();
                    } catch (Exception e) {
                        log.warn("cannot close connector", e);
                    }
                }
        );
    }

}
