package org.opentesting.services.execution;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.core.JsonProcessingException;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseServiceDTO;
import org.opentesting.dto.TraceDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.adapter.AdapterResolver;
import org.opentesting.services.pause.Pause;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.services.trace.OpentestingTraceContext;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.exceptions.ValidationException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;

import brave.ScopedSpan;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class TestCheck extends TestAbstractHandler {

    private static final String CHECKEXECUTION = "CheckExecution ";

    @Autowired
    private OpentestingTraceContext opentestingTraceContext;

    @Autowired
    private Pause pause;

    @Autowired
    private Prometheus prometheus;

    @Autowired
    private TestInjection testInjection;

    @Autowired
    private AdapterResolver adapterResolver;

    /**
     * execute check
     */
    @LogExecutionTime
    public Boolean executeCheck(TestCaseCheckDTO check, boolean ageValidationOnly, Adapter adapter,
            Object... args) throws JsonProcessingException, InterruptedException {        
        return executeCheck(check, ageValidationOnly, adapter, new TraceDTO(), args);
    }

    /**
     * execute check
     */
    @LogExecutionTime
    public Boolean executeCheck(TestCaseCheckDTO check, boolean ageValidationOnly, Adapter adapter, TraceDTO trace,
            Object... args) throws JsonProcessingException, InterruptedException {        

        ScopedSpan span = opentestingTraceContext.startScopedSpanWithParent(
            "opentesting.check."+check.getTestid()+"."+check.getCheckid()+"."+check.getInstanceid(), trace);          
        span.tag("checkid", OpenTestingConversion.replaceNull(check.getCheckid()))
            .tag("checkinstanceid", OpenTestingConversion.replaceNull(check.getInstanceid()))
            .tag("testid", OpenTestingConversion.replaceNull(check.getTestid()))
            .tag("class", this.getClass().getSimpleName())
            .tag("method", "executeCheck");
        
        TestCaseDTO test = null;
        try {

            //read original test case to use original check definition
            test = this.getTest(check.getTestid());

            //disable check for deactivated ones                
            if (!check.isActive()) {
                log.debug(CHECKEXECUTION+check.getTestid()+"."+check.getCheckid()+" - deactivated");
                return null;
            }

            //pause                    
            if (pause.isPause(test.getLabels(), 
                "check deactivated for label "+pause.getPauseByLabel()+": "+ check.getTestid() + " - " + check.getCheckid())) return null;                  

            //disable check for fully disabled test cases (including already stored checks)
            if (!test.isActive()) {
                log.info("E2ETest "+check.getTestid()+"."+check.getCheckid()+" - deactivated");
                //set to false
                check.setSuccess(false);
                check.setResultts(LocalDateTime.now());
                checkRepository.updateByInstanceId(check);
                return false;
            }

            //use latest connection details
            uselatestConnectDeatils(check, test);

            //check            
            boolean success = false;            
            if (!ageValidationOnly) {
                //normal check
                success = adapter.check(check.getTestid(), check, args);
            }

            //write result           
            if (success) {
                check.setSuccess(true);  
                check.setResultts(LocalDateTime.now());                      
                checkRepository.updateByInstanceId(check);

                //execute additional injects (not parallel, correct order might be required)
                executeInjects(check, test);

                //create additional checks for this check (parallel)
                createAndStoreChecks(check.getChecks(), check.getRandomdata(), test, check.getBulkid(), check.getCheckid(), 
                                            span.context().traceIdString());

            } else {
                if (LocalDateTime.now().isAfter(check.getTargetts())) {
                    //to old
                    check.setSuccess(false); 
                    check.setResultts(LocalDateTime.now());                   
                    checkRepository.updateByInstanceId(check);                               
                } else {
                    //no result
                    check.setSuccess(null);                   
                }
            }            

            //increase prometheus
            if (!ageValidationOnly) prometheus.incrementCheck(check.getTestid(), check, test.getLabels());

            log.info("##### CHECK ##### "+check.getTestid()+"."+check.getCheckid()+" executed: "+translateResult(check.getSuccess()));
            return check.getSuccess();
        } catch (InterruptedException ie) {
            log.error(CHECKEXECUTION+check.getTestid()+"."+check.getCheckid()+" interrupted with exception", ie);
            // Restore interrupted state...
            Thread.currentThread().interrupt();
            return false;
        } catch (Exception e) {
            log.error(CHECKEXECUTION+check.getTestid()+"."+check.getCheckid()+" failed with exception", e);

            //increase prometheus
            List<String> labels = new ArrayList<>();
            if (test != null) labels = test.getLabels();
            prometheus.incrementCheck(check.getTestid(), check, labels);

            return false;
        } finally {
            span.finish();
        }
    }

    private void uselatestConnectDeatils(TestCaseCheckDTO check, TestCaseDTO test) {
        //checks need to use the latest connect details
        TestCaseCheckDTO newCheck = null;
        for (TestCaseCheckDTO tmp : test.getChecks()) {
            if (tmp!= null && tmp.getCheckid().equalsIgnoreCase(check.getCheckid())) {
                newCheck = tmp;
                break;
            }
        }
        if (newCheck != null) {
            check.setService(newCheck.getService());
        }
    }

    private void executeInjects(TestCaseCheckDTO check, TestCaseDTO test) throws JsonProcessingException, InterruptedException, NotFoundException, ValidationException {
        for (String inject : check.getInjects()) {

            //search inject object
            TestCaseInjectionDTO injectDO = null;
            for (TestCaseInjectionDTO tmp : test.getInjections()) {
                if (tmp.getInjectid().equalsIgnoreCase(inject)) {
                    injectDO = tmp;
                    break;
                }
            }

            //use found inject
            if (injectDO != null) {

                //validate loop
                if (injectDO.getChecks() != null && injectDO.getChecks().contains(check.getCheckid())) {
                    log.warn("infinite loop detected - inject "+injectDO.getInjectid()+" not executed");
                } else {
                    //execute with existing data
                    injectDO.setRandomdata(check.getRandomdata());
                    Adapter adapterInject = adapterResolver.getAdapter(injectDO.getService().getType());
                    testInjection.executeInject(check.getTestid(), injectDO, "check-triggered",
                            check.getBulkid(), adapterInject);
                }
            }
        }
    }

    /**
     * read all open checks for a defined type
     */
    public List<TestCaseCheckDTO> getOpenChecks(TestCaseServiceDTO service) throws DataAccessException, JsonProcessingException {
        return getOpenChecks(service.getType());
    }

    /**
     * read all open checks for a defined type
     */
    public List<TestCaseCheckDTO> getOpenChecks(String service) throws DataAccessException, JsonProcessingException {
        return checkRepository.selectByOpentype(service);
    }
    
}