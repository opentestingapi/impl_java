package org.opentesting.services.execution;

import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.persistence.TestCaseCheckRepository;
import org.opentesting.persistence.TestCaseFileRepository;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.pause.Pause;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.OpenTestingConversion;
import org.springframework.beans.factory.annotation.Autowired;
import brave.Span;
import org.springframework.stereotype.Component;

import brave.Tracer;
import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class TestCheck extends TestAbstractHandler {

    @Autowired
    private Tracer tracer;

    @Autowired
    private Pause pause;

    @Autowired
    private TestCaseFileRepository testCaseFileRepository;
    
    @Autowired
    private OpenTestingConversion openTestingConversion;

    @Autowired
    private TestCaseCheckRepository testCaseCheckRepository;

    @Autowired
    private Prometheus prometheus;

    @Autowired
    private TestInjection testInjection;

    /**
     * execute check
     */
    @LogExecutionTime
    public Boolean executeCheck(TestCaseCheckDTO check, boolean ageValidationOnly, Adapter adapter, Object... args) throws JsonProcessingException, InterruptedException {

        //add new span
        Span span = tracer.nextSpan().name("e2e.check."+check.getTestid()+"."+check.getCheckid())
                .tag("checkid", check.getCheckid())
                .tag("testid", check.getTestid())
                .tag("class", this.getClass().getSimpleName())
                .tag("method", "executeInject")
                .start();

        TestCaseDTO test = new TestCaseDTO();
        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {

            //disable check for deactivated ones                
            if (!check.isActivation()) {
                log.debug("CheckExecution "+check.getTestid()+"."+check.getCheckid()+" - deactivated");
                return null;
            }

            //read original test case to use the labels
            test = getOriginalTestCase(check.getTestid(), testCaseFileRepository, openTestingConversion);

            //pause                    
            if (pause.isPause(test.getLabels(), 
                "check deactivated for label "+pause.getPauseByLabel()+": "+ check.getTestid() + " - " + check.getCheckid())) return null;                  

            //disable check for fully disabled test cases (including already stored checks)
            if (!test.isActivation()) {
                log.info("E2ETest "+check.getTestid()+"."+check.getCheckid()+" - deactivated");
                //set to false
                check.setSuccess(false);
                testCaseCheckRepository.updateSuccess(check);
                return false;
            }

            //checks need to use the latest connect details
            TestCaseCheckDTO newCheck = null;
            for (TestCaseCheckDTO tmp : test.getChecks()) {
                if (tmp!= null && tmp.getCheckid().equalsIgnoreCase(OpenTestingConversion.getCleanCheckID(check.getCheckid()))) {
                    newCheck = tmp;
                    break;
                }
            }
            if (newCheck != null) {
                check.setConnectpassword(newCheck.getConnectpassword());
                check.setConnectstring(newCheck.getConnectstring());
                check.setConnectuser(newCheck.getConnectuser());
                check.setJwtpassword(newCheck.getJwtpassword());
                check.setJwtuser(newCheck.getJwtuser());
                check.setServiceparam(newCheck.getServiceparam());
            }

            //check            
            Boolean success = false;            
            if (!ageValidationOnly) {
                //normal check
                success = adapter.check(check, args);
            }

            //write result           
            if (success) {
                check.setSuccess(true);                        
                testCaseCheckRepository.updateSuccess(check);

                //execute additional injects (not parallel, correct order might be required)
                for (String inject : check.getInjects()) {

                    //search inject object
                    TestCaseInjectionDTO injectDO = null;
                    for (TestCaseInjectionDTO tmp : test.getInjections()) {
                        if (tmp.getInjectid().equalsIgnoreCase(inject)) {
                            injectDO = tmp;
                            break;
                        }
                    }

                    //use found inject
                    if (injectDO != null) {

                        //validate loop
                        if (injectDO.getChecks() != null && injectDO.getChecks().contains(OpenTestingConversion.getCleanCheckID(check.getCheckid()))) {
                            log.warn("infinite loop detected - inject "+injectDO.getInjectid()+" not executed");
                        } else {
                            //execute with existing data
                            testInjection.executeInject(check.getTestid(), injectDO, "check-triggered",
                                    check.getBulkid(), check.getRandomdata(), adapter);
                        }
                    }
                }

                //create additional checks for this check (parallel)
                createAndStoreChecks(check.getChecks(), check.getRandomdata(), test, check.getBulkid(), OpenTestingConversion.getCleanCheckID(check.getCheckid()), 
                                            span.context().traceIdString(), testCaseCheckRepository);

            } else {
                if (LocalDateTime.now().isAfter(check.getTargetts())) {
                    //to old
                    check.setSuccess(false);                    
                    testCaseCheckRepository.updateSuccess(check);                                       
                } else {
                    //no result
                    check.setSuccess(null);                   
                }
            }            

            //increase prometheus
            if (!ageValidationOnly) prometheus.incrementCheck(check, OpenTestingConversion.getCleanCheckID(check.getCheckid()), test.getLabels());

            log.info("##### CHECK ##### "+check.getTestid()+"."+check.getCheckid()+" executed: "+translateResult(check.getSuccess()));
            return check.getSuccess();
        } catch (InterruptedException ie) {
            log.error("CheckExecution "+check.getTestid()+"."+check.getCheckid()+" interrupted with exception", ie);
            // Restore interrupted state...
            Thread.currentThread().interrupt();
            return false;
        } catch (Exception e) {
            log.error("CheckExecution "+check.getTestid()+"."+check.getCheckid()+" failed with exception", e);

            //increase prometheus
            prometheus.incrementCheck(check, OpenTestingConversion.getCleanCheckID(check.getCheckid()), test.getLabels());

            return false;
        } finally {
            span.finish();
        }
    }
    
}