package org.opentesting.services.execution;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.core.JsonProcessingException;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseServiceDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.pause.Pause;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.util.LogExecutionTime;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;

import brave.Span;
import org.springframework.stereotype.Component;

import brave.Tracer;
import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class TestCheck extends TestAbstractHandler {

    @Autowired
    private Tracer tracer;

    @Autowired
    private Pause pause;

    @Autowired
    private Prometheus prometheus;

    @Autowired
    private TestInjection testInjection;

    /**
     * execute check
     */
    @LogExecutionTime
    public Boolean executeCheck(TestCaseCheckDTO check, boolean ageValidationOnly, Adapter adapter, 
            Object... args) throws JsonProcessingException, InterruptedException {

        //add new span
        Span span = tracer.nextSpan().name("e2e.check."+check.getCheckinstancetestid()+"."+check.getCheckid())
                .tag("checkid", check.getCheckid())
                .tag("testid", check.getCheckinstancetestid())
                .tag("class", this.getClass().getSimpleName())
                .tag("method", "executeCheck")
                .start();       
        
        TestCaseDTO test = null;
        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {

            //read original test case to use original check definition
            test = this.getTest(check.getCheckinstancetestid());

            //disable check for deactivated ones                
            if (!check.isActive()) {
                log.debug("CheckExecution "+check.getCheckinstancetestid()+"."+check.getCheckid()+" - deactivated");
                return null;
            }

            //pause                    
            if (pause.isPause(test.getLabels(), 
                "check deactivated for label "+pause.getPauseByLabel()+": "+ check.getCheckinstancetestid() + " - " + check.getCheckid())) return null;                  

            //disable check for fully disabled test cases (including already stored checks)
            if (!test.isActive()) {
                log.info("E2ETest "+check.getCheckinstancetestid()+"."+check.getCheckid()+" - deactivated");
                //set to false
                check.setSuccess(false);
                check.setResultts(LocalDateTime.now());
                checkRepository.updateByInstanceId(check);
                return false;
            }

            //checks need to use the latest connect details
            TestCaseCheckDTO newCheck = null;
            for (TestCaseCheckDTO tmp : test.getChecks()) {
                if (tmp!= null && tmp.getCheckid().equalsIgnoreCase(check.getCheckid())) {
                    newCheck = tmp;
                    break;
                }
            }
            if (newCheck != null) {
                check.setService(newCheck.getService());
            }

            //check            
            Boolean success = false;            
            if (!ageValidationOnly) {
                //normal check
                success = adapter.check(check.getCheckinstancetestid(), check, args);
            }

            //write result           
            if (success) {
                check.setSuccess(true);  
                check.setResultts(LocalDateTime.now());                      
                checkRepository.updateByInstanceId(check);

                //execute additional injects (not parallel, correct order might be required)
                for (String inject : check.getInjects()) {

                    //search inject object
                    TestCaseInjectionDTO injectDO = null;
                    for (TestCaseInjectionDTO tmp : test.getInjections()) {
                        if (tmp.getInjectid().equalsIgnoreCase(inject)) {
                            injectDO = tmp;
                            break;
                        }
                    }

                    //use found inject
                    if (injectDO != null) {

                        //validate loop
                        if (injectDO.getChecks() != null && injectDO.getChecks().contains(check.getCheckid())) {
                            log.warn("infinite loop detected - inject "+injectDO.getInjectid()+" not executed");
                        } else {
                            //execute with existing data
                            injectDO.setRandomdata(check.getRandomdata());
                            testInjection.executeInject(check.getCheckinstancetestid(), injectDO, "check-triggered",
                                    check.getBulkid(), adapter);
                        }
                    }
                }

                //create additional checks for this check (parallel)
                createAndStoreChecks(check.getChecks(), check.getRandomdata(), test, check.getBulkid(), check.getCheckid(), 
                                            span.context().traceIdString());

            } else {
                if (LocalDateTime.now().isAfter(check.getTargetts())) {
                    //to old
                    check.setSuccess(false); 
                    check.setResultts(LocalDateTime.now());                   
                    checkRepository.updateByInstanceId(check);                               
                } else {
                    //no result
                    check.setSuccess(null);                   
                }
            }            

            //increase prometheus
            if (!ageValidationOnly) prometheus.incrementCheck(check.getCheckinstancetestid(), check, test.getLabels());

            log.info("##### CHECK ##### "+check.getCheckinstancetestid()+"."+check.getCheckid()+" executed: "+translateResult(check.getSuccess()));
            return check.getSuccess();
        } catch (InterruptedException ie) {
            log.error("CheckExecution "+check.getCheckinstancetestid()+"."+check.getCheckid()+" interrupted with exception", ie);
            // Restore interrupted state...
            Thread.currentThread().interrupt();
            return false;
        } catch (Exception e) {
            log.error("CheckExecution "+check.getCheckinstancetestid()+"."+check.getCheckid()+" failed with exception", e);

            //increase prometheus
            List<String> labels = new ArrayList<>();
            if (test != null) labels = test.getLabels();
            prometheus.incrementCheck(check.getCheckinstancetestid(), check, labels);

            return false;
        } finally {
            span.finish();
        }
    }

    /**
     * read all open checks for a defined type
     */
    public List<TestCaseCheckDTO> getOpenChecks(TestCaseServiceDTO service) throws DataAccessException, JsonProcessingException {
        return getOpenChecks(service.getType());
    }

    /**
     * read all open checks for a defined type
     */
    public List<TestCaseCheckDTO> getOpenChecks(String service) throws DataAccessException, JsonProcessingException {
        return checkRepository.selectByOpentype(service);
    }
    
}