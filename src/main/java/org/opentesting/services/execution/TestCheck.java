package org.opentesting.services.execution;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.core.JsonProcessingException;

import io.micrometer.tracing.ScopedSpan;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.adapter.AdapterResolver;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.exceptions.ValidationException;
import org.springframework.dao.DataAccessException;

import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class TestCheck extends TestAbstractHandler {

    private static final String CHECKEXECUTION = "CheckExecution ";

    public TestCheck(ApplicationContextProvider applicationContextProvider) {
        super(applicationContextProvider);                      
    }

    /**
     * execute check
     */
    @LogExecutionTime
    public Boolean executeCheck(TestCaseCheckDTO check, Object... args) throws JsonProcessingException, InterruptedException {        

        ScopedSpan span = tracer.startScopedSpan("opentesting.check."+check.getTestid()+"."+check.getCheckid()+"."+check.getInstanceid());          
        span.tag("checkid", OpenTestingConversion.replaceNull(check.getCheckid()))
            .tag("checkinstanceid", OpenTestingConversion.replaceNull(check.getInstanceid()))
            .tag("testid", OpenTestingConversion.replaceNull(check.getTestid()))
            .tag("class", this.getClass().getSimpleName())
            .tag("method", "executeCheck");
        
        TestCaseDTO test = null;
        try {

            //read original test case to use original check definition
            test = this.getTest(check.getTestid());

            //disable check for deactivated ones                
            if (!check.isActive()) {
                log.debug(CHECKEXECUTION+check.getTestid()+"."+check.getCheckid()+" - deactivated");
                return null;
            }

            //pause                    
            if (pause.isPause(test.getLabels(), 
                "check deactivated for label "+pause.getPauseByLabel()+": "+ check.getTestid() + " - " + check.getCheckid())) return null;                  

            //disable check for fully disabled test cases (including already stored checks)
            if (!test.isActive()) {
                log.info("E2ETest "+check.getTestid()+"."+check.getCheckid()+" - deactivated");
                //set to false
                check.setSuccess(false);
                check.setResultts(LocalDateTime.now());
                checkRepository.updateByInstanceId(check);
                return false;
            }

            //use latest connection details
            uselatestConnectDeatils(check, test);

            //check    
            AdapterResolver adapterResolver = applicationContextProvider.getBean(AdapterResolver.class);  
            Adapter adapter = adapterResolver.getAdapter(check.getService().getType());
            boolean success = adapter.check(check.getTestid(), check, args);     
            
            //write result           
            if (success) {
                check.setSuccess(true);  
                check.setResultts(LocalDateTime.now());           
                boolean updated = checkRepository.updateByInstanceId(check);

                //create checks and injects
                if (updated) executeSubsequentChecksAndInjects(check, test, span);
            } else {
                failedCheck(check, test, span);
            }         

            //increase prometheus
            prometheus.incrementCheck(check.getTestid(), check, test.getLabels());

            log.info("##### CHECK ##### "+check.getTestid()+"."+check.getInstanceid()+" executed: "+translateResult(check.getSuccess()));
            return check.getSuccess();
        } catch (InterruptedException ie) {
            log.error(CHECKEXECUTION+check.getTestid()+"."+check.getInstanceid()+" interrupted with exception", ie);
            // Restore interrupted state...
            Thread.currentThread().interrupt();
            return false;
        } catch (Exception e) {
            log.error(CHECKEXECUTION+check.getTestid()+"."+check.getInstanceid()+" failed with exception", e);

            //increase prometheus
            List<String> labels = new ArrayList<>();
            if (test != null) labels = test.getLabels();
            prometheus.incrementCheck(check.getTestid(), check, labels);

            return false;
        } finally {
            span.end();
        }
    }    

    /**
     * execute maxwaittime check
     */
    @LogExecutionTime
    public boolean executeMaxwaittimeCheck(TestCaseCheckDTO check) throws JsonProcessingException, InterruptedException {        

        ScopedSpan span = tracer.startScopedSpan("opentesting.check."+check.getTestid()+"."+check.getCheckid()+"."+check.getInstanceid());          
        span.tag("checkid", OpenTestingConversion.replaceNull(check.getCheckid()))
            .tag("checkinstanceid", OpenTestingConversion.replaceNull(check.getInstanceid()))
            .tag("testid", OpenTestingConversion.replaceNull(check.getTestid()))
            .tag("class", this.getClass().getSimpleName())
            .tag("method", "executeMaxwaittimeCheck");
        
        try {

            if (LocalDateTime.now().isAfter(check.getTargetts())) {

                //set expired flag but do not update the data object
                checkRepository.expire(check);
                
                return true;             
            }
            
            return false;
        } catch (Exception e) {
            log.error(CHECKEXECUTION+check.getTestid()+"."+check.getInstanceid()+" failed with exception", e);
            return false;
        } finally {
            span.end();
        }
    }    

    private void failedCheck(TestCaseCheckDTO check, TestCaseDTO test, ScopedSpan span) throws DataAccessException, JsonProcessingException, InterruptedException, NotFoundException, ValidationException {
        if (LocalDateTime.now().isAfter(check.getTargetts())) {
            //expired
            check.setSuccess(false);
            check.setResultts(LocalDateTime.now());
            if(check.getExpiredts() == null) check.setExpiredts(LocalDateTime.now());
            boolean updated = checkRepository.updateByInstanceId(check);
            
            if (updated && !check.isMandatory()) {
                //create checks and injects if test is failed, but not mandatory
                executeSubsequentChecksAndInjects(check, test, span);
            }
        } else {
            //no result
            check.setSuccess(null);                   
        }
    }   

    private void executeSubsequentChecksAndInjects(TestCaseCheckDTO check, TestCaseDTO test, ScopedSpan span) 
        throws JsonProcessingException, InterruptedException, NotFoundException, ValidationException {

        //execute additional injects (not parallel, correct order might be required)
        executeInjects(check, test);

        //create additional checks for this check (parallel)
        createAndStoreChecks(check.getChecks(), check.getRandomdata(), test, check.getBulkid(), check.getCheckid(), 
                                    span.context().traceId());
    }

    private void uselatestConnectDeatils(TestCaseCheckDTO check, TestCaseDTO test) {
        //checks need to use the latest connect details
        TestCaseCheckDTO newCheck = null;
        for (TestCaseCheckDTO tmp : test.getChecks()) {
            if (tmp!= null && tmp.getCheckid().equalsIgnoreCase(check.getCheckid())) {
                newCheck = tmp;
                break;
            }
        }
        if (newCheck != null) {
            check.setService(newCheck.getService());
        }
    }

    private void executeInjects(TestCaseCheckDTO check, TestCaseDTO test) throws JsonProcessingException, InterruptedException, NotFoundException, ValidationException {
        for (String inject : check.getInjects()) {

            //search inject object
            TestCaseInjectionDTO injectDO = null;
            for (TestCaseInjectionDTO tmp : test.getInjections()) {
                if (tmp.getInjectid().equalsIgnoreCase(inject)) {
                    injectDO = tmp;
                    break;
                }
            }

            //use found inject
            if (injectDO != null) {

                //validate loop
                if (injectDO.getChecks() != null && injectDO.getChecks().contains(check.getCheckid())) {
                    log.warn("infinite loop detected - inject "+injectDO.getInjectid()+" not executed");
                } else {
                    //execute with existing data
                    injectDO.setRandomdata(check.getRandomdata());                    
                    TestInjection testInjection = applicationContextProvider.getBean(TestInjection.class);
                    testInjection.executeInject(check.getTestid(), injectDO, "check-triggered",
                            check.getBulkid());
                }
            }
        }
    }    

    /**
     * read all open checks for a defined type
     */
    public List<TestCaseCheckDTO> getOpenChecks(String testid, String service) throws DataAccessException {
        return checkRepository.selectByTestAndOpentype(testid, service);
    }

    /**
     * read all unexpired open checks
     * @param service service
     * @return checks
     */
    public List<TestCaseCheckDTO> getOpenChecksUnexpired(String service) {
        return checkRepository.selectByOpentypeAndUnexpired(service);
    }

    /**
     * get check by instance id
     * @throws NotFoundException
     */
    public TestCaseCheckDTO getCheckByInstanceId(String instanceId) throws DataAccessException, NotFoundException {
        return checkRepository.selectByInstanceId(instanceId);
    }
    
}