package org.opentesting.services.execution;

import java.util.ArrayList;
import java.util.List;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.dto.migration.TestCaseDTOMigration;
import org.opentesting.persistence.CheckRepository;
import org.opentesting.persistence.IndexRepository;
import org.opentesting.persistence.InjectRepository;
import org.opentesting.persistence.KeyValueRepository;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.springframework.beans.factory.annotation.Autowired;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class TestAbstractHandler {

    //must be unique for every test case, we shall use something a user would never use
    public static final String TESTCASESTORAGE = "internal_testcase_store_5418959620.json";
    public static final String TESTCASERANDOMDATASTORAGE = "internal_testcase_randomdata_store_5418959620_###.json";

    @Autowired
    protected KeyValueRepository keyValueRepository;

    @Autowired
    protected CheckRepository checkRepository;

    @Autowired
    protected InjectRepository injectRepository;
    
    @Autowired
    protected IndexRepository indexRepository;

    @Autowired
    protected OpenTestingConversion openTestingConversion;

    /**
     * read stored file
     */
    @LogExecutionTime
    public String getFile(String testid, String filename) {
        return keyValueRepository.select(testid, filename);
    }   
    
    /**
     * stored file
     */
    @LogExecutionTime
    public void storeFile(String testid, String filename, String content) {
        keyValueRepository.insert(testid, filename, content);
    }

    /**
     * read stored file
     * @throws NotFoundException
     * @throws JsonProcessingException
     * @throws JsonMappingException
     * @throws Exception
     */
    @LogExecutionTime
    @SuppressWarnings("unchecked")
    public TestCaseDTO getTest(String testid) throws NotFoundException, JsonMappingException, JsonProcessingException {
        String testJson = getFile(testid, TESTCASESTORAGE);
        if (testJson == null || testJson.length() < 1) throw new NotFoundException("TestCaseDTO not found: "+testid); 
        return (TestCaseDTO) openTestingConversion.json2object(testJson, TestCaseDTOMigration.LATEST);
    }

    /**
     * stored file
     * @throws JsonProcessingException
     */
    @LogExecutionTime
    public void storeTest(TestCaseDTO test) throws JsonProcessingException {
        storeFile(test.getId(), TESTCASESTORAGE, openTestingConversion.object2json(test));
    }

    /**
     * read stored file
     * @throws JsonProcessingException
     * @throws JsonMappingException
     */
    @LogExecutionTime
    @SuppressWarnings("unchecked")
    public List<TestCaseDTO> getTests() throws JsonMappingException, JsonProcessingException {
        List<TestCaseDTO> tests = new ArrayList<>();
        for (String testJson : keyValueRepository.selectByKey(TESTCASESTORAGE)) {
            if (testJson == null || testJson.length() < 1)
                tests.add((TestCaseDTO) openTestingConversion.json2object(testJson, TestCaseDTOMigration.LATEST));
        }
        return tests;
    }
    
    /**
     * create required check instances
     */
    @LogExecutionTime
    protected void createAndStoreChecks(List<String> checks, TestCaseRandomDataDTO randomdata, TestCaseDTO test, String bulkid, 
                                        String parentcheck, String traceid) {
        long now = System.currentTimeMillis();
        if (parentcheck == null) parentcheck = "#";
        if (checks != null) {
            final TestCaseRandomDataDTO finalRandomdata = randomdata;
            String finalParentcheck = parentcheck;
            checks.parallelStream().forEach(
                    checkString -> {

                        //check recursion checks
                        if (finalParentcheck.equals(checkString)) {
                            log.warn("infinite loop detected - check " + checkString + " not stored");
                            return;
                        }

                        //search check
                        TestCaseCheckDTO check = null;
                        for (TestCaseCheckDTO ch : test.getChecks()) {
                            if (ch.getCheckid().equals(checkString)) {
                                check = ch;
                                break;
                            }
                        }

                        //check recursion sub-checks
                        if (check.getChecks() != null && check.getChecks().contains(finalParentcheck)) {
                            log.warn("infinite loop detected - check "+checkString+" not executed");
                             return;
                        }

                        //if available persiste new one
                        if (check != null && check.isActive()) {

                            //add additional data to id
                            check.setCheckid(check.getCheckid());
                            check.setCheckinstanceid(check.getCheckid()+"_"+now);                            
                            check.setRandomdata(finalRandomdata);
                            check.setBulkid(bulkid);
                            check.setTraceid(traceid);

                            //create
                            try {
                                //we can use the service type as opentype key                                
                                checkRepository.insert(test.getId(), check);

                                //add bulk id to index as check was created
                                if (bulkid != null && bulkid.length() > 0) {
                                    indexRepository.insert(IndexRepository.BULKIDINDEXCHECKS, bulkid, check.getCheckinstanceid());
                                }
                            } catch (Exception e) {
                                log.error("cannot persist new check instance: "+test.getId()+"."+check.getCheckid(), e);                                
                            }                          
                        }
                    }
            );
        }
    }    

    /**
     * transfer success object to text
     * @param success Boolean
     * @return String
     */
    protected String translateResult(Boolean success) {
        if (success == null) return "without";
        if (success) return "success";
        return "failed";
    }       
    
}