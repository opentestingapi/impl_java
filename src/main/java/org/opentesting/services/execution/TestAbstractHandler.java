package org.opentesting.services.execution;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

import com.fasterxml.jackson.core.JsonProcessingException;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.persistence.CheckRepository;
import org.opentesting.persistence.IndexRepository;
import org.opentesting.persistence.InjectRepository;
import org.opentesting.persistence.KeyValueRepository;
import org.opentesting.persistence.TestRepository;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.exceptions.ValidationException;
import org.springframework.beans.factory.annotation.Autowired;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public abstract class TestAbstractHandler {

    //must be unique for every test case, we shall use something a user would never use    
    public static final String TESTCASERANDOMDATASTORAGE = "internal_testcase_randomdata_store_5418959620_###.json";

    @Autowired
    protected KeyValueRepository keyValueRepository;

    @Autowired
    protected CheckRepository checkRepository;

    @Autowired
    protected InjectRepository injectRepository;
    
    @Autowired
    protected IndexRepository indexRepository;

    @Autowired
    protected TestRepository testRepository;

    @Autowired
    protected OpenTestingConversion openTestingConversion;

    protected Random rand = new SecureRandom();

    /**
     * read stored file
     * @throws NotFoundException
     */
    @LogExecutionTime
    public String getFile(String testid, String filename) throws NotFoundException {
        return keyValueRepository.select(testid, filename);
    }   
    
    /**
     * stored file
     */
    @LogExecutionTime
    public void storeFile(String testid, String filename, String content) {
        keyValueRepository.insert(testid, filename, content);
    }

    /**
     * read stored file
     * @throws NotFoundException
     * @throws JsonProcessingException
     * @throws Exception
     */
    @LogExecutionTime
    public TestCaseDTO getTest(String testid) throws NotFoundException, JsonProcessingException {        
        return testRepository.select(testid);
    }

    /**
     * stored file
     * @throws JsonProcessingException
     */
    @LogExecutionTime
    public void storeTest(TestCaseDTO test) throws JsonProcessingException {        
        testRepository.insert(test);
    }

    /**
     * read stored file
     * @throws JsonProcessingException
     */
    @LogExecutionTime
    public List<TestCaseDTO> getTests() throws JsonProcessingException {
        return testRepository.selectAll();
    }
    
    /**
     * create required check instances
     * @return 
     * @return 
     */
    @LogExecutionTime
    protected List<String> createAndStoreChecks(List<String> checks, TestCaseRandomDataDTO randomdata, TestCaseDTO test, String bulkid, 
                                        String parentcheck, String traceid) {
        long now = System.currentTimeMillis();
        if (parentcheck == null) parentcheck = "#";
        if (checks != null) {
            final TestCaseRandomDataDTO finalRandomdata = randomdata;
            String finalParentcheck = parentcheck;
            List<String> res = checks.parallelStream().map(
                    checkString -> {
                        try {
                            return handleCheck(finalParentcheck, checkString, test, finalRandomdata, now, bulkid, traceid);
                        } catch (ValidationException e) {
                            log.error(e.getMessage(), e);
                            return null;
                        }
                    }
            ).collect(Collectors.toList());
            return OpenTestingConversion.filterNull(res);
        } else {
            return new ArrayList<>();
        }
    }

    private String handleCheck(String finalParentcheck, String checkString, TestCaseDTO test, TestCaseRandomDataDTO finalRandomdata,
                                long now, String bulkid, String traceid) throws ValidationException {

        //check recursion checks
        if (finalParentcheck.equals(checkString)) {
            log.warn("infinite loop detected - check " + checkString + " not stored");
            return null;
        }

        //search check
        TestCaseCheckDTO check = null;
        for (TestCaseCheckDTO ch : test.getChecks()) {
            if (ch.getCheckid().equals(checkString)) {
                check = ch;
                break;
            }
        }

        //check recursion sub-checks
        if (check != null && check.getChecks() != null && check.getChecks().contains(finalParentcheck)) {
            log.warn("infinite loop detected - check "+checkString+" not executed");
            return null;
        }

        //if available persiste new one
        if (check != null && check.isActive()) {                            
            return persistCheck(check, now, finalRandomdata, bulkid, traceid, test);
        }
        return null;
    }

    private String persistCheck(TestCaseCheckDTO check, long now, TestCaseRandomDataDTO finalRandomdata,
                                    String bulkid, String traceid, TestCaseDTO test) throws ValidationException {

        //add additional data to id
        check.setCheckid(check.getCheckid());
        check.setInstanceid(check.getCheckid()+"_"+now+"_"+rand.nextInt(Integer.MAX_VALUE));                            
        check.setRandomdata(finalRandomdata);
        check.setBulkid(bulkid);
        check.setTraceid(traceid);

        //set startts/targetts when check is persisted
        long waitSec = OpenTestingConversion.toSeconds(check.getMaxwaittime());
        LocalDateTime nowLDT = LocalDateTime.now();
        check.setStartts(nowLDT);
        check.setTargetts(nowLDT.plusSeconds(waitSec));

        //create
        try {
            //we can use the service type as opentype key                                
            checkRepository.insert(test.getId(), check);

            //add bulk id to index as check was created
            if (bulkid != null && bulkid.length() > 0) {
                indexRepository.insert(IndexRepository.BULKIDINDEXCHECKS, bulkid, check.getInstanceid());
            }
        } catch (Exception e) {
            log.error("cannot persist new check instance: "+test.getId()+"."+check.getCheckid(), e);                                
        }

        return check.getInstanceid();
    }

    /**
     * transfer success object to text
     * @param success Boolean
     * @return String
     */
    protected String translateResult(Boolean success) {
        if (success == null) return "without";
        if (success) return "success";
        return "failed";
    }       
    
}