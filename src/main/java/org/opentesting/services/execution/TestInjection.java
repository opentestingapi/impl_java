package org.opentesting.services.execution;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;

import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.persistence.TestCaseCheckRepository;
import org.opentesting.persistence.TestCaseFileRepository;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.pause.Pause;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.services.random.RandomData;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.OpenTestingConversion;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import brave.Span;
import brave.Tracer;
import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class TestInjection extends TestAbstractHandler {

    @Autowired
    private Tracer tracer;

    @Autowired
    private Pause pause;

    @Autowired
    private RandomData randomData;

    @Autowired
    private Prometheus prometheus;

    @Autowired
    private TestCaseCheckRepository testCaseCheckRepository;

    @Autowired
    private TestCaseFileRepository testCaseFileRepository;
    
    @Autowired
    private OpenTestingConversion openTestingConversion;

    /**
     * execute inject
     * @throws JsonProcessingException
     * @throws JsonMappingException
     * @throws InterruptedException
     */
    @LogExecutionTime
    public boolean executeInject(String testid, TestCaseInjectionDTO inject, String source, String bulkid,
                                 TestCaseRandomDataDTO randomdata, Adapter adapter)
            throws JsonMappingException, JsonProcessingException, InterruptedException {

        //add new span
        Span span = tracer.nextSpan().name("e2e.inject."+testid+"."+inject.getInjectid())
                .tag("injectid", inject.getInjectid())
                .tag("testid", testid)
                .tag("class", this.getClass().getSimpleName())
                .tag("method", "executeInject")
                .start();        

        Boolean injected = null;

        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {

            //read original test case to use original check definition
            TestCaseDTO test = this.getOriginalTestCase(testid, testCaseFileRepository, openTestingConversion);

            //pause
            if (pause.isPause(test.getLabels(),
                "inject deactivated for label "+pause.getPauseByLabel()+": "+ testid + " " + inject.getInjectid())) return false;

            //disable inject for fully disabled test cases
            if (!test.isActivation()) {
                log.info("E2ETest " + testid + "." + inject.getInjectid() + " - deactivated");
                return false;
            }

            //read or create random data if parameter is not set
            if (randomdata == null) randomdata = randomData.getRandomData(testid, inject);

            //create checks for this inject (parallel)
            this.createAndStoreChecks(inject.getChecks(), randomdata, test, bulkid, null, span.context().traceIdString(), testCaseCheckRepository);

            //we need to wait a few ms because of really fast executions
            Thread.sleep(10);

            //inject            
            injected = adapter.inject(testid, inject, randomdata);

            //increase prometheus
            prometheus.incrementInject(testid, inject, injected, test.getLabels());

            log.info("##### INJECT ##### " + testid + "." + inject.getInjectid() + ": " + translateResult(injected) + " " + source);
        } finally {
            span.finish();
        }
        return injected;
    }    
    
}