package org.opentesting.services.execution;

import java.time.LocalDateTime;
import java.util.List;

import com.fasterxml.jackson.core.JsonProcessingException;

import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TraceDTO;
import org.opentesting.persistence.IndexRepository;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.pause.Pause;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.services.random.RandomData;
import org.opentesting.services.trace.OpentestingTraceContext;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.exceptions.ValidationException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import brave.ScopedSpan;
import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class TestInjection extends TestAbstractHandler {    

    @Autowired
    private OpentestingTraceContext opentestingTraceContext;

    @Autowired
    private Pause pause;

    @Autowired
    private RandomData randomData;

    @Autowired
    private Prometheus prometheus;

    /**
     * execute inject
     * @throws JsonProcessingException
     * @throws InterruptedException
     * @throws NotFoundException
     * @throws ValidationException
     */
    @LogExecutionTime
    public boolean executeInject(String testid, TestCaseInjectionDTO inject, String source, String bulkid, Adapter adapter)
            throws JsonProcessingException, InterruptedException, NotFoundException, ValidationException {
        return executeInject(testid, inject, source, bulkid, adapter, new TraceDTO());
    }

    /**
     * execute inject
     * @throws JsonProcessingException
     * @throws InterruptedException
     * @throws NotFoundException
     * @throws ValidationException
     */
    @LogExecutionTime
    public boolean executeInject(String testid, TestCaseInjectionDTO inject, String source, String bulkid, Adapter adapter, TraceDTO trace)
            throws JsonProcessingException, InterruptedException, NotFoundException, ValidationException {

        ScopedSpan span = opentestingTraceContext.startScopedSpanWithParent(
            "opentesting.inject."+testid+"."+inject.getInjectid()+"."+inject.getInjectinstanceid(), trace);          
        span.tag("injectid", inject.getInjectid())
            .tag("injectinstanceid", inject.getInjectinstanceid())
            .tag("testid", testid)
            .tag("class", this.getClass().getSimpleName())
            .tag("method", "executeInject");       

        Boolean injected = null;

        try {

            String traceid = span.context().traceIdString();

            //read original test case to use original check definition
            TestCaseDTO test = this.getTest(testid);

            //pause
            if (pause.isPause(test.getLabels(),
                "inject deactivated for label "+pause.getPauseByLabel()+": "+ testid + " " + inject.getInjectid())) return false;

            //disable inject for fully disabled test cases
            if (!test.isActive()) {
                log.info("E2ETest " + testid + "." + inject.getInjectid() + " - deactivated");
                return false;
            }

            //read or create random data if parameter is not set
            if (inject.getRandomdata() == null) inject.setRandomdata(randomData.getRandomData(testid, inject));

            //create checks for this inject (parallel)
            List<String> checkinstances = this.createAndStoreChecks(inject.getChecks(), inject.getRandomdata(), test, bulkid, null, traceid);

            //we need to wait a few ms because of really fast executions
            Thread.sleep(10);

            //inject 
            injected = adapter.inject(testid, inject);

            //update random data from inject - might be to late, but we need to create checks first because Kafka
            checkRepository.updateRandomData(checkinstances, inject.getRandomdata());

            //add inject instance
            long now = System.currentTimeMillis();
            inject.setStartts(LocalDateTime.now());
            inject.setInjectinstanceid(inject.getInjectid()+"_"+now);
            inject.setBulkid(bulkid);
            inject.setTraceid(traceid);
            injectRepository.insert(testid, inject);

            //add bulk id to index as inject was executed
            if (bulkid != null && bulkid.length() > 0) {
                indexRepository.insert(IndexRepository.BULKIDINDEXINJECTS, bulkid, inject.getInjectinstanceid());
            }

            //increase prometheus
            prometheus.incrementInject(testid, inject, injected, test.getLabels());

            log.info("##### INJECT ##### " + testid + "." + inject.getInjectid() + ": " + translateResult(injected) + " " + source);
        } finally {
            span.finish();
        }
        return injected;
    }    
    
}