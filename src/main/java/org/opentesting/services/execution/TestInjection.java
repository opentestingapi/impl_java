package org.opentesting.services.execution;

import java.time.LocalDateTime;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;

import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.persistence.IndexRepository;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.pause.Pause;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.services.random.RandomData;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.exceptions.NotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import brave.Span;
import brave.Tracer;
import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class TestInjection extends TestAbstractHandler {

    @Autowired
    private Tracer tracer;

    @Autowired
    private Pause pause;

    @Autowired
    private RandomData randomData;

    @Autowired
    private Prometheus prometheus;

    /**
     * execute inject
     * @throws JsonProcessingException
     * @throws JsonMappingException
     * @throws InterruptedException
     * @throws NotFoundException
     */
    @LogExecutionTime
    public boolean executeInject(String testid, TestCaseInjectionDTO inject, String source, String bulkid,
                                 TestCaseRandomDataDTO randomdata, Adapter adapter)
            throws JsonMappingException, JsonProcessingException, InterruptedException, NotFoundException {

        //add new span
        Span span = tracer.nextSpan().name("e2e.inject."+testid+"."+inject.getInjectid())
                .tag("injectid", inject.getInjectid())
                .tag("testid", testid)
                .tag("class", this.getClass().getSimpleName())
                .tag("method", "executeInject")
                .start();        

        Boolean injected = null;

        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {

            String traceid = span.context().traceIdString();

            //read original test case to use original check definition
            TestCaseDTO test = this.getTest(testid);

            //pause
            if (pause.isPause(test.getLabels(),
                "inject deactivated for label "+pause.getPauseByLabel()+": "+ testid + " " + inject.getInjectid())) return false;

            //disable inject for fully disabled test cases
            if (!test.isActive()) {
                log.info("E2ETest " + testid + "." + inject.getInjectid() + " - deactivated");
                return false;
            }

            //read or create random data if parameter is not set
            if (randomdata == null) randomdata = randomData.getRandomData(testid, inject);

            //create checks for this inject (parallel)
            this.createAndStoreChecks(inject.getChecks(), randomdata, test, bulkid, null, traceid);

            //we need to wait a few ms because of really fast executions
            Thread.sleep(10);

            //inject            
            injected = adapter.inject(testid, inject, randomdata);

            //add inject instance
            long now = System.currentTimeMillis();
            inject.setStartts(LocalDateTime.now());
            inject.setInjectinstanceid(inject.getInjectid()+"_"+now);
            inject.setBulkid(bulkid);
            inject.setTraceid(traceid);
            inject.setRandomdata(randomdata);
            injectRepository.insert(testid, inject);

            //add bulk id to index as inject was executed
            if (bulkid != null && bulkid.length() > 0) {
                indexRepository.insert(IndexRepository.BULKIDINDEXINJECTS, bulkid, inject.getInjectinstanceid());
            }

            //increase prometheus
            prometheus.incrementInject(testid, inject, injected, test.getLabels());

            log.info("##### INJECT ##### " + testid + "." + inject.getInjectid() + ": " + translateResult(injected) + " " + source);
        } finally {
            span.finish();
        }
        return injected;
    }    
    
}