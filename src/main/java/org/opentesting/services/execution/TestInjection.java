package org.opentesting.services.execution;

import java.time.LocalDateTime;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

import com.fasterxml.jackson.core.JsonProcessingException;

import io.micrometer.tracing.ScopedSpan;

import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.persistence.IndexRepository;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.adapter.AdapterResolver;
import org.opentesting.services.random.RandomData;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.exceptions.ValidationException;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class TestInjection extends TestAbstractHandler {    

    private RandomData randomData;

    public TestInjection(ApplicationContextProvider applicationContextProvider) {
        super(applicationContextProvider);
        randomData = applicationContextProvider.getBean(RandomData.class);
    }

    /**
     * execute inject
     * @throws JsonProcessingException
     * @throws InterruptedException
     * @throws NotFoundException
     * @throws ValidationException
     */
    @LogExecutionTime
    public boolean executeInject(String testid, TestCaseInjectionDTO inject, String source, String bulkid)
            throws JsonProcessingException, InterruptedException, NotFoundException, ValidationException {
        return executeInject(testid, inject, source, bulkid, false);
    }

    @Async
    public void executeInjectAsync(String testid, TestCaseInjectionDTO inject, String source, String bulkid, AtomicInteger cnt)
            throws JsonProcessingException, InterruptedException, NotFoundException, ValidationException {
        executeInject(testid, inject, source, bulkid, true);
        if (cnt.incrementAndGet() % 1000 == 0)
            log.info("##### INJECT ##### " + cnt.get() + " injects succ executed");
    }

    /**
     * execute inject
     * @throws JsonProcessingException
     * @throws InterruptedException
     * @throws NotFoundException
     * @throws ValidationException
     */
    @LogExecutionTime
    public boolean executeInject(String testid, TestCaseInjectionDTO inject, String source, String bulkid, boolean silent)
            throws JsonProcessingException, InterruptedException, NotFoundException, ValidationException {

        ScopedSpan span = tracer.startScopedSpan("opentesting.inject."+testid+"."+inject.getInjectid()+"."+inject.getInstanceid());          
        span.tag("injectid", OpenTestingConversion.replaceNull(inject.getInjectid()))
            .tag("injectinstanceid", OpenTestingConversion.replaceNull(inject.getInstanceid()))
            .tag("testid", OpenTestingConversion.replaceNull(testid))
            .tag("class", this.getClass().getSimpleName())
            .tag("method", "executeInject");       

        Boolean injected = null;

        try {

            String traceid = span.context().traceId();

            //read original test case to use original check definition
            TestCaseDTO test = this.getTest(testid);

            //pause
            if (pause.isPause(test.getLabels(),
                "inject deactivated for label "+pause.getPauseByLabel()+": "+ testid + " " + inject.getInjectid())) return false;

            //disable inject for fully disabled test cases
            if (!test.isActive()) {
                log.info("E2ETest " + testid + "." + inject.getInjectid() + " - deactivated");
                return false;
            }

            //if we need to execute it multiple times, we have to create random data copies
            TestCaseRandomDataDTO rd = inject.getRandomdata();
            if (rd == null) rd = new TestCaseRandomDataDTO();

            //loop for our executions
            for (int i = 0; i < inject.getExecutions(); i++) {

                //create the copy to have unique values
                inject.setRandomdata(rd.copy());

                //create additional random data
                inject.setRandomdata(randomData.getRandomData(testid, inject));

                //create checks for this inject (parallel)
                List<String> checkinstances = this.createAndStoreChecks(inject.getChecks(), inject.getRandomdata(), test, bulkid, null, traceid);

                //inject 
                AdapterResolver adapterResolver = applicationContextProvider.getBean(AdapterResolver.class);
                Adapter adapter = adapterResolver.getAdapter(inject.getService().getType());
                injected = adapter.inject(testid, inject);

                if (checkinstances != null) {
                    //update random data from inject - might be too late, but we need to create checks first because of Kafka
                    checkRepository.updateRandomData(checkinstances, inject.getRandomdata());
                }
                //update random data store for "other injects" (will override if executions > 1)
                randomData.writeRandomDataStore(testid, inject, inject.getRandomdata());

                //add inject instance
                long now = System.currentTimeMillis();
                inject.setStartts(LocalDateTime.now());
                inject.setInstanceid(inject.getInjectid()+"_"+now+"_"+rand.nextInt(Integer.MAX_VALUE));
                inject.setBulkid(bulkid);
                inject.setTraceid(traceid);
                injectRepository.insert(testid, inject);

                //add bulk id to index as inject was executed
                if (bulkid != null && bulkid.length() > 0) {
                    indexRepository.insert(IndexRepository.BULKIDINDEXINJECTS, bulkid, inject.getInstanceid());
                }

                //increase prometheus
                prometheus.incrementInject(testid, inject, injected, test.getLabels());

                if (!silent) {
                    log.info("##### INJECT ##### " + testid + "." + inject.getInjectid() + " "+inject.getInstanceid()+": " + translateResult(injected) + " " + source);
                }

                //sub injects using recursion
                executeSubinjects(test, inject, source, bulkid, silent);
            }   
        } finally {
            span.end();
        }
        return injected;
    } 
    
    private void executeSubinjects(TestCaseDTO test, TestCaseInjectionDTO inject, String source, String bulkid, boolean silent) throws JsonProcessingException, InterruptedException, NotFoundException, ValidationException {
        //sub injects uding recursion
        for (String subinject : inject.getInjections()) {
            for (TestCaseInjectionDTO originject : test.getInjections()) {
                if (originject.getInjectid().equals(subinject)) {
                    if (originject.getInjectid().equals(inject.getInjectid())) {
                        //loop detected
                        throw new ValidationException("executeSubinjects: loop detected");
                    }
                    originject.setRandomdata(inject.getRandomdata().copy());
                    this.executeInject(test.getId(), originject, source, bulkid, silent);
                }
            }
        }
    }
    
}