package org.opentesting.services.execution;

import java.time.LocalDateTime;
import java.util.*;

import brave.Span;
import brave.Tracer;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.adapter.AdapterResolver;
import org.opentesting.services.execution.dto.TestCaseCheckDTO;
import org.opentesting.services.execution.dto.TestCaseDTO;
import org.opentesting.services.execution.dto.TestCaseInjectionDTO;
import org.opentesting.services.execution.dto.TestCaseRandomDataDTO;
import org.opentesting.services.execution.persistence.TestCaseCheckRepository;
import org.opentesting.services.execution.persistence.TestCaseFileRepository;
import org.opentesting.services.execution.persistence.TestCaseInjectionRepository;
import org.opentesting.services.execution.persistence.TestCaseRepository;
import org.opentesting.services.execution.scheduler.AsynTaskExec;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.OpenTestingConfig;
import org.opentesting.util.LogExecutionTime;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;

import lombok.extern.slf4j.Slf4j;

/**
 * central planing / management logic
 */
@Controller
@Slf4j
public class TestManager {

    public static final String TESTCASESTORAGE = "internal_e2e_testcase_store.json";  
    public static final String ALLPAUSELABEL = "all";  

    @Autowired
    private TestCaseFileRepository testCaseFileRepository;

    @Autowired
    private TestCaseCheckRepository testCaseCheckRepository;

    @Autowired
    private TestCaseInjectionRepository testCaseInjectionRepository;

    @Autowired
    private TestCaseRepository testCaseRepository;

    @Autowired
    private TimerFactory timerFactory;

    @Autowired
    private AdapterResolver adapterResolver;     

    @Autowired
    private OpenTestingConfig e2ETestConfig;

    @Autowired
    private Prometheus prometheus;

    @Autowired
    private AsynTaskExec asynTaskExec;

    @Autowired
    private OpenTestingConversion e2EConversion;

    @Autowired
    private Tracer tracer;

    @Autowired
    private RandomData randomData;

    //pause flag to stop inject/check execution, because they might trigger injects...
    private List<String> pauseByLabel = new ArrayList<>();

    /**
     * schedule test
     */
    @LogExecutionTime
    public String scheduleTest(TestCaseDTO test) {            
        try {
            if (test.getInjections() == null) test.setInjections(new ArrayList<>());
            if (test.getChecks() == null) test.setChecks(new ArrayList<>());
            log.info("planing "+test.getTestid()+" with "+test.getInjections().size()+" injections and "+test.getChecks().size()+" checks");  

            //validation - check file existence
            for (TestCaseInjectionDTO inject : test.getInjections()) {
                String content = testCaseFileRepository.select(test.getTestid(), inject.getSourcefile());
                log.debug(content);
                if (content == null || content.length() < 1) return "file not found: "+inject.getSourcefile();
            }
            for (TestCaseCheckDTO check : test.getChecks()) {
                String content = testCaseFileRepository.select(test.getTestid(), check.getExpectedfile());
                log.debug(content);
                if (content == null || content.length() < 1) return "file not found: "+check.getExpectedfile();                
            }

            //deactivated testcase needs to deactivate all injects and checks, to deactivate active timers
            if (!test.isActivation()) {
                test.getInjections().forEach(i -> { i.setActivation(false); });
                test.getChecks().forEach(c -> { c.setActivation(false); });
            }

            //store test case as JSON for later usage (original)
            testCaseFileRepository.insert(test.getTestid(), TESTCASESTORAGE, e2EConversion.object2json(test));

            //store test case
            testCaseRepository.insert(test);

            //check activation
            String message = "";
            StringBuffer ttlBuf = new StringBuffer();
            if (test.isActivation()) {

                //send test case to all adapters for preparation (parallel)
                adapterResolver.getAllAdapter().parallelStream().forEach(
                    a -> {
                        if (a != null) a.createRequiredComponents(test);
                        else log.warn("adapter is null");
                    }
                );

                //create inject timers
                for (TestCaseInjectionDTO inject : test.getInjections()) {   
                       
                    if (inject.isActivation()) {
                        //create timer and store ID
                        Adapter adapter = adapterResolver.getAdapter(inject.getService());
                        if (adapter != null) {                            
                            timerFactory.createInjectionTimer(test.getTestid(), inject,this, asynTaskExec);
                            if (inject.getCreatets() == null) {
                                ttlBuf.append(" " + inject.getInjectid() + "=" + inject.getTimetolive());
                            } else {
                                ttlBuf.append(" " + inject.getInjectid() + "=" + inject.getTimetolive() + "(" + inject.getCreatets() + ")");
                            }
                        } else {
                            log.warn("cannot create timer, unknown adapter: "+inject.getService());
                        }
                    }
                }             

                message = "Test scheduled - here's the time-to-live of your injects:"+ttlBuf.toString();
            } else {
                message = "Test stored, but inactive";
            }  
            
            //store injects with timer IDs (must be done for deactivated ones, too)
            testCaseInjectionRepository.insert(test.getTestid(), test.getInjections());

            //increase prometheus
            prometheus.incrementSchedule(test, true);
            prometheus.incrementTests(test);

            return message;
        } catch (Exception e) {
            log.error("could not schedule test", e);

            //increase prometheus
            prometheus.incrementSchedule(test, false);

            return e.getMessage();
        }
    }

    /**
     * execute inject
     * @throws JsonProcessingException
     * @throws JsonMappingException
     * @throws InterruptedException
     */
    @LogExecutionTime
    public boolean executeInject(String testid, TestCaseInjectionDTO inject, String source, String bulkid,
                                 TestCaseRandomDataDTO randomdata)
            throws JsonMappingException, JsonProcessingException, InterruptedException {

        //add new span
        Span span = tracer.nextSpan().name("e2e.inject."+testid+"."+inject.getInjectid())
                .tag("injectid", inject.getInjectid())
                .tag("testid", testid)
                .tag("class", this.getClass().getSimpleName())
                .tag("method", "executeInject")
                .start();        

        Boolean injected = null;

        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {

            //read original test case to use original check definition
            TestCaseDTO test = this.getOriginalTestCase(testid);

            //pause
            if (this.isPause(test.getLabels(),
                "inject deactivated for label "+pauseByLabel+": "+ testid + " " + inject.getInjectid())) return false;

            //disable inject for fully disabled test cases
            if (!test.isActivation()) {
                log.info("E2ETest " + testid + "." + inject.getInjectid() + " - deactivated");
                return false;
            }

            //read or create random data if parameter is not set
            if (randomdata == null) randomdata = randomData.getRandomData(testid, inject);

            //create checks for this inject (parallel)
            this.createAndStoreChecks(inject.getChecks(), randomdata, test, bulkid, null, span.context().traceIdString());

            //we need to wait a few ms because of really fast executions
            Thread.sleep(10);

            //inject
            Adapter adapter = adapterResolver.getAdapter(inject.getService());
            injected = adapter.inject(testid, inject, randomdata);

            //increase prometheus
            prometheus.incrementInject(testid, inject, injected, test.getLabels());

            log.info("##### INJECT ##### " + testid + "." + inject.getInjectid() + ": " + translateResult(injected) + " " + source);
        } finally {
            span.finish();
        }
        return injected;
    }

    /**
     * create required check instances
     */
    @LogExecutionTime
    private void createAndStoreChecks(List<String> checks, TestCaseRandomDataDTO randomdata, TestCaseDTO test, String bulkid, 
                                        String parentcheck, String traceid) {
        long now = System.currentTimeMillis();
        if (parentcheck == null) parentcheck = "#";
        if (checks != null) {
            final TestCaseRandomDataDTO finalRandomdata = randomdata;
            String finalParentcheck = parentcheck;
            checks.parallelStream().forEach(
                    checkString -> {

                        //check recursion checks
                        if (finalParentcheck.equals(checkString)) {
                            log.warn("infinite loop detected - check " + checkString + " not stored");
                            return;
                        }

                        //search check
                        TestCaseCheckDTO check = null;
                        for (TestCaseCheckDTO ch : test.getChecks()) {
                            if (ch.getCheckid().equals(checkString)) {
                                check = ch;
                                break;
                            }
                        }

                        //check recursion sub-checks
                        if (check.getChecks() != null && check.getChecks().contains(finalParentcheck)) {
                            log.warn("infinite loop detected - check "+checkString+" not executed");
                             return;
                        }

                        //if available persiste new one
                        if (check != null && check.isActivation()) {

                            //add additional data to id
                            check.setCheckid(check.getCheckid() + "_" + now);
                            check.setRandomdata(finalRandomdata);
                            check.setBulkid(bulkid);
                            check.setTraceid(traceid);

                            //create
                            testCaseCheckRepository.insert(test.getTestid(), check);
                        }
                    }
            );
        }
    }  
    
    
    /**
     * execute check
     */
    @LogExecutionTime
    public Boolean executeCheck(TestCaseCheckDTO check, boolean ageValidationOnly, Object... args) throws JsonProcessingException, InterruptedException {

        //add new span
        Span span = tracer.nextSpan().name("e2e.check."+check.getTestid()+"."+check.getCheckid())
                .tag("checkid", check.getCheckid())
                .tag("testid", check.getTestid())
                .tag("class", this.getClass().getSimpleName())
                .tag("method", "executeInject")
                .start();

        TestCaseDTO test = new TestCaseDTO();
        try (Tracer.SpanInScope ws = tracer.withSpanInScope(span)) {

            //disable check for deactivated ones                
            if (!check.isActivation()) {
                log.debug("CheckExecution "+check.getTestid()+"."+check.getCheckid()+" - deactivated");
                return null;
            }

            //read original test case to use the labels
            test = this.getOriginalTestCase(check.getTestid());

            //pause                    
            if (this.isPause(test.getLabels(), 
                "check deactivated for label "+pauseByLabel+": "+ check.getTestid() + " - " + check.getCheckid())) return null;                  

            //disable check for fully disabled test cases (including already stored checks)
            if (!test.isActivation()) {
                log.info("E2ETest "+check.getTestid()+"."+check.getCheckid()+" - deactivated");
                //set to false
                check.setSuccess(false);
                testCaseCheckRepository.updateSuccess(check);
                return false;
            }

            //checks need to use the latest connect details
            TestCaseCheckDTO newCheck = null;
            for (TestCaseCheckDTO tmp : test.getChecks()) {
                if (tmp!= null && tmp.getCheckid().equalsIgnoreCase(getCleanCheckID(check.getCheckid()))) {
                    newCheck = tmp;
                    break;
                }
            }
            if (newCheck != null) {
                check.setConnectpassword(newCheck.getConnectpassword());
                check.setConnectstring(newCheck.getConnectstring());
                check.setConnectuser(newCheck.getConnectuser());
                check.setJwtpassword(newCheck.getJwtpassword());
                check.setJwtuser(newCheck.getJwtuser());
                check.setServiceparam(newCheck.getServiceparam());
            }

            //check
            Adapter adapter = adapterResolver.getAdapter(check.getService());
            Boolean success = false;            
            if (!ageValidationOnly) {
                //normal check
                success = adapter.check(check, args);
            }

            //write result           
            if (success) {
                check.setSuccess(true);                        
                testCaseCheckRepository.updateSuccess(check);

                //execute additional injects (not parallel, correct order might be required)
                for (String inject : check.getInjects()) {

                    //search inject object
                    TestCaseInjectionDTO injectDO = null;
                    for (TestCaseInjectionDTO tmp : test.getInjections()) {
                        if (tmp.getInjectid().equalsIgnoreCase(inject)) {
                            injectDO = tmp;
                            break;
                        }
                    }

                    //use found inject
                    if (injectDO != null) {

                        //validate loop
                        if (injectDO.getChecks() != null && injectDO.getChecks().contains(getCleanCheckID(check.getCheckid()))) {
                            log.warn("infinite loop detected - inject "+injectDO.getInjectid()+" not executed");
                        } else {
                            //execute with existing data
                            this.executeInject(check.getTestid(), injectDO, "check-triggered",
                                    check.getBulkid(), check.getRandomdata());
                        }
                    }
                }

                //create additional checks for this check (parallel)
                this.createAndStoreChecks(check.getChecks(), check.getRandomdata(), test, check.getBulkid(), this.getCleanCheckID(check.getCheckid()), 
                                            span.context().traceIdString());

            } else {
                if (LocalDateTime.now().isAfter(check.getTargetts())) {
                    //to old
                    check.setSuccess(false);                    
                    testCaseCheckRepository.updateSuccess(check);                                       
                } else {
                    //no result
                    check.setSuccess(null);                   
                }
            }            

            //increase prometheus
            if (!ageValidationOnly) prometheus.incrementCheck(check, getCleanCheckID(check.getCheckid()), test.getLabels());

            log.info("##### CHECK ##### "+check.getTestid()+"."+check.getCheckid()+" executed: "+translateResult(check.getSuccess()));
            return check.getSuccess();
        } catch (InterruptedException ie) {
            log.error("CheckExecution "+check.getTestid()+"."+check.getCheckid()+" interrupted with exception", ie);
            // Restore interrupted state...
            Thread.currentThread().interrupt();
            return false;
        } catch (Exception e) {
            log.error("CheckExecution "+check.getTestid()+"."+check.getCheckid()+" failed with exception", e);

            //increase prometheus
            prometheus.incrementCheck(check, getCleanCheckID(check.getCheckid()), test.getLabels());

            return false;
        } finally {
            span.finish();
        }
    }

    /**
     * transfer success object to text
     * @param success Boolean
     * @return String
     */
    private String translateResult(Boolean success) {
        if (success == null) return "without";
        if (success) return "success";
        return "failed";
    }

    /**
     * remove added value to check id
     */
    public String getCleanCheckID(String checkid) {
        //checkid - remove suffix
        int posLastUnderscore = checkid.lastIndexOf("_");
        return checkid.substring(0, posLastUnderscore);
    }

    /**
     * read inject     
     */
    @LogExecutionTime
    public TestCaseInjectionDTO getInject(String testid, String timerid) {
        return testCaseInjectionRepository.selectByIdAndTimer(testid, timerid);
    } 

    /**
     * get all checks for a service and connectstring
     */
    @LogExecutionTime
    public List<TestCaseCheckDTO> getChecksByServiceAndConnectstringAndOpen(String service, String connectstring, String connectuser) {
        return testCaseCheckRepository.selectByServiceAndConnectstringAndOpen(service, connectstring, connectuser);
    }

    /**
     * get all checks for a service
     */
    @LogExecutionTime
    public List<TestCaseCheckDTO> getChecksByServiceAndOpen(List<String> services) {
        return testCaseCheckRepository.selectByServiceAndOpen(services);
    }

    /**
     * store File
     */
    @LogExecutionTime
    public String storeFile(String testid, String filename, String content) {
        try {
            testCaseFileRepository.insert(testid, filename, content);
            return "File stored";
        } catch (Exception e) {
            log.error("could not store file", e);
            return e.getMessage();
        }
    } 
    
    /**
     * read File
     */
    @LogExecutionTime
    public String readFile(String testid, String filename) {
        try {
            return testCaseFileRepository.select(testid, filename);            
        } catch (Exception e) {
            log.error("could read stored file", e);
            return e.getMessage();
        }
    }

    /**
     * read test cases with injects
     */
    @LogExecutionTime
    public List<TestCaseDTO> getTestsWithInjects() {

        //read from DB
        List<TestCaseDTO> tests =  testCaseRepository.selectAll();

        //extend in parallel
        tests.parallelStream().forEach(
                test -> {
                    test.setInjections(testCaseInjectionRepository.select(test.getTestid()));
                }
        );

        return tests;
    }

    /**
     * read original test case from stored JSON
     */
    @LogExecutionTime
    public TestCaseDTO getOriginalTestCase(String testid) throws JsonMappingException, JsonProcessingException {
        String jsonTest = testCaseFileRepository.select(testid, TESTCASESTORAGE);
        if (jsonTest == null || jsonTest.length() < 1) return null;
        return e2EConversion.json2object(jsonTest, TestCaseDTO.class);
    }        

    /**
     * create check timer
     */
    @LogExecutionTime
    public void createCheckTimer(List<String> services, String cron) {
        timerFactory.createCheckTimer(services, cron, this, asynTaskExec);
    }

    /**
     * create check timer
     */
    @LogExecutionTime
    public void createCheckTimer(List<String> services, String[] cron) {
        for (String cr : cron) timerFactory.createCheckTimer(services, cr, this, asynTaskExec);
    }

    /**
     * remove test id
     */
    @LogExecutionTime
    public String removeTest(String testid) {
        StringBuffer st = new StringBuffer();
        testCaseCheckRepository.deleteByTestId(testid);
        st.append("checks deleted");
        testCaseInjectionRepository.deleteByTestId(testid);
        st.append(", injects deleted");
        testCaseRepository.delete(testid);
        st.append(", test deleted");
        testCaseFileRepository.deleteByTestId(testid);
        st.append(", files deleted");
        return st.toString();
    }

    /**
     * read original test cases from stored JSON
     */
    @LogExecutionTime
    public List<TestCaseDTO> getOriginalTestCases() throws JsonMappingException, JsonProcessingException {
        List<TestCaseDTO> testcases = new ArrayList<>();
        //we should not do in parallel - this could be a lot of test cases
        for (String jsonTest : testCaseFileRepository.selectByFilename(TESTCASESTORAGE)) {
            testcases.add(e2EConversion.json2object(jsonTest, TestCaseDTO.class));
        }
        return testcases;
    }

    /**
     * check if pause is set
     */    
    public boolean isPause(List<String> labels, String message) {
        for (String pauselabel : this.pauseByLabel) {
            if (labels.contains(pauselabel) || pauselabel.equals(TestManager.ALLPAUSELABEL)) {
                log.warn(message);
                return true;
            }
        }        
        return false;
    }

    /**
     * pause injects and checks
     * @param byLabel by label or for all
     */
    @LogExecutionTime
    public void pause(boolean value, String byLabel) {

        //unique handling
        if (byLabel == null || byLabel.isEmpty() || byLabel.isBlank())  byLabel = TestManager.ALLPAUSELABEL;

        //internal list for checks and injects
        if (value) {
            this.pauseByLabel.add(byLabel);
        } else {
            //we do not remove special pause when removing the "all" one
            this.pauseByLabel.remove(byLabel);
        }

        //adapter should know it
        final String finalLabel = byLabel;
        adapterResolver.getAllAdapter().parallelStream().forEach(
                adapter -> {
                    adapter.pause(value, finalLabel);
                }
        );
    }

    /**
     * auto-delete old data
     */
    @LogExecutionTime
    public void autodelete() {

        LocalDateTime maxAge = LocalDateTime.now().minusDays(e2ETestConfig.getAutodelete());

        //cleanup database checks (files, injects, tests still required)
        testCaseCheckRepository.deleteOlderThan(maxAge);

        log.info("autodelete ("+e2ETestConfig.getAutodelete()+" days) done");
    }    

}