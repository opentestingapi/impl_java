package org.opentesting.services.execution.persistence;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

import javax.annotation.PostConstruct;

import org.opentesting.services.execution.dto.TestCaseCheckDTO;
import org.opentesting.services.execution.dto.TestCaseRandomDataDTO;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.LogExecutionTime;
import com.fasterxml.jackson.core.JsonProcessingException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.support.DataAccessUtils;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Controller;

import lombok.extern.slf4j.Slf4j;

@Controller
@Slf4j
public class TestCaseCheckRepository {

    private static final String TABLENAME = "testcasecheck";
    private static final String[] SQLS = {"create table if not exists "+TABLENAME+" (testid VARCHAR(1000) NOT NULL)"
        ,"alter table "+TABLENAME+" add if not exists checkid VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists activation boolean"
        ,"alter table "+TABLENAME+" add if not exists service VARCHAR(100)"
        ,"alter table "+TABLENAME+" add if not exists expectedfile VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists expectedtype VARCHAR(100)"
        ,"alter table "+TABLENAME+" add if not exists connectstring VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists startts timestamp"
        ,"alter table "+TABLENAME+" add if not exists targetts timestamp"
        ,"alter table "+TABLENAME+" add if not exists mandatory boolean"
        ,"alter table "+TABLENAME+" add if not exists serviceparam VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists connectuser VARCHAR(100)"
        ,"alter table "+TABLENAME+" add if not exists connectpassword VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists success boolean"
        ,"alter table "+TABLENAME+" add if not exists resultts timestamp"
        ,"alter table "+TABLENAME+" add if not exists maxwaittime VARCHAR(100)"
        ,"alter table "+TABLENAME+" add if not exists randomdata text"
        ,"alter table "+TABLENAME+" add if not exists jwtuser VARCHAR(100)"
        ,"alter table "+TABLENAME+" add if not exists jwtpassword VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists injects VARCHAR(1000)" //# concatenated
        ,"alter table "+TABLENAME+" add if not exists checks VARCHAR(1000)" //# concatenated
        ,"alter table "+TABLENAME+" add if not exists bulkid VARCHAR(100)"
        ,"alter table "+TABLENAME+" add if not exists result2random VARCHAR(10000)" //# concatenated
        ,"alter table "+TABLENAME+" add if not exists traceid VARCHAR(100)"
    };

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private OpenTestingConversion e2EConversion;

    @PostConstruct
    @LogExecutionTime
    public void prepareDB() {
        for (String sql : SQLS) {
            try {
                log.info("execute: "+sql);
                jdbcTemplate.execute(sql);
            } catch (Exception e) {
                log.warn("warning preparing internal database", e);
            }
        }
    }

    @LogExecutionTime
    public void insert(String testid, TestCaseCheckDTO check) throws DataAccessException {        
        LocalDateTime now = LocalDateTime.now();
        String sql = "insert into "+TABLENAME+" (testid, checkid, activation, service, expectedfile, expectedtype, connectstring, startts, targetts, "+
            "mandatory, serviceparam, connectuser, connectpassword, jwtuser, jwtpassword, maxwaittime, randomdata, injects, checks, bulkid, result2random, traceid) "+
            "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
        long waitSec = OpenTestingConversion.toSeconds(check.getMaxwaittime());
        String randomdata = null;
        try {
            randomdata = e2EConversion.object2json(check.getRandomdata());
        } catch (JsonProcessingException e) {
            log.error("cannot create random data string for "+check.getRandomdata(), e);
        }
        jdbcTemplate.update(sql, testid, check.getCheckid(), check.isActivation(), check.getService(), check.getExpectedfile(), check.getExpectedtype(), 
                check.getConnectstring(), now, now.plusSeconds(waitSec), check.isMandatory(), check.getServiceparam(),
                check.getConnectuser(), check.getConnectpassword(), check.getJwtuser(), check.getJwtpassword(),
                check.getMaxwaittime(), randomdata, OpenTestingConversion.toStringDatabase(check.getInjects()),
                OpenTestingConversion.toStringDatabase(check.getChecks()), check.getBulkid(),
                OpenTestingConversion.toStringDatabase(check.getResult2random()), check.getTraceid());
    }

    @LogExecutionTime
    public void deleteByCheckId(String checkid) {
        String sql = "delete from "+TABLENAME+" where checkid = ?";
        jdbcTemplate.update(sql, checkid);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> select(String testid) {
        String sql = "select * from "+TABLENAME+" where testid = ?";      
        return jdbcTemplate.query(sql, (rs, rowNum) -> 
            getFromRS(rs), testid);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectLast(String testid, int lastchecks) {
        String sql = "select * from "+TABLENAME+" where testid = ? order by startts desc limit ?";   
        return jdbcTemplate.query(sql, (rs, rowNum) -> 
            getFromRS(rs), testid, lastchecks);
    }

    @LogExecutionTime
    public TestCaseCheckDTO selectByCheckId(String checkid) {
        String sql = "select * from "+TABLENAME+" where checkid = ?";      
        return DataAccessUtils.singleResult(jdbcTemplate.query(sql, (rs, rowNum) -> 
            getFromRS(rs), checkid));
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectByServiceAndOpen(List<String> services) {
        String sql = "select * from "+TABLENAME+" where service = ? and success is null";  
        return services.parallelStream().flatMap(s -> {
            return jdbcTemplate.query(sql, (rs, rowNum) -> getFromRS(rs), s).stream();
        }).collect(Collectors.toList()); 
    }

    private TestCaseCheckDTO getFromRS(ResultSet rs) throws SQLException {   
        TestCaseRandomDataDTO randomdata = null;
        String randomdatastr = "";
        try {  
            randomdatastr = rs.getString("randomdata");  
            if (randomdatastr != null)
                randomdata = e2EConversion.json2object(randomdatastr, TestCaseRandomDataDTO.class);
        } catch (JsonProcessingException e) {
            log.error("cannot read random data for "+rs.getString("testid")+" "+rs.getString("checkid")+" "
                +OpenTestingConversion.toLDT(rs.getTimestamp("startts")), e);
        }
        return new TestCaseCheckDTO(rs.getString("checkid"), OpenTestingConversion.toBooleanFromDatabase(rs, "activation"),
                rs.getString("service"), rs.getString("expectedfile"),
                rs.getString("expectedtype"), rs.getString("maxwaittime"),
                OpenTestingConversion.toBooleanFromDatabase(rs, "mandatory"), rs.getString("serviceparam"),
                rs.getString("connectstring"), rs.getString("connectuser"),
                rs.getString("connectpassword"), rs.getString("jwtuser"),
                rs.getString("jwtpassword"), OpenTestingConversion.toListFromDatabase(rs.getString("injects")),
                OpenTestingConversion.toListFromDatabase(rs.getString("checks")),
                OpenTestingConversion.toListFromDatabase(rs.getString("result2random")),
                OpenTestingConversion.toLDT(rs.getTimestamp("startts")), OpenTestingConversion.toLDT(rs.getTimestamp("targetts")),
                OpenTestingConversion.toBooleanFromDatabase(rs, "success"), rs.getString("testid"),
                OpenTestingConversion.toLDT(rs.getTimestamp("resultts")), randomdata, rs.getString("bulkid"), 
                rs.getString("traceid"));
    }

    @LogExecutionTime
    public void updateSuccess(TestCaseCheckDTO check) {
        String sql = "update "+TABLENAME+" set success = ?, resultts = ? where testid = ? and checkid = ?";
        jdbcTemplate.update(sql, check.getSuccess(), LocalDateTime.now(), check.getTestid(), check.getCheckid());
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectByServiceAndConnectstringAndOpen(String service, String connectstring, String connectuser) {
        String sql = "select * from "+TABLENAME+" where service = ? and connectstring = ? and connectuser = ? and success is null";      
        return jdbcTemplate.query(sql, (rs, rowNum) -> 
            getFromRS(rs), service, connectstring, connectuser);
    }

    @LogExecutionTime
    public void deleteByTestId(String testid) {
        String sql = "delete from "+TABLENAME+" where testid = ?";
        jdbcTemplate.update(sql, testid);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectByBulkId(String bulkid) {
        String sql = "select * from "+TABLENAME+" where bulkid = ?";
        return jdbcTemplate.query(sql, (rs, rowNum) ->
                getFromRS(rs), bulkid);
    }

    @LogExecutionTime
    public void deleteOlderThan(LocalDateTime maxAge) {
        String sql = "delete from "+TABLENAME+" where targetts < ?";
        jdbcTemplate.update(sql, maxAge);
    }

}
