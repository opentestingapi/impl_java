package org.opentesting.services.execution;

import java.time.LocalDateTime;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseValidationDTO;
import org.opentesting.persistence.IndexRepository;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.adapter.AdapterResolver;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.services.scheduler.AsynTaskExec;
import org.opentesting.services.scheduler.TimerFactory;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.exceptions.NotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class TestScheduler extends TestAbstractHandler {

    private static final String FILENOTFOUND = "file not found: ";
    
    @Autowired
    private AdapterResolver adapterResolver;   
    
    @Autowired
    private TimerFactory timerFactory;    

    @Autowired
    private Prometheus prometheus;

    @Autowired
    private AsynTaskExec asynTaskExec;

    @Autowired
    private TestInjection testInjection;    

    /**
     * schedule test
     */
    @LogExecutionTime
    public String scheduleTest(TestCaseDTO test) {            
        try {
            log.info("planing "+test.getId()+" with "+test.getInjections().size()+" injections and "+test.getChecks().size()+" checks");  

            //validation - check file existence
            checkFileExistence(test);

            //deactivated testcase needs to deactivate all injects and checks, to deactivate active timers
            inheritActivation(test);              

            //check activation
            String message = "";
            StringBuilder ttlBuf = new StringBuilder();
            if (test.isActive()) {

                //send test case to all adapters for preparation (parallel)
                prepareAdapters(test);

                //create inject timers
                createInjectionTimers(test, ttlBuf);       

                message = "Test scheduled - here's the time-to-live of your injects:"+ttlBuf.toString();
            } else {
                message = "Test stored, but inactive";
            }  
            
            //store test case as JSON for later usage (original, including injection timer IDs)
            this.storeTest(test); 

            //create label index to enable search
            for (String label : test.getLabels()) {
                indexRepository.insert(IndexRepository.LABELINDEX, label, test.getId());
            }

            //increase prometheus
            prometheus.incrementSchedule(test, true);
            prometheus.incrementTests(test);

            return message;
        } catch (Exception e) {
            log.error("could not schedule test", e);

            //increase prometheus
            prometheus.incrementSchedule(test, false);

            return e.getMessage();
        }
    }

    private void createInjectionTimers(TestCaseDTO test, StringBuilder ttlBuf) {
        for (TestCaseInjectionDTO inject : test.getInjections()) {                       
            if (inject.isActive()) {
                //create timer and store ID
                Adapter adapter = adapterResolver.getAdapter(inject.getService().getType());
                if (adapter != null) {                            
                    String timerid = timerFactory.createInjectionTimer(test.getId(), inject, adapter, asynTaskExec, testInjection);
                    inject.setTimerid(timerid);                                
                    if (inject.getSchedulets() == null) {
                        inject.setSchedulets(LocalDateTime.now());
                    }
                    ttlBuf.append(" " + inject.getInjectid() + "=" + inject.getTimetolive() + " (" + inject.getSchedulets() + ")");
                } else {
                    log.warn("cannot create timer, unknown adapter: "+inject.getService().getType());
                }
            }
        }
    }

    private void checkFileExistence(TestCaseDTO test) throws NotFoundException {
        for (TestCaseInjectionDTO inject : test.getInjections()) {
            checkFileExistenceInject(inject, test);
        }
        for (TestCaseCheckDTO check : test.getChecks()) {
            checkFileExistenceCheck(check, test);
        }
    }

    private void checkFileExistenceInject(TestCaseInjectionDTO inject, TestCaseDTO test) throws NotFoundException {
        if (inject.getSourcefile() != null && inject.getSourcefile().length() > 0) {
            String content = getFile(test.getId(), inject.getSourcefile());
            log.debug(content);
            if (content == null || content.length() < 1) throw new NotFoundException(FILENOTFOUND+inject.getSourcefile());
        }
    }

    private void checkFileExistenceCheck(TestCaseCheckDTO check, TestCaseDTO test) throws NotFoundException {
        for (TestCaseValidationDTO val : check.getValidations()) {
            if (val.getRequest() != null && val.getRequest().length() > 0) {
                String content = getFile(test.getId(), val.getRequest());
                log.debug(content);
                if (content == null || content.length() < 1) throw new NotFoundException(FILENOTFOUND+val.getRequest()); 
                checkFileExistenceCheckResponses(val, test);
            }
        } 
    }

    private void checkFileExistenceCheckResponses(TestCaseValidationDTO val, TestCaseDTO test) throws NotFoundException {
        for (String response : val.getResponse()) {
            if (response != null && response.length() > 0) {
                String content = getFile(test.getId(), response);
                log.debug(content);
                if (content == null || content.length() < 1) throw new NotFoundException(FILENOTFOUND+response); 
            }
        }
    }

    private void inheritActivation(TestCaseDTO test) {
        if (!test.isActive()) {
            test.getInjections().forEach(i ->  i.setActive(false));
            test.getChecks().forEach(c -> c.setActive(false));
        }
    }

    private void prepareAdapters(TestCaseDTO test) {
        adapterResolver.getAllAdapter().parallelStream().forEach(
                    a -> {
                        if (a != null) a.createRequiredComponents(test);
                        else log.warn("adapter is null");
                    }
                );
    }
    
}
