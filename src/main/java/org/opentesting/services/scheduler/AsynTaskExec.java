package org.opentesting.services.scheduler;

import java.time.LocalDateTime;
import java.util.List;

import com.fasterxml.jackson.core.JsonProcessingException;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseCheckResultDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.services.execution.Startup;
import org.opentesting.services.execution.TestCheck;
import org.opentesting.services.execution.TestInjection;
import org.opentesting.services.execution.TestManager;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.LogExecutionTime;

import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class AsynTaskExec {

    private static final String ERRORMSGCHECK = "CheckTask execution failed: ";
    private static final String ERRORMSGINJECT = "InjectTask execution failed: ";

    private Prometheus prometheus;

    private TimerFactory timerFactory;

    private ApplicationContextProvider applicationContextProvider;

    public AsynTaskExec(ApplicationContextProvider applicationContextProvider) {
        prometheus = applicationContextProvider.getBean(Prometheus.class);
        timerFactory = applicationContextProvider.getBean(TimerFactory.class);
        this.applicationContextProvider = applicationContextProvider;
    }    

    /**
     * async method executed from timer
     */
    @Async
    @LogExecutionTime
    public void timerInject(String testid, String injectid, String timerid) {
        try {            

            //load data from database
            TestCaseInjectionDTO inject = getInject(testid, injectid, timerid);

            //in case the DTO is null we can cancel ourselfs (new upload happened)
            if (inject == null) {
                timerFactory.cancelInjectionTimer(timerid);
                log.info("E2EInjectTask "+testid+" - inject null - "+timerid+" canceled");
                return;
            }

            //if deactivated we can skip
            if (!inject.isActive()) {
                log.info("E2EInjectTask "+testid+"."+inject.getInjectid()+" - "+timerid+" deactivated");
                return;
            }

            //calculate expired ones
            long seconds = OpenTestingConversion.toSeconds(inject.getTimetolive());
            LocalDateTime mindate = LocalDateTime.now().plusSeconds(-seconds);
            boolean ttlExpired = inject.getSchedulets().isBefore(mindate);

            //in case the DTO is outdated we can cancel ourselfs (new upload happened)
            if (ttlExpired) {
                timerFactory.cancelInjectionTimer(timerid);
                return;
            }

            //inject
            TestInjection testInjection = applicationContextProvider.getBean(TestInjection.class);
            testInjection.executeInject(testid, inject, timerid, "");

            //increment Prometheus
            prometheus.incrementExecution("timerinject", inject.getService().getType());
        } catch (InterruptedException ie) {
            log.error(ERRORMSGINJECT+testid+" - "+injectid+" - "+timerid, ie);
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            log.error(ERRORMSGINJECT+testid+" - "+injectid+" - "+timerid, e);
        }
    }

    /**
     * execute the check timer, will re-schedule itself
     */
    @LogExecutionTime
    public void timerCheck(String instanceid, CheckExecutionTask task) {

        TestCaseCheckResultDTO result = new TestCaseCheckResultDTO();
        LocalDateTime beforeExec = LocalDateTime.now();
        TestCheck testCheck = applicationContextProvider.getBean(TestCheck.class);
        TestCaseCheckDTO check = null;
        try {  

            // load data from database
            check = testCheck.getCheckByInstanceId(instanceid);

            // execute check
            result = testCheck.executeCheck(check);
            
            // increment Prometheus
            prometheus.incrementExecution("timercheck", check.getService().getType());   

        } catch (InterruptedException ie) {
            log.error(ERRORMSGCHECK+instanceid, ie);
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            log.error(ERRORMSGCHECK+instanceid, e);
        } finally {
            // replan if no result and additional time check in case of exceptions   
            if (!result.isWithResult() && check != null && beforeExec.isBefore(check.getTargetts())) {
                testCheck.scheduleCheck(check, task);
            }
        }
    }

    /**
     * async method executed from timer
     */
    @Async
    @LogExecutionTime
    public void maxwaittimeCheck(String service) {
        try {    

            TestCheck testCheck = applicationContextProvider.getBean(TestCheck.class);
            
            //load data from database
            List<TestCaseCheckDTO> checks = testCheck.getOpenChecksUnexpired(service);

            //execute maxwaittime checks, can be done after each other to save memory
            int expiries = 0;
            for (TestCaseCheckDTO check : checks) {
                if (execmaxwaittimecheck(check, testCheck)) expiries++;
            }
            
            //increment Prometheus
            prometheus.incrementExecution("maxwaittimecheck", service);
            
            if (expiries > 0) {
                log.info("##### CHECK MAXWAITTIME TOTAL ##### " + service + ": total "+checks.size()+" / expired "+expiries);
            }

        } catch (Exception e) {
            log.error(ERRORMSGCHECK+service, e);
        }
    }

    /**
     * execute maxwaittime check for 1 service
     * @param service service
     * @param testCheck test check instance
     */
    private boolean execmaxwaittimecheck(TestCaseCheckDTO check, TestCheck testCheck) {
        try {                  
            return testCheck.executeMaxwaittimeCheck(check);
        } catch (InterruptedException ie) {
            log.error(ERRORMSGCHECK+check.getInstanceid(), ie);
            Thread.currentThread().interrupt();
            return false;
        } catch (Exception e) {
            log.error(ERRORMSGCHECK+check.getInstanceid(), e);
            return false;
        }
    }

    /**
     * async method to initially load the test cases
     */
    @Async
    @LogExecutionTime
    public void startup() {
        try {
            Startup startup = applicationContextProvider.getBean(Startup.class);

            //load data from database
            startup.loadTestCases();
        } catch (Exception e) {
            log.error("loadTestCases failed", e);
        }
    }
    
    /**
     * auto-delete old data
     */
    @LogExecutionTime
    public void autodelete() {
        try {
            TestManager testPlaner = applicationContextProvider.getBean(TestManager.class);

            //autodelete
            testPlaner.autodelete();
        } catch (Exception e) {
            log.error("autodelete failed", e);
        }
    }

    /**
     * read inject     
     * @throws JsonProcessingException
     * @throws NotFoundException
     */
    @LogExecutionTime
    public TestCaseInjectionDTO getInject(String testid, String injectid, String timerid) throws JsonProcessingException {
        try {
            TestInjection testInjection = applicationContextProvider.getBean(TestInjection.class);
            TestCaseDTO test = testInjection.getTest(testid);
            for (TestCaseInjectionDTO inj : test.getInjections()) {
                //need to check injectid and timerid, as we might have an outdated timer
                if (inj.getInjectid().equals(injectid) && inj.getTimerid().equals(timerid)) {
                    return inj;
                }
            }
            return null;
        } catch (NotFoundException nfe) {
            //test case deleted
            log.warn(nfe.getMessage(), nfe);
            return null;
        }

    }    

}