package org.opentesting.services.scheduler;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import com.fasterxml.jackson.core.JsonProcessingException;

import org.opentesting.dto.CheckResultDTO;
import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.execution.Startup;
import org.opentesting.services.execution.TestCheck;
import org.opentesting.services.execution.TestInjection;
import org.opentesting.services.execution.TestManager;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.LogExecutionTime;

import org.springframework.dao.DataAccessException;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class AsynTaskExec {

    private static final String ERRORMSGCHECK = "CheckTask execution failed: ";
    private static final String ERRORMSGINJECT = "InjectTask execution failed: ";

    private Prometheus prometheus;

    private TimerFactory timerFactory;

    public AsynTaskExec(ApplicationContextProvider applicationContextProvider) {
        prometheus = applicationContextProvider.getBean(Prometheus.class);
        timerFactory = applicationContextProvider.getBean(TimerFactory.class);
    }    

    /**
     * async method executed from timer
     */
    @Async
    @LogExecutionTime
    public void timerInject(String testid, String injectid, String timerid,
            Adapter adapter, TestInjection testInjection) {
        try {            

            //load data from database
            TestCaseInjectionDTO inject = getInject(testInjection, testid, injectid, timerid);

            //in case the DTO is null we can cancel ourselfs (new upload happened)
            if (inject == null) {
                timerFactory.cancelInjectionTimer(timerid);
                log.info("E2EInjectTask "+testid+" - inject null - "+timerid+" canceled");
                return;
            }

            //if deactivated we can skip
            if (!inject.isActive()) {
                log.info("E2EInjectTask "+testid+"."+inject.getInjectid()+" - "+timerid+" deactivated");
                return;
            }

            //calculate expired ones
            long seconds = OpenTestingConversion.toSeconds(inject.getTimetolive());
            LocalDateTime mindate = LocalDateTime.now().plusSeconds(-seconds);
            boolean ttlExpired = inject.getSchedulets().isBefore(mindate);

            //in case the DTO is outdated we can cancel ourselfs (new upload happened)
            if (ttlExpired) {
                timerFactory.cancelInjectionTimer(timerid);
                return;
            }

            //inject
            testInjection.executeInject(testid, inject, timerid, "", adapter);

            //increment Prometheus
            prometheus.incrementExecution("timerinject", inject.getService().getType());
        } catch (InterruptedException ie) {
            log.error(ERRORMSGINJECT+testid+" - "+injectid+" - "+timerid, ie);
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            log.error(ERRORMSGINJECT+testid+" - "+injectid+" - "+timerid, e);
        }
    }

    /**
     * async method executed from timer
     */
    @Async
    @LogExecutionTime
    public void timerCheck(TestCaseCheckDTO check, Adapter adapter, TestCheck testCheck) {
        try {           

            //load data from database
            List<TestCaseCheckDTO> checks = getChecksByServiceAndOpen(services, testCheck);           

            // execute checks in parallel
            List<Boolean> results = checks.parallelStream().map(c -> {
                try {                    
                    return testCheck.executeCheck(c, adapter);
                } catch (InterruptedException ie) {
                    log.error(ERRORMSGCHECK+c.getCheckid()+"-"+c.getInstanceid(), ie);
                    Thread.currentThread().interrupt();
                    return null;
                } catch (Exception e) {
                    log.error(ERRORMSGCHECK+c.getCheckid()+"-"+c.getInstanceid(), e);
                    return null;
                }
            }).collect(Collectors.toList());

            //prepare result
            CheckResultDTO result = OpenTestingConversion.list2CheckResult(results);
            
            //increment Prometheus
            prometheus.incrementExecution("timercheck", OpenTestingConversion.toString(services, "#"));

            if (!checks.isEmpty()) {
                log.info("##### CHECK TOTAL ##### " + services + ": total "+checks.size()+" / success "+result.getSuccess()
                    +" / failed "+result.getFailed()+" / without "+result.getWithout());
            }

        } catch (Exception e) {
            log.error(ERRORMSGCHECK+services, e);
        }
    }

    /**
     * async method executed from timer
     */
    @Async
    @LogExecutionTime
    public void maxwaittimeCheck(List<String> services, TestCheck testCheck) {
        try {    
            
            //load data from database
            List<TestCaseCheckDTO> checks = getChecksByServiceAndOpenAndUnexpired(services, testCheck);

            //execute maxwaittime checks, can be done after each other to save memory
            for (TestCaseCheckDTO check : checks) {
                execmaxwaittimecheck(check, testCheck);
            }
            
            //increment Prometheus
            prometheus.incrementExecution("maxwaittimecheck", OpenTestingConversion.toString(services, "#"));            

        } catch (Exception e) {
            log.error(ERRORMSGCHECK+services, e);
        }
    }

    /**
     * execute maxwaittime check for 1 service
     * @param service service
     * @param testCheck test check instance
     */
    private void execmaxwaittimecheck(TestCaseCheckDTO check, TestCheck testCheck) {
        try {                    
            testCheck.executeMaxwaittimeCheck(check);
        } catch (InterruptedException ie) {
            log.error(ERRORMSGCHECK+check.getCheckid()+"-"+check.getInstanceid(), ie);
            Thread.currentThread().interrupt();
        } catch (Exception e) {
            log.error(ERRORMSGCHECK+check.getCheckid()+"-"+check.getInstanceid(), e);
        }
    }

    /**
     * async method to initially load the test cases
     */
    @Async
    @LogExecutionTime
    public void startup(Startup startup) {
        try {
            //load data from database
            startup.loadTestCases();
        } catch (Exception e) {
            log.error("loadTestCases failed", e);
        }
    }
    
    /**
     * auto-delete old data
     */
    @LogExecutionTime
    public void autodelete(TestManager testPlaner) {
        try {
            //autodelete
            testPlaner.autodelete();
        } catch (Exception e) {
            log.error("autodelete failed", e);
        }
    }

    /**
     * read inject     
     * @throws JsonProcessingException
     * @throws NotFoundException
     */
    @LogExecutionTime
    public TestCaseInjectionDTO getInject(TestInjection testInjection, String testid, String injectid, String timerid) throws JsonProcessingException {
        try {
            TestCaseDTO test = testInjection.getTest(testid);
            for (TestCaseInjectionDTO inj : test.getInjections()) {
                //need to check injectid and timerid, as we might have an outdated timer
                if (inj.getInjectid().equals(injectid) && inj.getTimerid().equals(timerid)) {
                    return inj;
                }
            }
            return null;
        } catch (NotFoundException nfe) {
            //test case deleted
            log.warn(nfe.getMessage(), nfe);
            return null;
        }

    }

    /**
     * get all checks for a service that are not expired
     * @throws JsonProcessingException
     * @throws DataAccessException
     */
    @LogExecutionTime
    public List<TestCaseCheckDTO> getChecksByServiceAndOpenAndUnexpired(List<String> services, TestCheck testCheck) throws DataAccessException {
        List<TestCaseCheckDTO> result = new ArrayList<>();
        for (String serv : services) {
            result.addAll(testCheck.getOpenChecksUnexpired(serv));
        }
        return result;
    } 

}