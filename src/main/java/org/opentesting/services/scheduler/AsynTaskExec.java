package org.opentesting.services.scheduler;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import com.fasterxml.jackson.core.JsonProcessingException;

import org.opentesting.dto.CheckResultDTO;
import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.execution.Startup;
import org.opentesting.services.execution.TestCheck;
import org.opentesting.services.execution.TestInjection;
import org.opentesting.services.execution.TestManager;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.LogExecutionTime;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class AsynTaskExec {

    @Autowired
    private Prometheus prometheus;

    @Autowired
    private TimerFactory timerFactory;

    /**
     * async method executed from timer
     */
    @Async
    @LogExecutionTime
    public void timerInject(String testid, String injectid, String timerid,
            Adapter adapter, TestInjection testInjection) {
        try {            

            //load data from database
            TestCaseInjectionDTO inject = getInject(testInjection, testid, injectid, timerid);

            //in case the DTO is null we can cancel ourselfs (new upload happened)
            if (inject == null) {
                timerFactory.cancelInjectionTimer(timerid);
                log.info("E2EInjectTask "+testid+" - inject null - "+timerid+" canceled");
                return;
            }

            //if deactivated we can skip
            if (!inject.isActive()) {
                log.info("E2EInjectTask "+testid+"."+inject.getInjectid()+" - "+timerid+" deactivated");
                return;
            }

            //calculate expired ones
            long seconds = OpenTestingConversion.toSeconds(inject.getTimetolive());
            LocalDateTime mindate = LocalDateTime.now().plusSeconds(-seconds);
            boolean ttlExpired = inject.getSchedulets().isBefore(mindate);

            //in case the DTO is outdated we can cancel ourselfs (new upload happened)
            if (ttlExpired) {
                timerFactory.cancelInjectionTimer(timerid);
                return;
            }

            //inject
            testInjection.executeInject(testid, inject, timerid, "", adapter);

            //increment Prometheus
            prometheus.incrementExecution("timerinject", inject.getService().getType());

        } catch (Exception e) {
            log.error("E2EInjectTask execution failed: "+testid+" - "+injectid+" - "+timerid, e);
        }
    }

    /**
     * async method executed from timer
     */
    @Async
    @LogExecutionTime
    public void timerCheck(List<String> services, Adapter adapter, TestCheck testCheck) {
        try {           

            //load data from database
            List<TestCaseCheckDTO> checks = getChecksByServiceAndOpen(services, testCheck);           

            // execute checks in parallel
            List<Boolean> results = checks.parallelStream().map(c -> {
                try {                    
                    return testCheck.executeCheck(c, adapter.timerValidateAgeOnly(), adapter);
                } catch (Exception e) {
                    log.error("E2ECheckTask execution failed: "+c.getCheckid(), e);
                    return null;
                }
            }).collect(Collectors.toList());

            //prepare result
            CheckResultDTO result = OpenTestingConversion.list2CheckResult(results);
            
            //increment Prometheus
            prometheus.incrementExecution("timercheck", OpenTestingConversion.toString(services, "#"));

            log.info("##### CHECK TOTAL ##### " + services + ": total "+checks.size()+" / success "+result.getSuccess()
                +" / failed "+result.getFailed()+" / without "+result.getWithout());

        } catch (Exception e) {
            log.error("E2ECheckTask execution failed: "+services, e);
        }
    }

    /**
     * async method to initially load the test cases
     */
    @Async
    @LogExecutionTime
    public void startup(Startup startup) {
        try {
            //load data from database
            startup.loadTestCases();
        } catch (Exception e) {
            log.error("loadTestCases failed", e);
        }
    }
    
    /**
     * auto-delete old data
     */
    @LogExecutionTime
    public void autodelete(TestManager testPlaner) {
        try {
            //autodelete
            testPlaner.autodelete();
        } catch (Exception e) {
            log.error("autodelete failed", e);
        }
    }

    /**
     * read inject     
     * @throws JsonProcessingException
     * @throws NotFoundException
     */
    @LogExecutionTime
    public TestCaseInjectionDTO getInject(TestInjection testInjection, String testid, String injectid, String timerid) throws JsonProcessingException, NotFoundException {
        TestCaseDTO test = testInjection.getTest(testid);
        for (TestCaseInjectionDTO inj : test.getInjections()) {
            //need to check injectid and timerid, as we might have an outdated timer
            if (inj.getInjectid().equals(injectid) && inj.getTimerid().equals(timerid)) {
                return inj;
            }
        }
        return null;
    }

    /**
     * get all checks for a service
     * @throws JsonProcessingException
     * @throws DataAccessException
     */
    @LogExecutionTime
    public List<TestCaseCheckDTO> getChecksByServiceAndOpen(List<String> services, TestCheck testCheck) throws DataAccessException, JsonProcessingException {
        List<TestCaseCheckDTO> result = new ArrayList<>();
        for (String serv : services) {
            result.addAll(testCheck.getOpenChecks(serv));
        }
        return result;
    }  

}