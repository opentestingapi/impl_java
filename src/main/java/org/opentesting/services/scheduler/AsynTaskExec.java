package org.opentesting.services.scheduler;

import java.time.LocalDateTime;
import java.util.List;
import java.util.stream.Collectors;

import org.opentesting.dto.CheckResultDTO;
import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.persistence.TestCaseCheckRepository;
import org.opentesting.persistence.TestCaseInjectionRepository;
import org.opentesting.services.adapter.Adapter;
import org.opentesting.services.execution.Startup;
import org.opentesting.services.execution.TestCheck;
import org.opentesting.services.execution.TestInjection;
import org.opentesting.services.execution.TestManager;
import org.opentesting.services.prometheus.Prometheus;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.LogExecutionTime;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class AsynTaskExec {

    @Autowired
    private Prometheus prometheus;

    @Autowired
    private TestCaseInjectionRepository testCaseInjectionRepository;

    @Autowired
    private TestCaseCheckRepository testCaseCheckRepository;

    @Autowired
    private TimerFactory timerFactory;

    /**
     * async method executed from timer
     */
    @Async
    @LogExecutionTime
    public void timerInject(String testid, String injectid, String timerid,
            Adapter adapter, TestInjection testInjection) {
        try {            

            //load data from database
            TestCaseInjectionDTO inject = getInject(testid, timerid);

            //in case the DTO is null we can cancel ourselfs (new upload happened)
            if (inject == null) {
                timerFactory.cancelInjectionTimer(timerid);
                log.info("E2EInjectTask "+testid+" - inject null - "+timerid+" canceled");
                return;
            }

            //if deactivated we can skip
            if (!inject.isActivation()) {
                log.info("E2EInjectTask "+testid+"."+inject.getInjectid()+" - "+timerid+" deactivated");
                return;
            }

            //calculate expired ones
            long seconds = OpenTestingConversion.toSeconds(inject.getTimetolive());
            LocalDateTime mindate = LocalDateTime.now().plusSeconds(-seconds);
            boolean ttlExpired = inject.getCreatets().isBefore(mindate);

            //in case the DTO is outdated we can cancel ourselfs (new upload happened)
            if (ttlExpired) {
                timerFactory.cancelInjectionTimer(timerid);
                return;
            }

            //inject
            testInjection.executeInject(testid, inject, timerid, "", null, adapter);

            //increment Prometheus
            prometheus.incrementExecution("timerinject", inject.getService());

        } catch (Exception e) {
            log.error("E2EInjectTask execution failed: "+testid+" - "+injectid+" - "+timerid, e);
        }
    }

    /**
     * async method executed from timer
     */
    @Async
    @LogExecutionTime
    public void timerCheck(List<String> services, Adapter adapter, TestCheck testCheck) {
        try {           

            //load data from database
            List<TestCaseCheckDTO> checks = getChecksByServiceAndOpen(services);           

            // execute checks in parallel
            List<Boolean> results = checks.parallelStream().map(c -> {
                try {
                    //kafka max wait time check timer should check age only
                    if (c.getService().equalsIgnoreCase("kafka")) {
                        return testCheck.executeCheck(c, true, adapter);  
                    }
                    return testCheck.executeCheck(c, false, adapter);           
                } catch (Exception e) {
                    log.error("E2ECheckTask execution failed: "+c.getCheckid(), e);
                    return null;
                }
            }).collect(Collectors.toList());

            //prepare result
            CheckResultDTO result = OpenTestingConversion.list2CheckResult(results);
            
            //increment Prometheus
            prometheus.incrementExecution("timercheck", OpenTestingConversion.toString(services, "#"));

            log.info("##### CHECK TOTAL ##### " + services + ": total "+checks.size()+" / success "+result.getSuccess()
                +" / failed "+result.getFailed()+" / without "+result.getWithout());

        } catch (Exception e) {
            log.error("E2ECheckTask execution failed: "+services, e);
        }
    }

    /**
     * async method to initially load the test cases
     */
    @Async
    @LogExecutionTime
    public void startup(Startup startup) {
        try {
            //load data from database
            startup.loadTestCases();
        } catch (Exception e) {
            log.error("loadTestCases failed", e);
        }
    }
    
    /**
     * auto-delete old data
     */
    @LogExecutionTime
    public void autodelete(TestManager testPlaner) {
        try {
            //autodelete
            testPlaner.autodelete();
        } catch (Exception e) {
            log.error("autodelete failed", e);
        }
    }

    /**
     * read inject     
     */
    @LogExecutionTime
    public TestCaseInjectionDTO getInject(String testid, String timerid) {
        return testCaseInjectionRepository.selectByIdAndTimer(testid, timerid);
    }

    /**
     * get all checks for a service
     */
    @LogExecutionTime
    public List<TestCaseCheckDTO> getChecksByServiceAndOpen(List<String> services) {
        return testCaseCheckRepository.selectByServiceAndOpen(services);
    }  

}