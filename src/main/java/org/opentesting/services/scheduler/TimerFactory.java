package org.opentesting.services.scheduler;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ScheduledFuture;

import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.services.execution.Startup;
import org.opentesting.services.execution.TestCheck;
import org.opentesting.services.execution.TestManager;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.LogExecutionTime;

import org.springframework.scheduling.TaskScheduler;
import org.springframework.scheduling.support.CronTrigger;
import org.springframework.stereotype.Component;

import jakarta.annotation.PreDestroy;
import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class TimerFactory { 

    private TaskScheduler taskScheduler;

    private ApplicationContextProvider applicationContextProvider;

    public TimerFactory(ApplicationContextProvider applicationContextProvider) {
        taskScheduler = applicationContextProvider.getBean(TaskScheduler.class);
        this.applicationContextProvider = applicationContextProvider;
    }    

    //1 timerid could have multiple futures
    private Map<String, List<ScheduledFuture<?>>> injecttimerstore = new HashMap<>();
    
    @LogExecutionTime
    public String createInjectionTimer(String testid, TestCaseInjectionDTO inject) {

        //create unique ID
        String timerid = UUID.randomUUID().toString();
        inject.setTimerid(timerid);

        //create timer - all should have th same timerid
        long counter = 0;
        for (String cron : inject.getCron()) {
            counter++;
            createInjectCronTimer(testid, inject.getInjectid(), timerid, cron);
        }

        if (counter > 0) log.info("Timer(s) "+timerid+" created: "+counter); 
        return timerid;    
    }

    private void createInjectCronTimer(String testid, String injectid, String timerid, String cron) {

        //create task
        InjectTask task = new InjectTask(testid, injectid, timerid, applicationContextProvider);

        //create cron trigger
        CronTrigger cronTrigger = new CronTrigger(cron);

        //schedule task
        ScheduledFuture<?> timertask = taskScheduler.schedule(task, cronTrigger);

        //store
        List<ScheduledFuture<?>> timerlist = injecttimerstore.get(timerid);
        if (timerlist == null) timerlist = new ArrayList<>();
        timerlist.add(timertask);
        injecttimerstore.put(timerid, timerlist);
    } 
    
    @LogExecutionTime
    public void cancelInjectionTimer(String timerid) {

        //cancel parallel 
        long size = injecttimerstore.get(timerid).size();
        injecttimerstore.get(timerid).forEach(
            timer -> timer.cancel(false)            
        );

        if (size > 0) log.info("Timer(s) "+timerid+" canceled: "+size);
    }    
    
    @LogExecutionTime
    public void createCronCheckTimer(String service, String cron, AsynTaskExec asynTaskExec, 
            TestCheck testCheck) {

        //create task
        CheckMaxwaittimeValidationTask task = new CheckMaxwaittimeValidationTask(service, applicationContextProvider);

        //create cron trigger
        CronTrigger cronTrigger = new CronTrigger(cron);

        //schedule task and store
        taskScheduler.schedule(task, cronTrigger);        
    }    

    @LogExecutionTime
    public void createCheckTimer(CheckExecutionTask task, long seconds) {        

        //schedule task and store
        taskScheduler.schedule(task, Instant.now().plusSeconds(seconds));  
    } 

    @LogExecutionTime
    public void createStartupTimer(Startup startup, AsynTaskExec asynTaskExec) {           

        //create task
        StartupTask task = new StartupTask(applicationContextProvider);  

        //schedule task with 15 sec delay
        taskScheduler.schedule(task, Instant.now().plusSeconds(15)); 
    }

    @PreDestroy
    private void close() {
        injecttimerstore.values().parallelStream().forEach(
            timers -> timers.forEach(timer -> timer.cancel(false))
        );
    }

    @LogExecutionTime
    public void createAutodeleteTimer(TestManager testPlaner, AsynTaskExec asynTaskExec) {

        //create task
        AutodeleteTask task = new AutodeleteTask(applicationContextProvider);

        //schedule once a hour
        taskScheduler.scheduleAtFixedRate(task,  Duration.ofHours(1));
    }

}