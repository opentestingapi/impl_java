package org.opentesting.services.random;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.Map.Entry;

import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.dto.TestCaseReplacementDTO;
import org.opentesting.dto.TestCaseReplacementValueDTO;
import org.opentesting.services.execution.TestAbstractHandler;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.exceptions.ValidationException;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.LogExecutionTime;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.github.curiousoddman.rgxgen.RgxGen;

import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

/**
 * random data managment
 */
@Component
@Slf4j
public class RandomData extends TestAbstractHandler {

    private Random secRandom = new SecureRandom();
    
    public RandomData(ApplicationContextProvider applicationContextProvider) {
        super(applicationContextProvider);
    }

    /**
     * read or create random data
     * @throws NotFoundException
     * @throws ValidationException
     */
    @LogExecutionTime
    public TestCaseRandomDataDTO getRandomData(String testid, TestCaseInjectionDTO inject) throws JsonProcessingException, NotFoundException, ValidationException {

        TestCaseRandomDataDTO randomdata = inject.getRandomdata();
        if (randomdata == null) randomdata = new TestCaseRandomDataDTO();

        //create all replacements
        for (TestCaseReplacementDTO replacement : inject.getReplacements()) {
            
            //do not override existing values
            if (!randomdata.contains(replacement.getKey())) {
                //sort value creators
                List<TestCaseReplacementValueDTO> repValueList = replacement.getValue();
                Collections.sort(repValueList, (a, b) -> Integer.compare(a.getOrder(), b.getOrder()));

                //inherit or generate
                StringBuilder valueBuf = new StringBuilder();
                for (TestCaseReplacementValueDTO repValue : repValueList) {
                    valueBuf.append(generateValue(repValue, replacement.getKey(), testid, randomdata)); 
                }

                //maxlength
                String value = valueBuf.toString();
                if (value.length() > replacement.getMaxlength()) {
                    value = value.substring(0, replacement.getMaxlength());
                }

                randomdata.add(replacement.getKey(), value);
            }
        }

        //store in database
        writeRandomDataStore(testid, inject, randomdata);

        return randomdata;
    }

    /**
     * write the random data store
     */
    public void writeRandomDataStore(String testid, TestCaseInjectionDTO inject, TestCaseRandomDataDTO randomdata)
            throws JsonProcessingException {
        // store in database
        this.storeFile(testid, TESTCASERANDOMDATASTORAGE.replace("###", inject.getInjectid()),
                openTestingConversion.object2json(randomdata));
    }

    /**
     * generate one value part
     * 
     * @param repValue TestCaseReplacementValueDTO
     * @return the value
     * @throws JsonProcessingException
     * @throws NotFoundException
     * @throws ValidationException
     */
    private String generateValue(TestCaseReplacementValueDTO repValue, String key, String testid, TestCaseRandomDataDTO randomdata)
            throws JsonProcessingException, NotFoundException, ValidationException {
        String result = "";
        switch (repValue.getType()) {
            case TestCaseReplacementValueDTO.TYPE_INHERITFROM:
                // reuse from different inject
                String jsonFile = this.getFile(testid, TESTCASERANDOMDATASTORAGE.replace("###", repValue.getValue()));
                TestCaseRandomDataDTO randomdatainject = openTestingConversion.json2object(jsonFile,
                        TestCaseRandomDataDTO.class);
                String sourcekey = key;
                //use param if it is set
                if (repValue.getParam() != null && repValue.getParam().length() > 0) {
                    sourcekey = repValue.getParam();
                }
                result = randomdatainject.get(sourcekey);
                break;
            case TestCaseReplacementValueDTO.TYPE_LIST:
                // obtain a number between [0 - size].
                List<String> listVals = Arrays.asList(repValue.getValue().split("\\|"));
                int n = secRandom.nextInt(listVals.size());
                result = listVals.get(n);
                break;
            case TestCaseReplacementValueDTO.TYPE_NOW:
                // use actual time
                LocalDateTime date = LocalDateTime.now();
                // add param
                if (repValue.getParam() != null && repValue.getParam().length() > 0) {
                    date = date.plusSeconds(OpenTestingConversion.toSeconds(repValue.getParam()));
                }
                // format
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(repValue.getValue());
                result = date.format(formatter);
                break;
            case TestCaseReplacementValueDTO.TYPE_REGEX:
                RgxGen rgxGen = new RgxGen(repValue.getValue());
                result = rgxGen.generate();
                break;
            case TestCaseReplacementValueDTO.TYPE_FILE:
                String content = this.getFile(testid, repValue.getValue());                
                List<String> lines = Arrays.asList(content.split("\\r?\\n"));                
                int m = secRandom.nextInt(lines.size());
                result = lines.get(m);
                break;
            case TestCaseReplacementValueDTO.TYPE_ADDITION:
                Double contentnumber = OpenTestingConversion.toDouble(randomdata.get(repValue.getValue()));
                result = "" + (contentnumber + OpenTestingConversion.toDouble(repValue.getParam()));
                break;
            default:
                log.warn("unknown type: >" + repValue.getType() + "<");
        }
        return result;
    }

    /**
     * replace placeholders with random data
     * 
     * @param content    file content
     * @param randomdata random data store
     * @return replaced file content
     */
    @LogExecutionTime
    public String addRandomData(String content, TestCaseRandomDataDTO randomdata) {
        if (randomdata != null && randomdata.getDatamap() != null) {
            for (Entry<String, String> repl : randomdata.getDatamap().entrySet()) {
                content = content.replaceAll(repl.getKey(), repl.getValue());
            }
        }
        return content;
    }

}