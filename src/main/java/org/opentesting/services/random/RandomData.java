package org.opentesting.services.random;

import java.security.SecureRandom;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.Map.Entry;

import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.dto.TestCaseReplacementDTO;
import org.opentesting.dto.TestCaseReplacementValueDTO;
import org.opentesting.services.execution.TestAbstractHandler;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.LogExecutionTime;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.github.curiousoddman.rgxgen.RgxGen;

import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

/**
 * random data managment
 */
@Component
@Slf4j
public class RandomData extends TestAbstractHandler {    

    private Random rand = new SecureRandom();

    /**
     * read or create random data
     * @throws NotFoundException
     */
    @LogExecutionTime
    public TestCaseRandomDataDTO getRandomData(String testid, TestCaseInjectionDTO inject) throws JsonMappingException, JsonProcessingException, NotFoundException {

        TestCaseRandomDataDTO randomdata = new TestCaseRandomDataDTO();

        //create all replacements
        for (TestCaseReplacementDTO replacement : inject.getReplacements()) {
            
            //sort value creators
            List<TestCaseReplacementValueDTO> repValueList = replacement.getValue();
            Collections.sort(repValueList, (a, b) -> Integer.valueOf(a.getOrder()).compareTo(Integer.valueOf(b.getOrder())));

            //inherit or generate
            StringBuffer valueBuf = new StringBuffer();
            for (TestCaseReplacementValueDTO repValue : repValueList) {
                valueBuf.append(generateValue(repValue, replacement.getKey(), testid)); 
            }

            //maxlength
            String value = valueBuf.toString();
            if (value.length() > replacement.getMaxlength()) {
                value = value.substring(0, replacement.getMaxlength());
            }

            randomdata.add(replacement.getKey(), value);
        }

        //store in database
        this.storeFile(testid, TESTCASERANDOMDATASTORAGE.replace("###", inject.getInjectid()), openTestingConversion.object2json(randomdata));

        return randomdata;
    }   
    
    /**
     * generate one value part
     * @param repValue TestCaseReplacementValueDTO
     * @return the value
     * @throws JsonProcessingException
     * @throws JsonMappingException
     * @throws NotFoundException
     */
    private String generateValue(TestCaseReplacementValueDTO repValue, String key, String testid) throws JsonMappingException, JsonProcessingException, NotFoundException {
        String result = "";
        switch (repValue.getType()) {
            case TestCaseReplacementValueDTO.TYPE_INHERITFROM:    
                //reuse from different inject
                String jsonFile = this.getFile(testid, TESTCASERANDOMDATASTORAGE.replace("###", repValue.getValue()));
                TestCaseRandomDataDTO randomdata = openTestingConversion.json2object(jsonFile, TestCaseRandomDataDTO.class);
                result = randomdata.get(key);
                break;
            case TestCaseReplacementValueDTO.TYPE_LIST:
                //obtain a number between [0 - size].    
                List<String> listVals = Arrays.asList(repValue.getValue().split("\\|"));        
                int n = rand.nextInt(listVals.size());
                result = listVals.get(n);
                break;  
            case TestCaseReplacementValueDTO.TYPE_NOW:
                //use actual time
                LocalDateTime date = LocalDateTime.now();
                //add param
                if (repValue.getParam() != null && repValue.getParam().length() > 0) {
                    date = date.plusSeconds(OpenTestingConversion.toSeconds(repValue.getParam()));
                }
                //format
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern(repValue.getValue());
                result = date.format(formatter);
                break; 
            case TestCaseReplacementValueDTO.TYPE_REGEX:
                RgxGen rgxGen = new RgxGen(repValue.getValue());
                result = rgxGen.generate();
                break;
            case TestCaseReplacementValueDTO.TYPE_FILE:
                String content = this.getFile(testid, repValue.getValue());
                List<String> lines = Arrays.asList(content.split("\\r?\\n"));
                int m = rand.nextInt(lines.size());
                result = lines.get(m);
                break;
            default:
                log.warn("unknown type: >"+repValue.getType()+"<");                      
        }
        return result;
    }

    /**
     * replace placeholders with random data
     * @param content file content
     * @param randomdata random data store
     * @return replaced file content
     */
    @LogExecutionTime
    public String addRandomData(String content, TestCaseRandomDataDTO randomdata) {
        if (randomdata != null && randomdata.getRandomdata() != null) {
            for (Entry<String,String> repl : randomdata.getRandomdata().entrySet()) {
                content = content.replaceAll(repl.getKey(), repl.getValue());
            }
        }
        return content;
    }
    
}