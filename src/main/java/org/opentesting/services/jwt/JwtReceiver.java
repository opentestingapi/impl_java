package org.opentesting.services.jwt;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.opentesting.services.lock.Lock;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.LogExecutionTime;
import com.fasterxml.jackson.core.type.TypeReference;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Controller;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import lombok.extern.slf4j.Slf4j;

/**
 * Jwt Receiver using POST and application/x-www-form-urlencoded
 */
@Controller
@Slf4j
public class JwtReceiver {

    @Autowired
    private RestTemplate restTemplate;

    @Autowired
    private Lock lock;

    @Autowired
    private OpenTestingConversion e2EConversion;

    /**
     * request JWT token from a URL
     * @throws URISyntaxException
     */
    @LogExecutionTime
    public String requestToken(String testid, String jwtPost, String jwtParam, String jwtHeader) {

        //must start with testid to get removed with test case upload
        String key = testid+"#"+jwtPost+"#"+jwtParam;

        try {
            if (lock.isLock(key)) {
                log.warn(testid+": jwtPost blocked - please check credential and upload test");
                return null;
            }

            URI url = new URI(jwtPost);     

            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

            //add headers
            addHeaderEntriesForRequest(jwtHeader, headers);
            MultiValueMap<String, String> map = addParametersForRequest(jwtParam);
            HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(map, headers);

            //send request
            ResponseEntity<String> response = restTemplate.postForEntity(url, request , String.class);

            //json to map
            TypeReference<Map<String,String>> ref = new TypeReference<>() {};
            Map<String, String> resultmap = e2EConversion.json2object(response.getBody(), ref);

            //read token
            String accessToken = resultmap.get("access_token");
            log.debug("using access token: {}", accessToken);

            log.info(testid+" JWT ok: " + jwtPost);

            return accessToken;
        } catch (Exception e) {
            log.error(testid+": JwtReceiver failed", e);
            lock.addLock(key);
            return null;
        }
    }

    private MultiValueMap<String, String> addParametersForRequest(String jwtParam) {
        MultiValueMap<String, String> map = new LinkedMultiValueMap<>();
        fillValueMap(map, Arrays.asList(jwtParam.split("&")));
        return map;
    }

    private void addHeaderEntriesForRequest(String jwtHeader, HttpHeaders headers) {
        MultiValueMap<String, String> headerEntriesMap = new LinkedMultiValueMap<>();
        List<String> jwtHeaderEntries = new LinkedList<>(Arrays.asList(jwtHeader.split("&")));
        fillValueMap(headerEntriesMap, jwtHeaderEntries);
        headers.addAll(headerEntriesMap);
    }

    private void fillValueMap(MultiValueMap<String, String> map, List<String> entries) {
        entries.forEach(
                par -> {
                    String[] pair = par.split("=");
                    if (pair.length > 1) {
                        map.add(pair[0], pair[1]);
                    }
                }
        );
    }

}