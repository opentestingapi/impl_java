package org.opentesting.services.rest;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Stream;

import jakarta.servlet.http.HttpServletResponse;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.services.execution.TestReporting;
import org.opentesting.services.rest.dto.BulkCheckResult;
import org.opentesting.services.rest.dto.TestCaseDTOWarning;
import org.opentesting.services.rest.dto.TestTreeDo;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.OpenTestingConfig;
import org.opentesting.util.exceptions.NotFoundException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;

@RestController
@Slf4j
@RequestMapping("/reporting")
public class ReportingController {

    private TestReporting testReporting;

    private OpenTestingConfig config;

    @Value("${logging.file.name}")
    private String logfile = "";

    @Value("${app.name}")
    private String appname;

    @Value("${app.version}")
    private String appversion;

    public ReportingController(ApplicationContextProvider applicationContextProvider) {
        testReporting = applicationContextProvider.getBean(TestReporting.class);
        config = applicationContextProvider.getBean(OpenTestingConfig.class);
    }

    @Operation(summary = "download 1 test case by ID")
    @GetMapping(value = "/test/{testid}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<TestCaseDTO> get(@Parameter(description = "testid ID test case") @PathVariable String testid,
            @Parameter(description = "lastchecks number of last checks") @RequestParam(defaultValue = "10") int lastchecks,
            HttpServletResponse response) {

        try {
            // validation
            if (config.getDownloadmaxchecks() < lastchecks) {
                return new ResponseEntity<>(
                        createWarning("lastchecks to high. allowed: " + config.getDownloadmaxchecks()),
                        HttpStatus.resolve(422));
            }

            TestCaseDTO test = testReporting.getTest(testid, lastchecks);            

            if (test == null) return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            return new ResponseEntity<>(test, HttpStatus.OK);
        } catch (NotFoundException nfe) {
            log.warn("test not found: "+testid, nfe);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } catch (Exception e) {
            log.error("loading test case failed", e);
            return new ResponseEntity<>(createWarning(e.getClass().getName()+": "+e.getMessage()), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Operation(summary = "download all test cases")
    @GetMapping(value = "/test", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<TestCaseDTO>> getAll(HttpServletResponse response) {

        try {          
            List<TestCaseDTO> tests = testReporting.getTests();
            if (tests == null) return new ResponseEntity<>(HttpStatus.NOT_FOUND);

            tests.stream().forEach(t -> testReporting.removePasswords(t));

            return new ResponseEntity<>(tests, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading test cases failed", e);
            return new ResponseEntity<>(createWarningList(e.getClass().getName()+": "+e.getMessage()), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Operation(summary = "download stored file for a test case")
    @GetMapping(value = "/file/{testid}/{filename}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> getFile(@Parameter(description = "testid ID test case") @PathVariable String testid,
            @Parameter(description = "filename name of the file") @PathVariable String filename,
            HttpServletResponse response) {

        try {
            String result = testReporting.getFile(testid, filename);            

            if (result == null) return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            return new ResponseEntity<>(result, HttpStatus.OK);
        } catch (NotFoundException nfe) {
            log.warn("test not found: "+testid+", "+filename, nfe);
            return new ResponseEntity<>(HttpStatus.NOT_FOUND);
        } catch (Exception e) {
            log.error("loading file for test case failed", e);
            return new ResponseEntity<>(e.getClass().getName()+": "+e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Operation(summary = "download test cases by label (comma-separated)")
    @GetMapping(value = "/search", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<TestCaseDTO>> search(
            @Parameter(description = "labels comma-separted labels") @RequestParam String labels,
            @Parameter(description = "lastchecks number of last checks") @RequestParam(defaultValue = "10") int lastchecks,
            HttpServletResponse response) {

        try {
            // validation
            if (labels == null || labels.length() < 1) {
                return new ResponseEntity<>(createWarningList("labels are mandatory"),
                        HttpStatus.resolve(422));
            }
            if (config.getDownloadmaxchecks() < lastchecks) {
                return new ResponseEntity<>(
                        createWarningList("lastchecks to high. allowed: " + config.getDownloadmaxchecks()),
                        HttpStatus.resolve(422));
            }

            return new ResponseEntity<>(
                testReporting.getTestsByLabel(Arrays.asList(labels.split(",")), lastchecks), HttpStatus.OK);
        } catch (Exception e) {
            log.error("searching test cases failed", e);
            return new ResponseEntity<>(createWarningList(e.getClass().getName()+": "+e.getMessage()), HttpStatus.INTERNAL_SERVER_ERROR);
        }        
    }

    @Operation(summary = "download bulk check result")
    @GetMapping(value = "/bulk", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<BulkCheckResult> bulk(
            @Parameter(description = "bulkid") @RequestParam String bulkid,
            HttpServletResponse response) {

        try {
            //build result
            BulkCheckResult result = new BulkCheckResult();
            result.setBulkid(bulkid);

            //read and add checks
            for (TestCaseCheckDTO check : testReporting.getChecksByBulkId(bulkid)) {
                result.addCheck(check);
            }

            //read and add injects
            result.setInjections(testReporting.getInjectionsByBulkId(bulkid));

            return new ResponseEntity<>(result, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading bulk checks failed", e);
            BulkCheckResult result = new BulkCheckResult();
            result.setError(e.getClass().getName()+": "+e.getMessage());
            result.setMandatorySuccess(false);
            result.setAllSuccess(false);
            return new ResponseEntity<>(result, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Operation(summary = "get version of this application")
    @GetMapping(value = "/version", produces = MediaType.TEXT_PLAIN_VALUE)
    public String version(HttpServletResponse response) {     
        return appname + " " + appversion;
    }

    @Operation(summary = "download filtered log")
    @GetMapping(value = "/log", produces = MediaType.TEXT_PLAIN_VALUE)
    public ResponseEntity<StreamingResponseBody> log(
            @Parameter(description = "filter") @RequestParam String filter,
            @Parameter(description = "max age logfiles in days") @RequestParam(defaultValue = "7") int maxage,
            HttpServletResponse response) {

        try {

            //read and order the log files
            File actuallog = new File(logfile);
            File logfolder = actuallog.getParentFile();

            //list logfiles and sort
            List<File> logfiles = new ArrayList<>(Arrays.asList(logfolder.listFiles()));
            if (maxage < 1) maxage = 7;
            long maxagems = System.currentTimeMillis() - (maxage * 24 * 60 * 60 * 1000);
            logfiles.removeIf(f -> f.lastModified() < maxagems);
            logfiles.removeIf(f -> !f.getName().endsWith(".log"));
            logfiles.removeIf(f -> !f.getName().startsWith("opentesting"));
            Collections.sort(logfiles, (o1, o2) -> (int)(o2.lastModified() - o1.lastModified()));

            //stream the log
            StreamingResponseBody stream = out -> {
                for (File thelogfile : logfiles) {

                    //ignore older ones

                    //print logfile name
                    out.write(("##### " + thelogfile.getName() + " #####\n").getBytes(StandardCharsets.UTF_8));

                    //stream the input file
                    streamInputFile(thelogfile, filter, out);

                    //empty line
                    out.write(("\n").getBytes(StandardCharsets.UTF_8));
                    out.flush();

                }
            };

            return new ResponseEntity<>(stream, HttpStatus.OK);

        } catch (Exception e) {
            log.error("reading filtered logs failed", e);
            StreamingResponseBody stream = out -> out.write(e.getMessage().getBytes(StandardCharsets.UTF_8));
            return new ResponseEntity<>(stream, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    private void streamInputFile(File logfile, String filter, OutputStream out) throws IOException {
        //stream the input file
        try (Stream<String> filestream = Files.lines(logfile.toPath(), StandardCharsets.UTF_8)) {
            AtomicBoolean lastout = new AtomicBoolean(false);
            String year = "" + Calendar.getInstance().get(Calendar.YEAR);
            filestream.forEach(
                    line -> {
                        if (line.contains(filter) || (!line.startsWith(year) && lastout.get())) {
                            try {
                                out.write((line + "\n").getBytes(StandardCharsets.UTF_8));
                                lastout.set(true);
                            } catch (IOException e) {
                                log.error("cannot write log to stream", e);
                            }
                        } else {
                            lastout.set(false);
                        }
                    }
            );
        }
    }

    @Operation(summary = "download a simple tree of the test structure")
    @GetMapping(value = "/testtree/{testid}", produces = MediaType.TEXT_HTML_VALUE)
    public ResponseEntity<String> getTestTree(@Parameter(description = "testid ID test case") @PathVariable String testid,            
            HttpServletResponse response) {

        try {
            //read the test case
            TestCaseDTO test = testReporting.getTest(testid, 0);

            //create the tree objects
            TestTreeDo tree = buildTestTree(test);

            //tree to text
            StringBuilder sb = new StringBuilder();

            //start with root injects
            Set<String> rootinjects = new HashSet<>();
            for (String inject : tree.getAllinjects()) {
                if (!tree.getSubinjects().contains(inject)) {
                    rootinjects.add(inject);
                    String label = "root";
                    if (tree.getCroninjects().contains(inject)) label = label+",cron";
                    addTreeInject(sb, label, inject, tree, "", test.getId());
                }
            }

            //add non-root cron injects
            for (String inject : tree.getCroninjects()) {
                if (!rootinjects.contains(inject)) addTreeInject(sb, "cron", inject, tree, "", test.getId());      
            }       

            return new ResponseEntity<>(sb.toString(), HttpStatus.OK);

        } catch (Exception e) {
            log.error("creating test tree failed", e);            
            return new ResponseEntity<>(e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }   
    
    private TestTreeDo buildTestTree(TestCaseDTO test) {
        TestTreeDo tree = new TestTreeDo();
        for (TestCaseInjectionDTO inject : test.getInjections()) {
            tree.getAllinjects().add(inject.getInjectid());
            if (inject.getCron() != null && !inject.getCron().isEmpty()) tree.getCroninjects().add(inject.getInjectid());                
            for (String check : inject.getChecks()) {   
                TestTreeDo.addToHashmapList(tree.getChecksByInject(), inject.getInjectid(), check);
            }
        }
        for (TestCaseCheckDTO check : test.getChecks()) {                
            for (String inject : check.getInjects()) {  
                tree.getSubinjects().add(inject);
                TestTreeDo.addToHashmapList(tree.getInjectionsByCheck(), check.getCheckid(), inject);
            }
            for (String subcheck : check.getChecks()) {                      
                TestTreeDo.addToHashmapList(tree.getChecksByCheck(), check.getCheckid(), subcheck);
            }
        }
        return tree;
    }

    private void addTreeInject(StringBuilder sb, String label, String inject, TestTreeDo tree, String prefix, String testid) {
        String link = "<a href=\"/trigger/inject/"+testid+"/"+inject+"\" target=\"_blank\">Execute</a>";
        String injectstr = inject+"&nbsp["+label+"]&nbsp"+link+"<br>";
        if (prefix.length() < 1) sb.append(injectstr);
        else sb.append(prefix+"+-&nbsp"+injectstr);
        for (String check : TestTreeDo.getListFromHashmap(tree.getChecksByInject(), inject)) {
            addTreeCheck(sb, check, tree, prefix, testid);
        }
    }

    private void addTreeCheck(StringBuilder sb, String check, TestTreeDo tree, String prefix, String testid) {
        sb.append(prefix+"+-&nbsp"+check+"<br>");
        for (String subinject : TestTreeDo.getListFromHashmap(tree.getInjectionsByCheck(), check)) {
            String sublabel = "chain";
            if (tree.getCroninjects().contains(subinject)) sublabel = sublabel+",cron";
            addTreeInject(sb, sublabel, subinject, tree, prefix+"&nbsp&nbsp&nbsp", testid);
        }
        for (String subcheck : TestTreeDo.getListFromHashmap(tree.getChecksByCheck(), check)) {            
            addTreeCheck(sb, subcheck, tree, prefix+"&nbsp&nbsp&nbsp", testid);
        }
    }

    /**
     * create DTO from warning
     * @param warn warning
     * @return DTO
     */
    private TestCaseDTO createWarning(String warn) {
        TestCaseDTOWarning warning = new TestCaseDTOWarning();
        warning.setWarning(warn);
        return warning;
    }

    /**
     * create DTO list from warning
     * @param warn warning
     * @return DTO
     */
    private List<TestCaseDTO> createWarningList(String warn) {
        List<TestCaseDTO> warninglist = new ArrayList<>();
        warninglist.add(createWarning(warn));
        return warninglist;
    }

}