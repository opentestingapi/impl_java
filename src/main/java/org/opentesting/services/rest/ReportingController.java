package org.opentesting.services.rest;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.util.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.stream.Stream;

import javax.servlet.http.HttpServletResponse;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.services.execution.TestReporting;
import org.opentesting.services.rest.dto.BulkCheckResult;
import org.opentesting.services.rest.dto.TestCaseDTOWarning;
import org.opentesting.util.OpenTestingConfig;
import org.opentesting.util.exceptions.NotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;

@Api(description = "download test cases for reporting")
@RestController
@Slf4j
@RequestMapping("/reporting")
public class ReportingController {

    @Autowired
    private TestReporting testReporting;

    @Autowired
    private OpenTestingConfig config;

    @Value("${logging.file.name}")
    private String logfile = "";

    @ApiOperation(value = "download 1 test case by ID")
    @GetMapping(value = "/test/{testid}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<TestCaseDTO> get(@ApiParam(value = "testid ID test case") @PathVariable String testid,
            @ApiParam(value = "lastchecks number of last checks") @RequestParam(defaultValue = "10") int lastchecks,
            HttpServletResponse response) {

        try {
            // validation
            if (config.getDownloadmaxchecks() < lastchecks) {
                return new ResponseEntity<TestCaseDTO>(
                        createWarning("lastchecks to high. allowed: " + config.getDownloadmaxchecks()),
                        HttpStatus.resolve(422));
            }

            TestCaseDTO test = null;
            try {
                test = testReporting.getTest(testid, lastchecks);
            } catch (NotFoundException nfe) {
                log.warn("test not found: "+testid, nfe);
                return new ResponseEntity<TestCaseDTO>(HttpStatus.NOT_FOUND);
            }

            if (test == null) return new ResponseEntity<TestCaseDTO>(HttpStatus.NOT_FOUND);
            return new ResponseEntity<TestCaseDTO>(test, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading test case failed", e);
            return new ResponseEntity<TestCaseDTO>(createWarning(e.getClass().getName()+": "+e.getMessage()), HttpStatus.resolve(500));
        }
    }

    @ApiOperation(value = "download stored file for a test case")
    @GetMapping(value = "/file/{testid}/{filename}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> getFile(@ApiParam(value = "testid ID test case") @PathVariable String testid,
            @ApiParam(value = "filename name of the file") @PathVariable String filename,
            HttpServletResponse response) {

        try {
            String result = "";
            try {
                result = testReporting.getFile(testid, filename);
            } catch (NotFoundException nfe) {
                log.warn("test not found: "+testid+", "+filename, nfe);
                return new ResponseEntity<String>(HttpStatus.NOT_FOUND);
            }

            if (result == null) return new ResponseEntity<String>(HttpStatus.NOT_FOUND);
            return new ResponseEntity<String>(result, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading file for test case failed", e);
            return new ResponseEntity<String>(e.getClass().getName()+": "+e.getMessage(), HttpStatus.resolve(500));
        }
    }

    @ApiOperation(value = "download test cases by label (comma-separated)")
    @GetMapping(value = "/search", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<TestCaseDTO>> search(
            @ApiParam(value = "labels comma-separted labels") @RequestParam String labels,
            @ApiParam(value = "lastchecks number of last checks") @RequestParam(defaultValue = "10") int lastchecks,
            HttpServletResponse response) {

        try {
            // validation
            if (labels == null || labels.length() < 1) {
                return new ResponseEntity<List<TestCaseDTO>>(createWarningList("labels are mandatory"),
                        HttpStatus.resolve(422));
            }
            if (config.getDownloadmaxchecks() < lastchecks) {
                return new ResponseEntity<List<TestCaseDTO>>(
                        createWarningList("lastchecks to high. allowed: " + config.getDownloadmaxchecks()),
                        HttpStatus.resolve(422));
            }

            return new ResponseEntity<List<TestCaseDTO>>(
                testReporting.getTestsByLabel(Arrays.asList(labels.split(",")), lastchecks), HttpStatus.OK);
        } catch (Exception e) {
            log.error("searching test cases failed", e);
            return new ResponseEntity<List<TestCaseDTO>>(createWarningList(e.getClass().getName()+": "+e.getMessage()), HttpStatus.resolve(500));
        }        
    }

    @ApiOperation(value = "download bulk check result")
    @GetMapping(value = "/bulk", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<BulkCheckResult> bulk(
            @ApiParam(value = "bulkid") @RequestParam String bulkid,
            HttpServletResponse response) {

        try {
            //build result
            BulkCheckResult result = new BulkCheckResult();
            result.setBulkid(bulkid);

            //read and add checks
            for (TestCaseCheckDTO check : testReporting.getChecksByBulkId(bulkid)) {
                result.addCheck(check);
            }

            //read and add injects
            result.setInjections(testReporting.getInjectionsByBulkId(bulkid));

            return new ResponseEntity<BulkCheckResult>(result, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading bulk checks failed", e);
            BulkCheckResult result = new BulkCheckResult();
            result.setError(e.getClass().getName()+": "+e.getMessage());
            result.setMandatorySuccess(false);
            result.setAllSuccess(false);
            return new ResponseEntity<BulkCheckResult>(result, HttpStatus.resolve(500));
        }
    }

    @ApiOperation(value = "download filtered log")
    @GetMapping(value = "/log", produces = MediaType.TEXT_PLAIN_VALUE)
    public ResponseEntity<StreamingResponseBody> log(
            @ApiParam(value = "filter") @RequestParam String filter,
            @ApiParam(value = "max age logfiles in days") @RequestParam(defaultValue = "7") int maxage,
            HttpServletResponse response) {

        try {

            //read and order the log files
            File actuallog = new File(logfile);
            File logfolder = actuallog.getParentFile();

            //list logfiles and sort
            List<File> logfiles = new ArrayList<>(Arrays.asList(logfolder.listFiles()));
            if (maxage < 1) maxage = 7;
            long maxagems = System.currentTimeMillis() - (maxage * 24 * 60 * 60 * 1000);
            logfiles.removeIf(f -> f.lastModified() < maxagems);
            Collections.sort(logfiles, (o1, o2) -> (int)(o2.lastModified() - o1.lastModified()));

            //stream the log
            StreamingResponseBody stream = out -> {
                for (File logfile : logfiles) {

                    //ignore older ones

                    //print logfile name
                    out.write(("##### " + logfile.getName() + " #####\n").getBytes(StandardCharsets.UTF_8));

                    //stream the input file
                    try (Stream<String> filestream = Files.lines(logfile.toPath(), StandardCharsets.UTF_8)) {
                        AtomicBoolean lastout = new AtomicBoolean(false);
                        String year = "" + Calendar.getInstance().get(Calendar.YEAR);
                        filestream.forEach(
                                line -> {
                                    if (line.contains(filter) || (!line.startsWith(year) && lastout.get())) {
                                        try {
                                            out.write((line + "\n").getBytes(StandardCharsets.UTF_8));
                                            lastout.set(true);
                                        } catch (IOException e) {
                                            log.error("cannot write log to stream", e);
                                        }
                                    } else {
                                        lastout.set(false);
                                    }
                                }
                        );
                    }

                    //empty line
                    out.write(("\n").getBytes(StandardCharsets.UTF_8));
                    out.flush();

                }
            };

            return new ResponseEntity<StreamingResponseBody>(stream, HttpStatus.OK);

        } catch (Exception e) {
            log.error("reading filtered logs failed", e);
            StreamingResponseBody stream = out -> {
                out.write(e.getMessage().getBytes(StandardCharsets.UTF_8));
            };
            return new ResponseEntity<StreamingResponseBody>(stream, HttpStatus.resolve(500));
        }
    }

    /**
     * create DTO from warning
     * @param warn warning
     * @return DTO
     */
    private TestCaseDTO createWarning(String warn) {
        TestCaseDTOWarning warning = new TestCaseDTOWarning();
        warning.setWarning(warn);
        return warning;
    }

    /**
     * create DTO list from warning
     * @param warn warning
     * @return DTO
     */
    private List<TestCaseDTO> createWarningList(String warn) {
        List<TestCaseDTO> warninglist = new ArrayList<>();
        warninglist.add(createWarning(warn));
        return warninglist;
    }

}