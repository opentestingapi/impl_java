package org.opentesting.services.rest;

import java.time.LocalDateTime;
import java.util.List;

import javax.servlet.http.HttpServletResponse;

import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.api0dot1.TestCaseDTOapi0dot1;
import org.opentesting.dto.api1dot0.TestCaseDTOapi1dot0;
import org.opentesting.dto.migration.TestCaseDTOMigration;
import org.opentesting.services.execution.TestManager;
import org.opentesting.services.execution.TestScheduler;
import org.opentesting.services.jsonvalidation.JsonValidator;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.MigrationException;
import org.opentesting.util.exceptions.ValidationException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import lombok.extern.slf4j.Slf4j;

@RestController
@Slf4j
@RequestMapping("/upload")
public class UploadController {

    @Autowired
    private TestManager testManager;

    @Autowired
    private TestScheduler testScheduler;

    @Autowired
    private TestCaseDTOMigration testCaseDTOMigration;

    @Autowired
    private OpenTestingConversion openTestingConversion;

    @Autowired
    private JsonValidator jsonValidator;

    @Operation(summary = "upload test case (please upload required files first), application/json")
    @PostMapping(value = "/test", 
                consumes = { MediaType.APPLICATION_JSON_VALUE }, 
                produces = MediaType.TEXT_PLAIN_VALUE)
    public ResponseEntity<String> testupload(@RequestBody String testcaseStr, HttpServletResponse response) {
        try {
            //create DTO and migrate
            TestCaseDTO testcase = null; 
            boolean migratedFrom0dot1 = false;     
            if (!testcaseStr.contains("testapi")) {
                //Version 0.1
                migratedFrom0dot1 = true;
                testcase = testCaseDTOMigration.toLatest(TestCaseDTOapi0dot1.class, testcaseStr);                
            }
            if (testcaseStr.replace(" ", "").contains("testapi\":\"1.0\"")) {
                //Version 1.0
                List<String> validations = jsonValidator.validateSchema(testcaseStr, "OpenTestApiSchema_v1.0.json");
                if (!validations.isEmpty()) {
                    throw new ValidationException(OpenTestingConversion.toString(validations, "; "));
                }
                testcase = testCaseDTOMigration.toLatest(TestCaseDTOapi1dot0.class, testcaseStr);
            }
            if (testcase == null) {
                throw new MigrationException("version unknown - you might want to use: testapi\":\"1.0\"");
            }
            if (testcase.getId() == null) {
                throw new ValidationException("id is mandatory");
            }
            String testcasestr = openTestingConversion.object2json(testcase);

            //schedule
            testcase.setUploadts(LocalDateTime.now());
            String result = testScheduler.scheduleTest(testcase);
            log.info("##### upload ##### test case "+testcase.getId()+" planned: "+result);

            //attach test case
            result += "\n\nyour test case:\n"+testcasestr;

            //migration hint
            if (migratedFrom0dot1) {
                result += "\n\nPlease DO use the new migrated test case instead of your old one!";
                result += "\nPlease DO check your replacements, regex might be incorrectly migrated!";
            }

            return new ResponseEntity<>(result+"\n", HttpStatus.OK);
        } catch (Exception e) {
            log.error("upload test case failed", e);
            return new ResponseEntity<>(e.getClass().getName()+": "+e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }
    
    @Operation(summary = "upload file for a test case")
    @PostMapping(value = "/file/{testid}/{filename}", 
                consumes = { MediaType.APPLICATION_JSON_VALUE, MediaType.TEXT_PLAIN_VALUE }, 
                produces = MediaType.TEXT_PLAIN_VALUE)
    public ResponseEntity<String> fileupload(@RequestBody String content,
            @Parameter(description = "testid ID test case") @PathVariable String testid,
            @Parameter(description = "filename name of the file") @PathVariable String filename,
            HttpServletResponse response) {

        try {    
            //store            
            testManager.storeFile(testid, filename, content);
            String result = testid+" - "+filename+" stored";
            log.info("##### upload ##### file "+testid+"/"+filename+" stored: "+result);

            return new ResponseEntity<>(result, HttpStatus.OK);
        } catch (Exception e) {
            log.error("upload test case failed", e);
            return new ResponseEntity<>(e.getClass().getName()+": "+e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Operation(summary = "remove test case")
    @DeleteMapping(value = "/test/{testid}", produces = MediaType.TEXT_PLAIN_VALUE)
    public ResponseEntity<String> testremoval(@Parameter(description = "testid ID test case") @PathVariable String testid,
            HttpServletResponse response) {
        try {

            //remove
            String result = testManager.removeTest(testid);
            log.info("##### upload ##### test case "+testid+" removed: "+result);

            return new ResponseEntity<>(result, HttpStatus.OK);
        } catch (Exception e) {
            log.error("remove test case failed", e);
            return new ResponseEntity<>(e.getClass().getName()+": "+e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

}