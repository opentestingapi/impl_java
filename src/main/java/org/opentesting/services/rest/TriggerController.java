package org.opentesting.services.rest;

import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.services.adapter.AdapterResolver;
import org.opentesting.services.execution.TestInjection;
import org.opentesting.services.execution.TestManager;
import org.opentesting.services.execution.TestReporting;
import org.opentesting.services.rest.dto.BulkInjectResult;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.exceptions.ValidationException;

import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import com.fasterxml.jackson.core.JsonProcessingException;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.regex.Pattern;

@RestController
@Slf4j
@RequestMapping("/trigger")
public class TriggerController {

    private static final String PATHCONNECTOR = "/";

    @Autowired
    private TestManager testManager;

    @Autowired
    private TestReporting testReporting;

    @Autowired
    private TestInjection testInjection;

    @Autowired
    private AdapterResolver adapterResolver; 

    @Operation(summary = "get available triggers")
    @GetMapping(value = "/", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<String>> get(HttpServletRequest request, HttpServletResponse response) {

        try {

            String url = request.getRequestURL().toString();
            if (!url.endsWith(PATHCONNECTOR)) {
                url = url + PATHCONNECTOR;
            }

            //read tests from database
            List<TestCaseDTO> tests = testReporting.getTests();
            Collections.sort(tests, (o1, o2) -> o1.getId().compareTo(o2.getId()));

            //create URLs
            List<String> urls = new ArrayList<>();
            for (TestCaseDTO test : tests) {
                for (TestCaseInjectionDTO inject : test.getInjections()) {
                    if (inject.isActive()) {
                        urls.add(url+"inject"+PATHCONNECTOR+test.getId()+PATHCONNECTOR+inject.getInjectid());
                    }
                }
            }

            if (tests.isEmpty()) return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            return new ResponseEntity<>(urls, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading inject URLs failed", e);
            return new ResponseEntity<>(createWarning(e.getClass().getName()+": "+e.getMessage()), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Operation(summary = "execute inject in browser")
    @GetMapping(value = "/inject/{testid}/{injectid}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> inject(@Parameter(description = "testid ID test case") @PathVariable String testid,
            @Parameter(description = "inject ID") @PathVariable String injectid,
            HttpServletResponse response) {

        try {

            String result = null;
            TestCaseInjectionDTO injectDto = null;

            //read test from database
            TestCaseDTO test = testManager.getTest(testid);
            for (TestCaseInjectionDTO inject : test.getInjections()) {
                if (inject.getInjectid().equals(injectid)) {
                    if (inject.isActive()) {
                        injectDto = inject;
                    } else {
                        result = testid + "." + injectid + ": inject deactivated";
                    }
                }
            }

            //execute inject
            if (injectDto != null) {
                result = testid+"."+injectid+": "+testInjection.executeInject(testid, injectDto, "manually-triggered",
                        "", adapterResolver.getAdapter(injectDto.getService().getType()));
            }

            if (result == null) return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            return new ResponseEntity<>(result, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading file for test case failed", e);
            return new ResponseEntity<>(e.getClass().getName()+": "+e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Operation(summary = "execute bulk of injects")
    @PostMapping(value = "/bulk", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<BulkInjectResult> bulk(@RequestBody List<String> injectlist,
                                            @Parameter(description = "delimiter testid injectid (default .)") @RequestParam(defaultValue = ".") String delimiter,
                                         HttpServletResponse response) throws InterruptedException {

        try {

            BulkInjectResult result = new BulkInjectResult();
            List<String> injectexecutions = new ArrayList<>();

            //set new ID
            result.setBulkid(UUID.randomUUID().toString());

            //do it one-by-one to not overload the server
            for (String injectinput : injectlist) {

                String[] splitvalues = injectinput.split(Pattern.quote(delimiter));

                //validation
                if (splitvalues.length != 2) {
                    injectexecutions.add(injectinput + ": invalid - please use testid.injectid or testid.*");
                    continue;
                }

                //read testid and injectid
                String testid = splitvalues[0];
                String injectid = splitvalues[1];

                //read test from database
                injectexecutions.addAll(executeInject(testid, injectid, result)); 
            }

            result.setInjectexecutions(injectexecutions);
            return new ResponseEntity<>(result, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading file for test case failed", e);
            if (e instanceof InterruptedException) Thread.currentThread().interrupt();
            BulkInjectResult result = new BulkInjectResult();
            result.setError(e.getClass().getName()+": "+e.getMessage());
            return new ResponseEntity<>(result, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    private List<String> executeInject(String testid, String injectid, BulkInjectResult result) throws JsonProcessingException, NotFoundException, InterruptedException, ValidationException {
        List<String> injectexecutions = new ArrayList<>();
        TestCaseDTO test = testManager.getTest(testid);
        if (test != null) {
            for (TestCaseInjectionDTO inject : test.getInjections()) {
                if (inject.getInjectid().equals(injectid) || injectid.equals("*")) {
                    if (inject.isActive()) {
                        // execute inject and add bulkid to checks
                        injectexecutions.add(testid + "." + inject.getInjectid() + ": "
                                + testInjection.executeInject(testid, inject, "bulk-triggered", result.getBulkid(),
                                        adapterResolver.getAdapter(inject.getService().getType())));
                    } else {
                        injectexecutions.add(testid + "." + inject.getInjectid() + ": deactivated");
                    }
                }
            }
        }
        return injectexecutions;
    }

    @Operation(summary = "pause injects and checks")
    @GetMapping(value = "/pause/{value}", produces = MediaType.TEXT_PLAIN_VALUE)
    public ResponseEntity<String> pause(@Parameter(description = "true/false") @PathVariable boolean value,
                                        @Parameter(description = "pause by label (optional)") @RequestParam(defaultValue = "") String byLabel,
                                         HttpServletResponse response) {

        try {

            testManager.pause(value, byLabel);

            return new ResponseEntity<>("pause set "+value + " for label: " + byLabel, HttpStatus.OK);
        } catch (Exception e) {
            log.error("cannot set pause", e);
            return new ResponseEntity<>(e.getClass().getName()+": "+e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * create result list from single warning
     * @param warn warning
     * @return List with single entry
     */
    private List<String> createWarning(String warn) {
        List<String> warning = new ArrayList<>();
        warning.add(warn);
        return warning;
    }

}
