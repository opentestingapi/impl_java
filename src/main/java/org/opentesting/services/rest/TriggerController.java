package org.opentesting.services.rest;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import lombok.extern.slf4j.Slf4j;
import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TraceDTO;
import org.opentesting.services.adapter.AdapterResolver;
import org.opentesting.services.execution.TestInjection;
import org.opentesting.services.execution.TestManager;
import org.opentesting.services.execution.TestReporting;
import org.opentesting.services.rest.dto.BulkInjectResult;
import org.opentesting.services.rest.dto.DataGeneratorRequest;
import org.opentesting.util.exceptions.NotFoundException;
import org.opentesting.util.exceptions.ValidationException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;

@RestController
@Slf4j
@RequestMapping("/trigger")
public class TriggerController {

    private static final String PATHCONNECTOR = "/";

    @Autowired
    private TestManager testManager;

    @Autowired
    private TestReporting testReporting;

    @Autowired
    private TestInjection testInjection;

    @Autowired
    private AdapterResolver adapterResolver;

    @Autowired
    private ObjectMapper objectmapper;

    @Operation(summary = "get available triggers")
    @GetMapping(value = "/", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<String>> get(HttpServletRequest request, HttpServletResponse response) {

        try {

            String url = request.getRequestURL().toString();
            if (!url.endsWith(PATHCONNECTOR)) {
                url = url + PATHCONNECTOR;
            }

            //read tests from database
            List<TestCaseDTO> tests = testReporting.getTests();
            Collections.sort(tests, (o1, o2) -> o1.getId().compareTo(o2.getId()));

            //create URLs
            List<String> urls = new ArrayList<>();
            for (TestCaseDTO test : tests) {
                for (TestCaseInjectionDTO inject : test.getInjections()) {
                    if (inject.isActive()) {
                        urls.add(url+"inject"+PATHCONNECTOR+test.getId()+PATHCONNECTOR+inject.getInjectid());
                    }
                }
            }

            if (tests.isEmpty()) return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            return new ResponseEntity<>(urls, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading inject URLs failed", e);
            return new ResponseEntity<>(createWarning(e.getClass().getName()+": "+e.getMessage()), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Operation(summary = "execute inject in browser")
    @GetMapping(value = "/inject/{testid}/{injectid}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> inject(@Parameter(description = "testid ID test case") @PathVariable String testid,
            @Parameter(description = "inject ID") @PathVariable String injectid,
            HttpServletResponse response) {

        try {

            String result = null;
            TestCaseInjectionDTO injectDto = null;

            //read test from database
            TestCaseDTO test = testManager.getTest(testid);
            for (TestCaseInjectionDTO inject : test.getInjections()) {
                if (inject.getInjectid().equals(injectid)) {
                    if (inject.isActive()) {
                        injectDto = inject;
                    } else {
                        result = testid + "." + injectid + ": inject deactivated";
                    }
                }
            }

            //execute inject
            if (injectDto != null) {
                result = testid+"."+injectid+": "+testInjection.executeInject(testid, injectDto, "manually-triggered",
                        "", adapterResolver.getAdapter(injectDto.getService().getType()));
            }

            if (result == null) return new ResponseEntity<>(HttpStatus.NOT_FOUND);
            return new ResponseEntity<>(result, HttpStatus.OK);
        } catch (InterruptedException ie) {
            log.error("loading file for test case failed", ie);
            Thread.currentThread().interrupt();
            return new ResponseEntity<>(ie.getClass().getName()+": "+ie.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        } catch (Exception e) {
            log.error("loading file for test case failed", e);
            return new ResponseEntity<>(e.getClass().getName()+": "+e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Operation(summary = "executes only the inject part, disables check process, number of parallel threads can be configured")
    @PostMapping(value = "/datagenerator", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> datagenerator(@RequestBody DataGeneratorRequest dataGeneratorRequest) {

        try {
            String result = null;
            TestCaseInjectionDTO injectDto = null;

            //read test from database
            String testId = dataGeneratorRequest.getTestId();
            String injectId = dataGeneratorRequest.getInjectId();

            TestCaseDTO test = testManager.getTest(testId);
            for (TestCaseInjectionDTO inject : test.getInjections()) {

                if (inject.getInjectid().equals(injectId)) {
                    injectDto = inject;
                }
            }

            //execute inject
            if (injectDto != null) {
                AtomicInteger cnt = new AtomicInteger();
                for(int i = 0; i < dataGeneratorRequest.getCount(); i++) {

                    String jsonSource = objectmapper.writeValueAsString(injectDto);
                    TestCaseInjectionDTO injectDtoCopy = objectmapper.readValue(jsonSource, TestCaseInjectionDTO.class);

                    injectDtoCopy.setRandomdata(null);
                    injectDtoCopy.setChecks(new ArrayList<>()); // disable checks in case of data generation

                    testInjection.executeInjectAsync(
                            testId, injectDtoCopy,
                            "manually-triggered", "",
                            adapterResolver.getAdapter(injectDto.getService().getType()),
                            new TraceDTO(), cnt);
                }
                log.info("##### INJECT ##### " + dataGeneratorRequest.getCount() + " injects started.");
                result = testId + "." + injectId + ": creation of " + dataGeneratorRequest.getCount() + " succ started.";
            } else {
                result = "no such test case: " + testId + "." + injectId;
                return new ResponseEntity<>(result, HttpStatus.NOT_FOUND);
            }

            return new ResponseEntity<>(result, HttpStatus.OK);
        } catch (InterruptedException ie) {
            log.error("data generation failed", ie);
            Thread.currentThread().interrupt();
            return new ResponseEntity<>(ie.getClass().getName()+": "+ie.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        } catch (Exception e) {
            log.error("data generation failed", e);
            return new ResponseEntity<>(e.getClass().getName() + ": " + e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    @Operation(summary = "execute bulk of injects")
    @PostMapping(value = "/bulk", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<BulkInjectResult> bulk(@RequestBody List<String> injectlist,
                                            @Parameter(description = "delimiter testid injectid (default .)") @RequestParam(defaultValue = ".") String delimiter,
                                            @Parameter(description = "execute in parallel (default false)") @RequestParam(defaultValue = "false") boolean parallel,
                                         HttpServletResponse response) throws InterruptedException {

        try {

            BulkInjectResult result = new BulkInjectResult();
            List<String> injectexecutions = new ArrayList<>();

            //set new ID
            result.setBulkid(UUID.randomUUID().toString());

            //do it one-by-one or in parallel
            if (!parallel) {
                injectlist.stream().forEach(injectinput -> injectexecutions.addAll(bulkExec(injectinput, delimiter, result)));
            } else {
                injectlist.parallelStream().forEach(injectinput -> injectexecutions.addAll(bulkExec(injectinput, delimiter, result)));
            }

            result.setInjectexecutions(injectexecutions);
            return new ResponseEntity<>(result, HttpStatus.OK);
        } catch (Exception e) {
            log.error("bulk inject execution failed", e);
            if (e instanceof InterruptedException) Thread.currentThread().interrupt();
            BulkInjectResult result = new BulkInjectResult();
            result.setError(e.getClass().getName()+": "+e.getMessage());
            return new ResponseEntity<>(result, HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    private List<String> bulkExec(String injectinput, String delimiter, BulkInjectResult result) {
        try {
            String[] splitvalues = injectinput.split(Pattern.quote(delimiter));

            //validation
            if (splitvalues.length != 2) {
                return List.of(injectinput + ": invalid - please use testid.injectid or testid.*");            
            }

            //read testid and injectid
            String testid = splitvalues[0];
            String injectid = splitvalues[1];

            //read test from database
            return executeInject(testid, injectid, result);
        } catch (InterruptedException ie) {
            log.error("cannot execute inject", ie);
            Thread.currentThread().interrupt();
            return List.of(ie.getMessage());
        } catch (Exception e) {
            log.error("cannot execute inject", e);
            return List.of(e.getMessage());
        }
    }

    private List<String> executeInject(String testid, String injectid, BulkInjectResult result) throws JsonProcessingException, NotFoundException, InterruptedException, ValidationException {
        List<String> injectexecutions = new ArrayList<>();
        TestCaseDTO test = testManager.getTest(testid);
        if (test != null) {
            for (TestCaseInjectionDTO inject : test.getInjections()) {
                if (inject.getInjectid().equals(injectid) || injectid.equals("*")) {
                    if (inject.isActive()) {
                        // execute inject and add bulkid to checks
                        injectexecutions.add(testid + "." + inject.getInjectid() + ": "
                                + testInjection.executeInject(testid, inject, "bulk-triggered", result.getBulkid(),
                                        adapterResolver.getAdapter(inject.getService().getType())));
                    } else {
                        injectexecutions.add(testid + "." + inject.getInjectid() + ": deactivated");
                    }
                }
            }
        }
        return injectexecutions;
    }

    @Operation(summary = "pause injects and checks")
    @GetMapping(value = "/pause/{value}", produces = MediaType.TEXT_PLAIN_VALUE)
    public ResponseEntity<String> pause(@Parameter(description = "true/false") @PathVariable boolean value,
                                        @Parameter(description = "pause by label (optional)") @RequestParam(defaultValue = "") String byLabel,
                                         HttpServletResponse response) {

        try {

            testManager.pause(value, byLabel);

            return new ResponseEntity<>("pause set "+value + " for label: " + byLabel, HttpStatus.OK);
        } catch (Exception e) {
            log.error("cannot set pause", e);
            return new ResponseEntity<>(e.getClass().getName()+": "+e.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }

    /**
     * create result list from single warning
     * @param warn warning
     * @return List with single entry
     */
    private List<String> createWarning(String warn) {
        List<String> warning = new ArrayList<>();
        warning.add(warn);
        return warning;
    }

}
