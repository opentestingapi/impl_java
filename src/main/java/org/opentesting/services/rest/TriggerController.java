package org.opentesting.services.rest;

import org.opentesting.dto.TestCaseDTO;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.services.adapter.AdapterResolver;
import org.opentesting.services.execution.TestInjection;
import org.opentesting.services.execution.TestManager;
import org.opentesting.services.execution.TestReporting;
import org.opentesting.services.rest.dto.BulkInjectResult;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.regex.Pattern;

@Api(description = "trigger test cases inject")
@RestController
@Slf4j
@RequestMapping("/trigger")
public class TriggerController {

    private final static String PATHCONNECTOR = "/";

    @Autowired
    private TestManager testPlaner;

    @Autowired
    private TestReporting testReporting;

    @Autowired
    private TestInjection testInjection;

    @Autowired
    private AdapterResolver adapterResolver; 

    @ApiOperation(value = "get available triggers")
    @GetMapping(value = "/", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<List<String>> get(HttpServletRequest request, HttpServletResponse response) {

        try {

            String url = request.getRequestURL().toString();
            if (!url.endsWith(PATHCONNECTOR)) {
                url = url + PATHCONNECTOR;
            }

            //read tests from database
            List<TestCaseDTO> tests = testReporting.getOriginalTestCases();
            Collections.sort(tests, (o1, o2) -> o1.getTestid().compareTo(o2.getTestid()));

            //create URLs
            List<String> urls = new ArrayList<>();
            for (TestCaseDTO test : tests) {
                for (TestCaseInjectionDTO inject : test.getInjections()) {
                    if (inject.isActivation()) {
                        urls.add(url+"inject"+PATHCONNECTOR+test.getTestid()+PATHCONNECTOR+inject.getInjectid());
                    }
                }
            }

            if (tests.isEmpty()) return new ResponseEntity<List<String>>(HttpStatus.NOT_FOUND);
            return new ResponseEntity<List<String>>(urls, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading inject URLs failed", e);
            return new ResponseEntity<List<String>>(createWarning(e.getClass().getName()+": "+e.getMessage()), HttpStatus.resolve(500));
        }
    }

    @ApiOperation(value = "execute inject in browser")
    @GetMapping(value = "/inject/{testid}/{injectid}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> inject(@ApiParam(value = "testid ID test case") @PathVariable String testid,
            @ApiParam(value = "inject ID") @PathVariable String injectid,
            HttpServletResponse response) {

        try {

            String result = null;
            TestCaseInjectionDTO injectDto = null;

            //read test from database
            TestCaseDTO test = testReporting.getOriginalTestCase(testid);
            for (TestCaseInjectionDTO inject : test.getInjections()) {
                if (inject.getInjectid().equals(injectid)) {
                    if (inject.isActivation()) {
                        injectDto = inject;
                    } else {
                        result = testid + "." + injectid + ": inject deactivated";
                    }
                }
            }

            //execute inject
            if (injectDto != null) {
                result = testid+"."+injectid+": "+testInjection.executeInject(testid, injectDto, "manually-triggered",
                        "", null, adapterResolver.getAdapter(injectDto.getService()));
            }

            if (result == null) return new ResponseEntity<String>(HttpStatus.NOT_FOUND);
            return new ResponseEntity<String>(result, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading file for test case failed", e);
            return new ResponseEntity<String>(e.getClass().getName()+": "+e.getMessage(), HttpStatus.resolve(500));
        }
    }

    @ApiOperation(value = "execute bulk of injects")
    @PostMapping(value = "/bulk/", consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<BulkInjectResult> bulk(@RequestBody List<String> injectlist,
                                           @ApiParam(value = "delimiter testid injectid (default .)") @RequestParam(defaultValue = ".") String delimiter,
                                         HttpServletResponse response) {

        try {

            BulkInjectResult result = new BulkInjectResult();
            List<String> injectexecutions = new ArrayList<>();

            //set new ID
            result.setBulkid(UUID.randomUUID().toString());

            //do it one-by-one to not overload the server
            for (String injectinput : injectlist) {

                String[] splitvalues = injectinput.split(Pattern.quote(delimiter));

                //validation
                if (splitvalues.length != 2) {
                    injectexecutions.add(injectinput + ": invalid - please use testid.injectid or testid.*");
                    continue;
                }

                //read testid and injectid
                String testid = splitvalues[0];
                String injectid = splitvalues[1];

                //read test from database
                TestCaseDTO test = testReporting.getOriginalTestCase(testid);
                if (test != null) {
                    for (TestCaseInjectionDTO inject : test.getInjections()) {
                        if (inject.getInjectid().equals(injectid) || injectid.equals("*")) {
                            if (inject.isActivation()) {
                                //execute inject and add bulkid to checks
                                injectexecutions.add(testid + "." + inject.getInjectid() + ": " + testInjection.executeInject(testid, inject,
                                        "bulk-triggered", result.getBulkid(), null, adapterResolver.getAdapter(inject.getService())));
                            } else {
                                injectexecutions.add(testid + "." + inject.getInjectid() + ": deactivated");
                            }
                        }
                    }
                }
            }

            result.setInjectexecutions(injectexecutions);
            return new ResponseEntity<BulkInjectResult>(result, HttpStatus.OK);
        } catch (Exception e) {
            log.error("loading file for test case failed", e);
            BulkInjectResult result = new BulkInjectResult();
            result.setError(e.getClass().getName()+": "+e.getMessage());
            return new ResponseEntity<BulkInjectResult>(result, HttpStatus.resolve(500));
        }
    }

    @ApiOperation(value = "pause injects and checks")
    @GetMapping(value = "/pause/{value}", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<String> pause(@ApiParam(value = "true/false") @PathVariable boolean value,
                                        @ApiParam(value = "pause by label (optional)") @RequestParam(defaultValue = "") String byLabel,
                                         HttpServletResponse response) {

        try {

            testPlaner.pause(value, byLabel);

            return new ResponseEntity<String>("pause set "+value + " for label: " + byLabel, HttpStatus.OK);
        } catch (Exception e) {
            log.error("cannot set pause", e);
            return new ResponseEntity<String>(e.getClass().getName()+": "+e.getMessage(), HttpStatus.resolve(500));
        }
    }

    /**
     * create result list from single warning
     * @param warn warning
     * @return List with single entry
     */
    private List<String> createWarning(String warn) {
        List<String> warning = new ArrayList<>();
        warning.add(warn);
        return warning;
    }

}