package org.opentesting.persistence;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.time.LocalDateTime;
import java.util.List;

import javax.annotation.PostConstruct;

import org.opentesting.util.OpenTestingConversion;
import org.opentesting.dto.TestCaseInjectionDTO;
import org.opentesting.dto.TestCaseRandomGeneratorDTO;
import org.opentesting.util.LogExecutionTime;
import com.fasterxml.jackson.core.JsonProcessingException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.support.DataAccessUtils;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class TestCaseInjectionRepository {

    private static final String TABLENAME = "testcaseinject";
    private static final String[] SQLS = {"create table if not exists "+TABLENAME+" (testid VARCHAR(1000) NOT NULL)"
        ,"alter table "+TABLENAME+" add if not exists injectid VARCHAR(1000)" 
        ,"alter table "+TABLENAME+" add if not exists timerid VARCHAR(1000)" //required to "disable" outdated timers - because they will stay active
        ,"alter table "+TABLENAME+" add if not exists activation boolean"
        ,"alter table "+TABLENAME+" add if not exists triggercron VARCHAR(1000)" //# concatenated
        ,"alter table "+TABLENAME+" add if not exists service VARCHAR(100)"
        ,"alter table "+TABLENAME+" add if not exists sourcefile VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists connectstring VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists connectuser VARCHAR(100)"
        ,"alter table "+TABLENAME+" add if not exists connectpassword VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists checks VARCHAR(1000)" //# concatenated
        ,"alter table "+TABLENAME+" add if not exists randomgenerator text"
        ,"alter table "+TABLENAME+" add if not exists timetolive VARCHAR(100)"
        ,"alter table "+TABLENAME+" add if not exists createts timestamp"       
        ,"alter table "+TABLENAME+" add if not exists serviceparam VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists jwtuser VARCHAR(100)"
        ,"alter table "+TABLENAME+" add if not exists jwtpassword VARCHAR(1000)"
    };

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private OpenTestingConversion e2EConversion;

    @PostConstruct
    @LogExecutionTime
    public void prepareDB() {
        for (String sql : SQLS) {
            try {
                log.info("execute: "+sql);
                jdbcTemplate.execute(sql);
            } catch (Exception e) {
                log.warn("warning preparing internal database", e);
            }
        }
    }

    @LogExecutionTime
    public void insert(String testid, List<TestCaseInjectionDTO> injects) {
        deleteByTestId(testid);

        String sql = "insert into "+TABLENAME+" (testid, injectid, timerid, activation, triggercron, service, "+
            "serviceparam, sourcefile, connectstring, connectuser, connectpassword, jwtuser, jwtpassword, checks, "+
            "randomgenerator, timetolive, createts) "+
            "VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)";
        for (TestCaseInjectionDTO inject : injects) {

            //build createts, but do not set in object
            LocalDateTime createts = LocalDateTime.now();
            if (inject.getCreatets() != null) createts = inject.getCreatets();

            //random generator
            String randomgenerator = null;
            try {
                randomgenerator = e2EConversion.object2json(inject.getRandomgenerator());
            } catch (JsonProcessingException e) {
                log.error("cannot create random generator string for "+inject.getRandomgenerator(), e);
            }

            jdbcTemplate.update(sql, testid, inject.getInjectid(), inject.getTimerid(), inject.isActivation(), OpenTestingConversion.toStringDatabase(inject.getTriggercron()),
                    inject.getService(), inject.getServiceparam(), inject.getSourcefile(), inject.getConnectstring(), inject.getConnectuser(), inject.getConnectpassword(),
                    inject.getJwtuser(), inject.getJwtpassword(), OpenTestingConversion.toStringDatabase(inject.getChecks()), randomgenerator, inject.getTimetolive(), createts);
        }
    }

    @LogExecutionTime
    public void deleteByTestId(String testid) {
        String sql = "delete from "+TABLENAME+" where testid = ?";
        jdbcTemplate.update(sql, testid);
    }

    @LogExecutionTime
    public List<TestCaseInjectionDTO> select(String testid) {
        String sql = "select * from "+TABLENAME+" where testid = ?";      
        return jdbcTemplate.query(sql, (rs, rowNum) -> 
            getFromRS(rs), testid);
    }

    @LogExecutionTime
    public TestCaseInjectionDTO selectByIdAndTimer(String testid, String timerid) {
        String sql = "select * from "+TABLENAME+" where testid = ? and timerid = ?";
        //because of old timers we have to handle 0 rows result
        return DataAccessUtils.singleResult(jdbcTemplate.query(sql, (rs, rowNum) -> getFromRS(rs), testid, timerid));
    }

    private TestCaseInjectionDTO getFromRS(ResultSet rs) throws SQLException {        
        TestCaseRandomGeneratorDTO randomgenerator = null;
        String randomgenstr = "";
        try {  
            randomgenstr = rs.getString("randomgenerator");  
            if (randomgenstr != null) {                
                randomgenerator = e2EConversion.json2object(randomgenstr, TestCaseRandomGeneratorDTO.class);
            }
        } catch (JsonProcessingException e) {
            log.error("cannot read random data for "+rs.getString("testid")+" "+rs.getString("checkid")+" "
                +OpenTestingConversion.toLDT(rs.getTimestamp("startts")), e);
        }
        //without random data
        return new TestCaseInjectionDTO(rs.getString("injectid"), OpenTestingConversion.toListFromDatabase(rs.getString("triggercron")),
                OpenTestingConversion.toBooleanFromDatabase(rs, "activation"), rs.getString("service"), rs.getString("serviceparam"),
                rs.getString("sourcefile"), rs.getString("connectstring"), rs.getString("connectuser"),
                rs.getString("connectpassword"), rs.getString("jwtuser"), rs.getString("jwtpassword"),
                rs.getString("timetolive"), OpenTestingConversion.toListFromDatabase(rs.getString("checks")),
                randomgenerator, rs.getString("timerid"),
                OpenTestingConversion.toLDT(rs.getTimestamp("createts"))
            );   
    }
    
}
