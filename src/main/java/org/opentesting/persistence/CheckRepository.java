package org.opentesting.persistence;

import java.sql.ResultSet;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import javax.annotation.PostConstruct;

import com.fasterxml.jackson.core.JsonProcessingException;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.dto.migration.TestCaseCheckDTOMigration;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.support.DataAccessUtils;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class CheckRepository extends AbstractRepository {

    private static final String TABLENAME = "checkstore";
    private static final String[] SQLS = {CREATETABLE+TABLENAME+DEFAULTCOLUMN
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"checkid VARCHAR(1000)"
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"instanceid VARCHAR(1000)"
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"version VARCHAR(100)"
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"value text"
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"insertts timestamp"
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"opentype VARCHAR(1000)"
    };     

    @Autowired
    private OpenTestingConversion openTestingConversion;

    @Autowired
    private TestCaseCheckDTOMigration testCaseCheckDTOMigration;

    @PostConstruct
    @LogExecutionTime
    public void prepareDB() {
        prepareDBinternal(SQLS);       
    }

    @LogExecutionTime
    public void insert(String testid, TestCaseCheckDTO check) throws DataAccessException, JsonProcessingException {

        //required to get test case reference when loading checks only
        check.setTestid(testid);

        jdbcTemplate.update(INSERTINTO+TABLENAME+" (testid, checkid, instanceid, version, value, insertts, opentype) VALUES (?, ?, ?, ?, ?, ?, ?)", 
            testid, check.getCheckid(), check.getInstanceid(), check.getVersion(), openTestingConversion.object2json(check), LocalDateTime.now(), 
            check.getService().getType());
    }

    @LogExecutionTime
    public void delete(String testid, String checkid) {
        jdbcTemplate.update(DELETEFROM+TABLENAME+" where testid = ? and checkid = ?", testid, checkid);
    }

    @LogExecutionTime
    public void deleteByTestId(String testid) {
        jdbcTemplate.update(DELETEFROM+TABLENAME+" where testid = ?", testid);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> select(String testid) throws DataAccessException {
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONVALUE+TABLENAME+" where testid = ?", 
            (rs, rowNum) -> fromRS(rs), testid);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectLatest(String testid, int max) throws DataAccessException {
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONVALUE+TABLENAME+" where testid = ? order by insertts desc limit ?", 
            (rs, rowNum) -> fromRS(rs), testid, max);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> select(String testid, String checkid) throws DataAccessException {
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONVALUE+TABLENAME+" where testid = ? and checkid = ?", 
            (rs, rowNum) -> fromRS(rs), testid, checkid);
        return OpenTestingConversion.filterNull(res);
    }

    private TestCaseCheckDTO fromRS(ResultSet rs) {
        try {
            return testCaseCheckDTOMigration.toLatest(rs.getString("version"), rs.getString("value"));
        } catch (Exception e) {
            log.error("cannot read/migrate TestCaseCheckDTO", e);
            return null;
        }
    }  
    
    @LogExecutionTime
    public void deleteOlderThan(LocalDateTime maxAge) {
        jdbcTemplate.update(DELETEFROM+TABLENAME+" where insertts < ?", maxAge);
    }

    @LogExecutionTime
    public TestCaseCheckDTO selectByInstanceId(String instanceid) throws NotFoundException {
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONVALUE+TABLENAME+" where instanceid = ?", 
            (rs, rowNum) -> fromRS(rs), instanceid);
        if (res == null || res.isEmpty()) throw new NotFoundException(instanceid);
        return DataAccessUtils.singleResult(res);
    }

    @LogExecutionTime
    public void updateByInstanceId(TestCaseCheckDTO check) throws DataAccessException, JsonProcessingException {     

        jdbcTemplate.update("update "+TABLENAME+" set value = ? where instanceid = ?", 
            openTestingConversion.object2json(check), check.getInstanceid());

        //remove open flag?
        if (check.getSuccess() != null) {
            jdbcTemplate.update("update "+TABLENAME+" set opentype = null where instanceid = ?", check.getInstanceid());
        }
    }

    @LogExecutionTime
    public void updateOpenByInstanceId(TestCaseCheckDTO check) throws DataAccessException, JsonProcessingException {
        jdbcTemplate.update("update "+TABLENAME+" set value = ? where instanceid = ? and opentype != null",
                openTestingConversion.object2json(check), check.getInstanceid());
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectByTestAndOpentype(String testid, String opentype) throws DataAccessException {
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONVALUE+TABLENAME+" where testid = ? and opentype = ?", 
            (rs, rowNum) -> fromRS(rs), testid, opentype);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectByOpentype(String opentype) throws DataAccessException {
        if (opentype == null || opentype.isEmpty()) return new ArrayList<>();
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONVALUE+TABLENAME+" where opentype = ?", 
            (rs, rowNum) -> fromRS(rs), opentype);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public void updateRandomData(List<String> checkinstances, TestCaseRandomDataDTO randomdata) {
        checkinstances.parallelStream().forEach(checkinstance -> 
            {
                try {
                    TestCaseCheckDTO check = selectByInstanceId(checkinstance);
                    check.setRandomdata(randomdata);
                    updateOpenByInstanceId(check);
                } catch (Exception e) {
                    log.error("cannot update check instance: "+checkinstance, e);
                }
            }
        );
    }
    
}