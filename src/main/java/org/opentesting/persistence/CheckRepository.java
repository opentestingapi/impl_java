package org.opentesting.persistence;

import java.sql.ResultSet;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.List;

import jakarta.annotation.PostConstruct;

import com.fasterxml.jackson.core.JsonProcessingException;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.dto.migration.TestCaseCheckDTOMigration;
import org.opentesting.util.ApplicationContextProvider;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.OpenTestingConversion;
import org.opentesting.util.exceptions.NotFoundException;
import org.springframework.dao.DataAccessException;
import org.springframework.dao.support.DataAccessUtils;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class CheckRepository extends AbstractRepository {

    private static final String SELECTVERSIONDATAEXPIRED = "select version, data, expired from "; 

    private static final String TABLENAME = "checkstore";    
    private static final String[] SQLS = {CREATETABLE+TABLENAME+DEFAULTCOLUMN
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"checkid VARCHAR(1000)"
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"instanceid VARCHAR(1000)"
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"version VARCHAR(100)"
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"data text"
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"insertts timestamp"
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"opentype VARCHAR(1000)"
        ,ALTERTABLE+TABLENAME+ADDIFNOTEXISTS+"expired timestamp"
    };

    private OpenTestingConversion openTestingConversion;

    private TestCaseCheckDTOMigration testCaseCheckDTOMigration;

    public CheckRepository(ApplicationContextProvider applicationContextProvider) {
        super(applicationContextProvider);
        openTestingConversion = applicationContextProvider.getBean(OpenTestingConversion.class);
        testCaseCheckDTOMigration = applicationContextProvider.getBean(TestCaseCheckDTOMigration.class);
    }

    @PostConstruct
    @LogExecutionTime
    public void prepareDB() {
        prepareDBinternal(SQLS);       
    }

    @LogExecutionTime
    public void insert(String testid, TestCaseCheckDTO check) throws DataAccessException, JsonProcessingException {

        //required to get test case reference when loading checks only
        check.setTestid(testid);

        jdbcTemplate.update(INSERTINTO+TABLENAME+" (testid, checkid, instanceid, version, data, insertts, opentype) VALUES (?, ?, ?, ?, ?, ?, ?)", 
            testid, check.getCheckid(), check.getInstanceid(), check.getVersion(), openTestingConversion.object2json(check), LocalDateTime.now(), 
            check.getService().getType());
    }

    @LogExecutionTime
    public void delete(String testid, String checkid) {
        jdbcTemplate.update(DELETEFROM+TABLENAME+" where testid = ? and checkid = ?", testid, checkid);
    }

    @LogExecutionTime
    public void deleteByTestId(String testid) {
        jdbcTemplate.update(DELETEFROM+TABLENAME+" where testid = ?", testid);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> select(String testid) throws DataAccessException {
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONDATAEXPIRED+TABLENAME+" where testid = ?", 
            (rs, rowNum) -> fromRS(rs), testid);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectLatest(String testid, int max) throws DataAccessException {
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONDATAEXPIRED+TABLENAME+" where testid = ? order by insertts desc limit ?", 
            (rs, rowNum) -> fromRS(rs), testid, max);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> select(String testid, String checkid) throws DataAccessException {
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONDATAEXPIRED+TABLENAME+" where testid = ? and checkid = ?", 
            (rs, rowNum) -> fromRS(rs), testid, checkid);
        return OpenTestingConversion.filterNull(res);
    }

    private TestCaseCheckDTO fromRS(ResultSet rs) {
        try {
            TestCaseCheckDTO res = testCaseCheckDTOMigration.toLatest(rs.getString("version"), rs.getString("data"));

            //expiry job will not change the json as this might be in parallel to normal checks
            Timestamp expired = rs.getTimestamp("expired");
            if (res.getExpiredts() == null && expired != null) {
                res.setExpiredts(expired.toLocalDateTime());
            }

            return res;
        } catch (Exception e) {
            log.error("cannot read/migrate TestCaseCheckDTO", e);
            return null;
        }
    }
    
    @LogExecutionTime
    public void deleteOlderThan(LocalDateTime maxAge) {
        jdbcTemplate.update(DELETEFROM+TABLENAME+" where insertts < ?", maxAge);
    }

    @LogExecutionTime
    public TestCaseCheckDTO selectByInstanceId(String instanceid) throws NotFoundException {
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONDATAEXPIRED+TABLENAME+" where instanceid = ?", 
            (rs, rowNum) -> fromRS(rs), instanceid);
        if (res.isEmpty()) throw new NotFoundException(instanceid);
        return DataAccessUtils.singleResult(res);
    }

    /**
     * only one process should be able to finalize the check because of subsequent injects or checks and possible parallel check executions (for example kafka message)
     * @param check check
     * @return update successful
     * @throws DataAccessException
     * @throws JsonProcessingException
     */
    @LogExecutionTime
    public boolean updateByInstanceId(TestCaseCheckDTO check) throws DataAccessException, JsonProcessingException {     

        //remove open flag?
        int result = 0;
        if (check.getSuccess() != null) {
            result = jdbcTemplate.update(UPDATE+TABLENAME+" set data = ?, opentype = null where instanceid = ? and opentype is not null", 
                        openTestingConversion.object2json(check), check.getInstanceid());
        } else {
            result = jdbcTemplate.update(UPDATE+TABLENAME+" set data = ? where instanceid = ? and opentype is not null", 
                        openTestingConversion.object2json(check), check.getInstanceid());
        }

        return result > 0;
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectByTestAndOpentype(String testid, String opentype) throws DataAccessException {
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONDATAEXPIRED+TABLENAME+" where testid = ? and opentype = ?", 
            (rs, rowNum) -> fromRS(rs), testid, opentype);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectByOpentypeAndUnexpired(String service) {
        List<TestCaseCheckDTO> res = jdbcTemplate.query(
            SELECTVERSIONDATAEXPIRED+TABLENAME+" where expired is null and opentype = ?", 
            (rs, rowNum) -> fromRS(rs), service);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public void updateRandomData(List<String> checkinstances, TestCaseRandomDataDTO randomdata) {
        checkinstances.parallelStream().forEach(checkinstance -> 
            {
                try {
                    TestCaseCheckDTO check = selectByInstanceId(checkinstance);
                    check.setRandomdata(randomdata);
                    updateByInstanceId(check);
                } catch (Exception e) {
                    log.error("cannot update check instance: "+checkinstance, e);
                }
            }
        );
    }

    @LogExecutionTime
    public void expire(TestCaseCheckDTO check) {
        jdbcTemplate.update(UPDATE+TABLENAME+" set expired = ? where instanceid = ?", 
            LocalDateTime.now(), check.getInstanceid());
    }    
    
}