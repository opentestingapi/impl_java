package org.opentesting.persistence;

import java.sql.ResultSet;
import java.time.LocalDateTime;
import java.util.List;

import javax.annotation.PostConstruct;

import com.fasterxml.jackson.core.JsonProcessingException;

import org.opentesting.dto.TestCaseCheckDTO;
import org.opentesting.dto.TestCaseRandomDataDTO;
import org.opentesting.dto.migration.TestCaseCheckDTOMigration;
import org.opentesting.util.LogExecutionTime;
import org.opentesting.util.OpenTestingConversion;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.DataAccessException;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

@Component
@Slf4j
public class CheckRepository {

    private static final String TABLENAME = "checkstore";
    private static final String[] SQLS = {"create table if not exists "+TABLENAME+" (testid VARCHAR(1000) NOT NULL)"
        ,"alter table "+TABLENAME+" add if not exists checkid VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists checkinstanceid VARCHAR(1000)"
        ,"alter table "+TABLENAME+" add if not exists version VARCHAR(100)"
        ,"alter table "+TABLENAME+" add if not exists value text"
        ,"alter table "+TABLENAME+" add if not exists insertts timestamp"
        ,"alter table "+TABLENAME+" add if not exists opentype VARCHAR(1000)"
    };

    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Autowired
    private OpenTestingConversion openTestingConversion;

    @Autowired
    private TestCaseCheckDTOMigration testCaseCheckDTOMigration;

    @PostConstruct
    @LogExecutionTime
    public void prepareDB() {
        for (String sql : SQLS) {
            try {
                log.info("execute: "+sql);
                jdbcTemplate.execute(sql);
            } catch (Exception e) {
                log.warn("warning preparing internal database", e);
            }
        }
    }

    @LogExecutionTime
    public void insert(String testid, TestCaseCheckDTO check) throws DataAccessException, JsonProcessingException {

        //required to get test case reference when loading checks only
        check.setCheckinstancetestid(testid);

        String sql = "insert into "+TABLENAME+" (testid, checkid, checkinstanceid, version, value, insertts, opentype) VALUES (?, ?, ?, ?, ?, ?, ?)";
        jdbcTemplate.update(sql, testid, check.getCheckid(), check.getCheckinstanceid(), 
            check.getVersion(), openTestingConversion.object2json(check), LocalDateTime.now(), check.getService().getType());
    }

    @LogExecutionTime
    public void delete(String testid, String checkid) {
        String sql = "delete from "+TABLENAME+" where testid = ? and checkid = ?";
        jdbcTemplate.update(sql, testid, checkid);
    }

    @LogExecutionTime
    public void deleteByTestId(String testid) {
        String sql = "delete from "+TABLENAME+" where testid = ?";
        jdbcTemplate.update(sql, testid);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> select(String testid) throws DataAccessException, JsonProcessingException {
        String sql = "select version, value from "+TABLENAME+" where testid = ?";
        List<TestCaseCheckDTO> res = jdbcTemplate.query(sql, (rs, rowNum) -> fromRS(rs), testid);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectLatest(String testid, int max) throws DataAccessException, JsonProcessingException {
        String sql = "select version, value from "+TABLENAME+" where testid = ? order by insertts desc limit ?";
        List<TestCaseCheckDTO> res = jdbcTemplate.query(sql, (rs, rowNum) -> fromRS(rs), testid, max);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> select(String testid, String checkid) throws DataAccessException, JsonProcessingException {
        String sql = "select version, value from "+TABLENAME+" where testid = ? and checkid = ?";
        List<TestCaseCheckDTO> res = jdbcTemplate.query(sql, (rs, rowNum) -> fromRS(rs), testid, checkid);
        return OpenTestingConversion.filterNull(res);
    }

    private TestCaseCheckDTO fromRS(ResultSet rs) {
        try {
            return testCaseCheckDTOMigration.toLatest(rs.getString("version"), rs.getString("value"));
        } catch (Exception e) {
            log.error("cannot read/migrate TestCaseCheckDTO", e);
            return null;
        }
    }  
    
    @LogExecutionTime
    public void deleteOlderThan(LocalDateTime maxAge) {
        String sql = "delete from "+TABLENAME+" where insertts < ?";
        jdbcTemplate.update(sql, maxAge);
    }

    @LogExecutionTime
    public TestCaseCheckDTO selectByInstanceId(String instanceid) {
        String sql = "select version, value from "+TABLENAME+" where checkinstanceid = ?";
        List<TestCaseCheckDTO> res = jdbcTemplate.query(sql, (rs, rowNum) -> fromRS(rs), instanceid);
        return res.get(0);
    }

    @LogExecutionTime
    public void updateByInstanceId(TestCaseCheckDTO check) throws DataAccessException, JsonProcessingException {     

        String sql = "update "+TABLENAME+" set value = ? where checkinstanceid = ?";
        jdbcTemplate.update(sql, openTestingConversion.object2json(check), check.getCheckinstanceid());

        //remove open flag?
        if (check.getSuccess() != null) {
            sql = "update "+TABLENAME+" set opentype = null where checkinstanceid = ?";
            jdbcTemplate.update(sql, check.getCheckinstanceid());
        }
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectByTestAndOpentype(String testid, String opentype) throws DataAccessException, JsonProcessingException {
        String sql = "select version, value from "+TABLENAME+" where testid = ? and opentype = ?";
        List<TestCaseCheckDTO> res = jdbcTemplate.query(sql, (rs, rowNum) -> fromRS(rs), testid, opentype);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public List<TestCaseCheckDTO> selectByOpentype(String opentype) throws DataAccessException, JsonProcessingException {
        String sql = "select version, value from "+TABLENAME+" where opentype = ?";
        List<TestCaseCheckDTO> res = jdbcTemplate.query(sql, (rs, rowNum) -> fromRS(rs), opentype);
        return OpenTestingConversion.filterNull(res);
    }

    @LogExecutionTime
    public void updateRandomData(List<String> checkinstances, TestCaseRandomDataDTO randomdata) {
        checkinstances.parallelStream().forEach(checkinstance -> 
            {
                try {
                    TestCaseCheckDTO check = selectByInstanceId(checkinstance);
                    check.setRandomdata(randomdata);
                    updateByInstanceId(check);
                } catch (Exception e) {
                    log.error("cannot update check instance: "+checkinstance, e);
                }
            }
        );
    }
    
}