package org.opentesting.util;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.util.*;
import java.util.stream.Collectors;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import org.opentesting.dto.CheckResultDTO;
import org.opentesting.util.exceptions.ValidationException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

@Component
public class OpenTestingConversion {

    public static final String CONCATENATOR = "#"; 
    private static final String DOUBLECONCATENATOR = CONCATENATOR+CONCATENATOR;

    @Autowired
    private ObjectMapper objectMapper;

    public static String replaceNull(String input) {
        if (input == null) return "";
        return input;
    }

    public static String toStringDatabase(List<String> input) {
        //##a##b##c## --> used for database search with #a#%#b#
        return DOUBLECONCATENATOR+toString(input, DOUBLECONCATENATOR)+DOUBLECONCATENATOR;
    }

    public static List<String> toListFromDatabase(String input) {
        //##a##b##c## --> used for database search with #a#%#b#             
        return toList(input, DOUBLECONCATENATOR);
    }

    public static Boolean toBooleanFromDatabase(ResultSet rs, String column) throws SQLException {
        Boolean result = rs.getBoolean(column);
        if (rs.wasNull()) result = null;
        return result;
    }

    public static String toString(List<String> input, String myconcatenator) {
        if (input == null) return "";    
        return input.stream().map(n -> n)
            .collect(Collectors.joining(myconcatenator));
    }

    public static List<String> toList(String input, String myconcatenator) {
        List<String> result = new ArrayList<>();
        if (input == null) return result;
        for (String in : input.split(myconcatenator)) {
            if (in.length() > 0) result.add(in);
        }      
        return result;
    }

    public static long toSeconds(String input) throws ValidationException {
        if (input.contains("d")) {
            return toNumber(input) * 60 * 60 * 24;
        } else if (input.contains("h")) {
            return toNumber(input) * 60 * 60;
        } else if (input.contains("m")) { 
            return toNumber(input) * 60;
        } else if (input.contains("s")) { 
            return toNumber(input);
        } else {
            throw new ValidationException("unknown time format: "+input);
        }
    }

    public static long toNumber(String input) {
        return Long.parseLong(input.replaceAll("[^\\d.-]", ""));
    }

    public static LocalDateTime toLDT(Timestamp ts) {
        if (ts != null) return ts.toLocalDateTime();
        return null;
    }

    public static String toString(InputStream is) {
        return new BufferedReader(
            new InputStreamReader(is, StandardCharsets.UTF_8))
            .lines()
            .collect(Collectors.joining("\n"));
    }

    public static String toString(Boolean input) {
        if (input == null) return "n/a";
        if (input) return "true";
        return "false";
    }

    public <T> T json2object(String json, Class<T> c) throws JsonProcessingException {
        return objectMapper.readValue(json, c);
    }

    public <T> List<T> json2objects(List<String> jsons, Class<T> c) throws JsonProcessingException {
        List<T> res = new ArrayList<>();
        for (String json : jsons) res.add(objectMapper.readValue(json, c));
        return res;
    }

    public <T> T json2object(InputStream json, Class<T> c) throws IOException {
        return objectMapper.readValue(json, c);
    }

    public String object2json(Object obj) throws JsonProcessingException {
        return objectMapper.writeValueAsString(obj);
    }

    public <T> T json2object(String json, TypeReference<T> ref) throws JsonProcessingException {
        return objectMapper.readValue(json, ref);
    }

    public Map<String, Object> json2Map(String input) throws JsonProcessingException {
        JsonNode node = objectMapper.readTree(input);
        return objectMapper.convertValue(node, new TypeReference<Map<String, Object>>(){});
    }

    public static CheckResultDTO list2CheckResult(List<Boolean> input) {
        long success = 0;
        long failed = 0;
        long without = 0;
        for (Boolean res : input) {
            if (res == null) {
                without++;
            } else {
                if (res) success++;
                if (!res) failed++;  
            }          
        }
        return new CheckResultDTO(success, failed, without);
    }    

    public static <T> List<T> filterNull(List<T> input) {
        List<T> res = new ArrayList<>();
        for (T a : input) {
            if (a != null) res.add(a);
        }
        return res;
    }
    
}
