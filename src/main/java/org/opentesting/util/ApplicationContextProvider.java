package org.opentesting.util;

import java.lang.reflect.Constructor;
import java.util.ArrayList;
import java.util.List;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

import lombok.extern.slf4j.Slf4j;

/**
 * we will use application context, as adapters should not know all of our beans...
 */
@Component
@Slf4j
public class ApplicationContextProvider implements ApplicationContextAware {

    private ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    } 

    /**
     * get application context
     */
    public ApplicationContext getContext() {
        return applicationContext;
    }
    
    /**
     * get bean from cintext
     * @param <T> expected object class
     * @param clazz expected object class
     * @return bean
     */
    public <T> T getBean(Class<T> clazz) {
        if (applicationContext == null) {
            log.warn("force creating: "+clazz.getName());
            return createBean(clazz);
        } else {
            return applicationContext.getBean(clazz);
        }
    }

    /**
     * get beans from context
     * @param <T> expected object class
     * @param clazz expected object class
     * @return bean list
     */
    @SuppressWarnings("unchecked")
    public <T> List<T> getBeansForType(Class<T> clazz) {
        if (applicationContext == null) {
            log.warn("no context - returning empty bean list");
            return new ArrayList<>();
        } else {
            List<T> res = new ArrayList<>();
            for (String c : applicationContext.getBeanNamesForType(clazz)) {
                res.add((T)applicationContext.getBean(c));
            }
            return res;
        }
    }

    /**
     * create bean with ApplicationContextProvider or empty constructor
     * @param <T> class
     * @param clazz class
     * @return bean
     */
    @SuppressWarnings("unchecked")
    private <T> T createBean(Class<T> clazz) {
        try {
            Constructor<?> ctor = getConstructur(clazz, this.getClass());
            if (ctor != null) return (T) ctor.newInstance(this);
            ctor = getConstructur(clazz);
            if (ctor != null) return (T) ctor.newInstance();
            return null;
        } catch (Exception e) {
            log.error("cannot create instance using constructor", e);
            return null;
        }
    }

    /**
     * get available constructor or null
     * @param clazz class
     * @param parameter parameters
     * @return constructor
     */
    private Constructor<?> getConstructur(Class<?> clazz, Class<?>... parameter) {
        try {
            return clazz.getConstructor(parameter);
        } catch (NoSuchMethodException e) {
            log.info("missing constructor for "+clazz.getName()+" - "+parameter);
            return null;
        }
    }
    
}