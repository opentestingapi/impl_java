package org.opentesting.systemtest.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.opentesting.common.Sleeper;
import org.opentesting.util.MappingHelper;
import org.testcontainers.shaded.com.google.common.io.Resources;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

/**
 * this class will wrap the test case execution from definition
 */
@Slf4j
public abstract class OpenTestingApiTester {

    private final int SLEEPTIMEMS = 5000;

    private ObjectMapper objectMapper = new ObjectMapper();

    private HttpClient client = HttpClient.newBuilder().build();

    private static String opentestingurl;    

    //reporting
    @Getter
    private static int summary_all = 0;
    @Getter
    private static int summary_success = 0;
    @Getter
    private static int summary_failed = 0;
    @Getter
    private static boolean summary_mandatorySuccess = true;
    @Getter
    private static boolean summary_allSuccess = true;

    @Getter
    @Setter
    public class OTATestResult {
        String testName;
        String checkName;
        String Description;
        Boolean result;
    }
    // Test -> [Check/Description/Result]
    @Getter
    private static List<OTATestResult> testResults = new ArrayList<>();

    /**
     * initialize your environment
     */
    protected static void init() {     
        opentestingurl = "http://localhost:50000/";
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(String testfile, String folderwithfiles, List<String> injects) throws IOException, InterruptedException, URISyntaxException {
        return test(testfile, folderwithfiles, injects, true);
    }

    /**
     * a default configuration
     *
     * @param folderWithFiles
     * @return
     * @throws IOException
     * @throws InterruptedException
     * @throws URISyntaxException
     */
    public boolean testDefault(String folderWithFiles) throws IOException, InterruptedException, URISyntaxException {
        String testFile = folderWithFiles +"/test.json"; // DEFAULT

        String load = "";

        ClassLoader classLoader = OpenTestingApiTester.class.getClassLoader();
        if(classLoader.getResource(testFile) != null) {
            // test.json
            load = Resources.toString(Resources.getResource(testFile), StandardCharsets.UTF_8);
        } else {
            // test.yml
            testFile = folderWithFiles + "/test.yml";
            String resourceYML = Resources.toString(Resources.getResource(testFile), StandardCharsets.UTF_8);
            load = MappingHelper.jsonOrYmlToJson(resourceYML);
        }

        JsonNode testCase = objectMapper.readTree(load);

        JsonNode id = testCase.findValue("id");
        List<String> injects = new ArrayList<>();

        //only the first found one
        for (JsonNode inject : testCase.findValues("injectid"))
            if (injects.isEmpty()) injects.add(id.textValue() + "." + inject.textValue());

        return test(testFile, folderWithFiles, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(String testfile, String folderwithfiles, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException, URISyntaxException {

        //create url list
        List<URL> urls = new ArrayList<>();
        URL url = getClass().getClassLoader().getResource(folderwithfiles);
        String path = url.getPath();
        for (File f : new File(path).listFiles()) {
            URL e = f.toURI().toURL();
            urls.add(e);
        }

        return test(getClass().getClassLoader().getResource(testfile), urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param files relative path required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(String testfile, List<String> files, List<String> injects) throws IOException, InterruptedException, URISyntaxException {
        return test(testfile, files, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param files relative path required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(String testfile, List<String> files, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException, URISyntaxException {

        //create url list
        List<URL> urls = new ArrayList<>();
        for (String f : files) {
            urls.add(getClass().getClassLoader().getResource(f));
        }

        return test(getClass().getClassLoader().getResource(testfile), urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(URL testfile, URL folderwithfiles, List<String> injects) throws IOException, InterruptedException, URISyntaxException {
        return test(testfile, folderwithfiles, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(URL testfile, URL folderwithfiles, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException, URISyntaxException {

        //create url list
        List<URL> urls = new ArrayList<>();
        String path = folderwithfiles.getPath();
        for (File f : new File(path).listFiles()) {
            urls.add(f.toURI().toURL());
        }

        return test(testfile, urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile URL testfile
     * @param files URL required files
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(URL testfile, List<URL> files, List<String> injects) throws IOException, InterruptedException, URISyntaxException {
        return test(testfile, files, injects, true);
    }

   /**
     * execute a test case
     *
     * @param testfile URL testfile
     * @param files URL required files
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
 * @throws URISyntaxException
     */
    public boolean test(URL testfile, List<URL> files, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException, URISyntaxException {

        //read test case
        String testcase = this.getResourceContent(testfile);
        testcase = MappingHelper.jsonOrYmlToJson(testcase);

        //read attributes
        JsonNode testcasemap = objectMapper.readTree(testcase);
        String id = testcasemap.findValue("id").textValue();

        // upload test case files
        HttpRequest request;
        HttpResponse<String> response;
        for (URL file : files) {
            request = HttpRequest.newBuilder()
                    .POST(HttpRequest.BodyPublishers.ofString(getResourceContent(file)))                    
                    .uri(URI.create(opentestingurl + "upload/file/"+id+"/"+Paths.get(file.getPath()).getFileName().toString()))
                    .header("Content-Type", "application/json")                
                    .build();
            response = client.send(request, HttpResponse.BodyHandlers.ofString());
            log.debug(file.getFile()+ ": " + response.body());
        }

        // upload test case
        request = HttpRequest.newBuilder()
                .POST(HttpRequest.BodyPublishers.ofString(testcase))
                .uri(URI.create(opentestingurl + "upload/test"))
                .header("Content-Type", "application/json")
                .build();
        response = client.send(request, HttpResponse.BodyHandlers.ofString());
        log.debug(testfile.getFile()+ ": " + response.body());

        // start bulk execution
        request = HttpRequest.newBuilder()
                .POST(HttpRequest.BodyPublishers.ofString(this.objectMapper.writeValueAsString(injects)))
                .uri(URI.create(opentestingurl + "trigger/bulk"))
                .header("Content-Type", "application/json")
                .build();
        log.debug("Bulkrequest " + request.uri());
        response = client.send(request, HttpResponse.BodyHandlers.ofString());
        log.debug("opentesting trigger bulk: " + response.body());

        if(response.body().contains("invalid"))
            return false;

        // read bulkid from result
        JsonNode opentestingdata = objectMapper.createObjectNode();

        JsonNode bulkIdRoot = objectMapper.readTree(response.body());
        //log.error(response.body());
        String bulkid = bulkIdRoot.findValue("bulkid").textValue();

        // wait for the test case result - there should not be open test cases anymore:
        // "percentage":0.0,"all":1,"success":0,"open":1,"failed":0,"mandatorySuccess":false,"allSuccess":false
        int openchecks = 1;

        String result = "";
        while (openchecks > 0) {
            Sleeper.sleep(SLEEPTIMEMS);
            result = getBulkResult(bulkid);
            opentestingdata = objectMapper.readTree(result);
            openchecks = opentestingdata.findValue("open").asInt();
        }
        log.debug("opentesting bulk result: " + result);

        // validation
        boolean mandatorySuccess = opentestingdata.findValue("mandatorySuccess").asBoolean();
        if (!mandatorySuccess) summary_mandatorySuccess = false;
        boolean allSuccess = opentestingdata.findValue("allSuccess").asBoolean();
        if (!allSuccess) summary_allSuccess = false;
        summary_all += opentestingdata.findValue("all").asInt();
        summary_success += opentestingdata.findValue("success").asInt();
        summary_failed += opentestingdata.findValue("failed").asInt();

        // more detailed
        JsonNode checks = opentestingdata.findValue("checks");
        Iterator<JsonNode> check = checks.elements();
        while(check.hasNext()){
            JsonNode next = check.next();

            OTATestResult testResult = new OTATestResult();
            testResult.setTestName(id);
            testResult.setCheckName( next.findValue("checkid").textValue());
            JsonNode description = next.findValue("description"); //optional
            if (description != null) testResult.setDescription(description.textValue());
            testResult.setResult(next.findValue("success").asBoolean());
            testResults.add(testResult);
        }

        if (mandatoryonly) {
            if (!allSuccess) {
                log.warn("some non-mandatory checks failed: " + opentestingdata.findValue("failed").asInt());
            }
            return mandatorySuccess;
        } else {
            return allSuccess;
        }
    }

    /**
     * request bulk result by bulkid
     *
     * @param bulkid Bulk ID
     * @return the result of the bulk
     * @throws InterruptedException
     * @throws IOException
     */
    private String getBulkResult(String bulkid) throws IOException, InterruptedException {

        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(opentestingurl + "reporting/bulk?bulkid=" + bulkid))
                .build();
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        log.debug("opentesting bulk result: " + response.body());

        return response.body();
    }

    /**
     * read file content from resources folder
     *
     * @param filename name of the file
     * @return file content
     * @throws IOException
     */
    private String getResourceContent(URL filename) throws IOException {
        BufferedInputStream is = new BufferedInputStream(filename.openStream());
        return new String(is.readAllBytes(), StandardCharsets.UTF_8);
    }

    /**
     * Json string to JsonNode
     *
     * @param input json input
     * @return JsonNode
     * @throws JsonProcessingException
     */
    public JsonNode json2JsonNode(String input) throws JsonProcessingException {
        return objectMapper.readTree(input);
    }

    /**
     * map from Json string using JsonNode
     *
     * @param input json input
     * @return map with attributes
     * @throws JsonProcessingException
     */
    public Map<String, Object> json2Map(String input) throws JsonProcessingException {
        return objectMapper.convertValue(json2JsonNode(input), new TypeReference<Map<String, Object>>() {
        });
    }

}
