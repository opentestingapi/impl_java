package org.opentesting.systemtest.util;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;

import org.opentesting.common.Sleeper;
import org.springframework.core.io.ClassPathResource;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.net.URI;
import java.net.URL;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * this class will wrap the test case execution from definition
 */
@Slf4j
public abstract class OpenTestingApiTester {

    private final int SLEEPTIMEMS = 5000;

    private ObjectMapper objectMapper = new ObjectMapper();

    private HttpClient client = HttpClient.newBuilder().build();

    private static String opentestingurl;    

    //reporting
    @Getter
    private static int summary_all = 0;
    @Getter
    private static int summary_success = 0;
    @Getter
    private static int summary_failed = 0;
    @Getter
    private static boolean summary_mandatorySuccess = true;
    @Getter
    private static boolean summary_allSuccess = true;

    /**
     * initialize your environment
     */
    protected static void init() {     
        opentestingurl = "http://localhost:50000/";
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(String testfile, String folderwithfiles, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, folderwithfiles, injects, true);
    }

    /**
     * a default configuration
     *
     * @param folderWithFiles
     * @return
     * @throws IOException
     * @throws InterruptedException
     */
    public boolean testDefault(String folderWithFiles) throws IOException, InterruptedException {
        String testFile = folderWithFiles +"/test.json";

        JsonNode testCase = objectMapper.readTree(new ClassPathResource(testFile).getInputStream());

        JsonNode id = testCase.findValue("id");
        List<String> injects = new ArrayList<>();

        //only the first found one
        for (JsonNode inject : testCase.findValues("injectid"))
            if (injects.isEmpty()) injects.add(id.textValue() + "." + inject.textValue());

        return test(testFile, folderWithFiles, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(String testfile, String folderwithfiles, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //create url list
        List<URL> urls = new ArrayList<>();
        URL url = getClass().getClassLoader().getResource(folderwithfiles);
        String path = url.getPath();
        for (File f : new File(path).listFiles()) {
            URL e = f.toURI().toURL();
            urls.add(e);
        }

        return test(getClass().getClassLoader().getResource(testfile), urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param files relative path required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(String testfile, List<String> files, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, files, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param files relative path required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(String testfile, List<String> files, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //create url list
        List<URL> urls = new ArrayList<>();
        for (String f : files) {
            urls.add(getClass().getClassLoader().getResource(f));
        }

        return test(getClass().getClassLoader().getResource(testfile), urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(URL testfile, URL folderwithfiles, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, folderwithfiles, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile relative path testfile in resources
     * @param folderwithfiles relative path folder containing required files in resources
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(URL testfile, URL folderwithfiles, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //create url list
        List<URL> urls = new ArrayList<>();
        String path = folderwithfiles.getPath();
        for (File f : new File(path).listFiles()) {
            urls.add(f.toURI().toURL());
        }

        return test(testfile, urls, injects, mandatoryonly);
    }

    /**
     * execute a test case with mandatory check validation only
     *
     * @param testfile URL testfile
     * @param files URL required files
     * @param injects Injects triggered for the test
     * @return test case result
     */
    public boolean test(URL testfile, List<URL> files, List<String> injects) throws IOException, InterruptedException {
        return test(testfile, files, injects, true);
    }

    /**
     * execute a test case
     *
     * @param testfile URL testfile
     * @param files URL required files
     * @param injects Injects triggered for the test
     * @param mandatoryonly validate only mandatory checks (default true)
     * @return test case result
     */
    public boolean test(URL testfile, List<URL> files, List<String> injects, boolean mandatoryonly) throws IOException, InterruptedException {

        //read test case
        String testcase = this.getResourceContent(testfile);

        //read attributes
        Map<String,Object> testcasemap = this.json2Map(testcase);
        String id = (String) testcasemap.get("id");

        // upload test case files
        HttpRequest request;
        HttpResponse<String> response;
        for (URL file : files) {
            request = HttpRequest.newBuilder()
                    .POST(HttpRequest.BodyPublishers.ofString(getResourceContent(file)))
                    .uri(URI.create(opentestingurl + "upload/file/"+id+"/"+Paths.get(file.getPath()).getFileName().toString()))
                    .header("Content-Type", "application/json")
                    .build();
            response = client.send(request, HttpResponse.BodyHandlers.ofString());
            log.debug(file.getFile()+ ": " + response.body());
        }

        // upload test case
        request = HttpRequest.newBuilder()
                .POST(HttpRequest.BodyPublishers.ofString(testcase))
                .uri(URI.create(opentestingurl + "upload/test"))
                .header("Content-Type", "application/json")
                .build();
        response = client.send(request, HttpResponse.BodyHandlers.ofString());
        log.debug(testfile.getFile()+ ": " + response.body());

        // start bulk execution
        request = HttpRequest.newBuilder()
                .POST(HttpRequest.BodyPublishers.ofString(this.objectMapper.writeValueAsString(injects)))
                .uri(URI.create(opentestingurl + "trigger/bulk"))
                .header("Content-Type", "application/json")
                .build();
        log.debug("Bulkrequest " + request.uri());
        response = client.send(request, HttpResponse.BodyHandlers.ofString());
        log.debug("opentesting trigger bulk: " + response.body());

        if(response.body().contains("invalid"))
            return false;

        // read bulkid from result
        Map<String, Object> opentestingdata = json2Map(response.body());
        String bulkid = (String) opentestingdata.get("bulkid");

        // wait for the test case result - there should not be open test cases anymore:
        // "percentage":0.0,"all":1,"success":0,"open":1,"failed":0,"mandatorySuccess":false,"allSuccess":false
        int openchecks = 1;
        String result = "";
        while (openchecks > 0) {
            Sleeper.sleep(SLEEPTIMEMS);
            result = getBulkResult(bulkid);
            opentestingdata = json2Map(result);
            openchecks = (Integer) opentestingdata.get("open");
        }
        log.debug("opentesting bulk result: " + result);

        // validation
        boolean mandatorySuccess = (Boolean) opentestingdata.get("mandatorySuccess");
        if (!mandatorySuccess) summary_mandatorySuccess = false;
        boolean allSuccess = (Boolean) opentestingdata.get("allSuccess");
        if (!allSuccess) summary_allSuccess = false;
        summary_all += (Integer) opentestingdata.get("all");
        summary_success += (Integer) opentestingdata.get("success");
        summary_failed += (Integer) opentestingdata.get("failed");
        if (mandatoryonly) {
            if (!allSuccess) {
                log.warn("some non-mandatory checks failed: " + opentestingdata.get("failed"));
            }
            return mandatorySuccess;
        } else {
            return allSuccess;
        }
    }

    /**
     * request bulk result by bulkid
     *
     * @param bulkid Bulk ID
     * @return the result of the bulk
     * @throws InterruptedException
     * @throws IOException
     */
    private String getBulkResult(String bulkid) throws IOException, InterruptedException {

        HttpRequest request = HttpRequest.newBuilder()
                .uri(URI.create(opentestingurl + "reporting/bulk?bulkid=" + bulkid))
                .build();
        HttpResponse<String> response = client.send(request, HttpResponse.BodyHandlers.ofString());
        log.debug("opentesting bulk result: " + response.body());

        return response.body();
    }

    /**
     * read file content from resources folder
     *
     * @param filename name of the file
     * @return file content
     * @throws IOException
     */
    private String getResourceContent(URL filename) throws IOException {
        BufferedInputStream is = new BufferedInputStream(filename.openStream());
        return new String(is.readAllBytes(), StandardCharsets.UTF_8);
    }

    /**
     * Json string to JsonNode
     *
     * @param input json input
     * @return JsonNode
     * @throws JsonProcessingException
     */
    public JsonNode json2JsonNode(String input) throws JsonProcessingException {
        return objectMapper.readTree(input);
    }

    /**
     * map from Json string using JsonNode
     *
     * @param input json input
     * @return map with attributes
     * @throws JsonProcessingException
     */
    public Map<String, Object> json2Map(String input) throws JsonProcessingException {
        return objectMapper.convertValue(json2JsonNode(input), new TypeReference<Map<String, Object>>() {
        });
    }

}